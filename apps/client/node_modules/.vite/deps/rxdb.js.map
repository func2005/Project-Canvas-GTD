{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/custom-index.ts"],
  "sourcesContent": ["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n *\n * We really often have to craft an index string for a given document.\n * Performance of everything in this file is very important\n * which is why the code sometimes looks strange.\n * Run performance tests before and after you touch anything here!\n */\n\nimport {\n    getSchemaByObjectPath\n} from './rx-schema-helper.ts';\nimport type {\n    JsonSchema,\n    RxDocumentData,\n    RxJsonSchema\n} from './types/index.ts';\nimport {\n    ensureNotFalsy,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './plugins/utils/index.ts';\nimport {\n    INDEX_MAX,\n    INDEX_MIN\n} from './query-planner.ts';\n\n\n/**\n * Prepare all relevant information\n * outside of the returned function\n * from getIndexableStringMonad()\n * to save performance when the returned\n * function is called many times.\n */\ntype IndexMetaField<RxDocType> = {\n    fieldName: string;\n    schemaPart: JsonSchema;\n    /*\n     * Only in number fields.\n     */\n    parsedLengths?: ParsedLengths;\n    getValue: ObjectPathMonadFunction<RxDocType>;\n    getIndexStringPart: (docData: RxDocumentData<RxDocType>) => string;\n};\n\nexport function getIndexMeta<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): IndexMetaField<RxDocType>[] {\n    const fieldNameProperties: IndexMetaField<RxDocType>[] = index.map(fieldName => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        if (!schemaPart) {\n            throw new Error('not in schema: ' + fieldName);\n        }\n        const type = schemaPart.type;\n        let parsedLengths: ParsedLengths | undefined;\n        if (type === 'number' || type === 'integer') {\n            parsedLengths = getStringLengthOfIndexNumber(\n                schemaPart\n            );\n        }\n\n        const getValue = objectPathMonad(fieldName);\n        const maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\n\n        let getIndexStringPart: (docData: RxDocumentData<RxDocType>) => string;\n        if (type === 'string') {\n            getIndexStringPart = docData => {\n                let fieldValue = getValue(docData);\n                if (!fieldValue) {\n                    fieldValue = '';\n                }\n                return fieldValue.padEnd(maxLength, ' ');\n            };\n        } else if (type === 'boolean') {\n            getIndexStringPart = docData => {\n                const fieldValue = getValue(docData);\n                return fieldValue ? '1' : '0';\n            };\n        } else { // number\n            getIndexStringPart = docData => {\n                const fieldValue = getValue(docData);\n                return getNumberIndexString(\n                    parsedLengths as any,\n                    fieldValue\n                );\n            };\n        }\n\n        const ret: IndexMetaField<RxDocType> = {\n            fieldName,\n            schemaPart,\n            parsedLengths,\n            getValue,\n            getIndexStringPart\n        };\n        return ret;\n    });\n    return fieldNameProperties;\n}\n\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): (docData: RxDocumentData<RxDocType>) => string {\n    const fieldNameProperties = getIndexMeta(schema, index);\n    const fieldNamePropertiesAmount = fieldNameProperties.length;\n    const indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\n\n\n    /**\n     * @hotPath Performance of this function is very critical!\n     */\n    const ret = function (docData: RxDocumentData<RxDocType>): string {\n        let str = '';\n        for (let i = 0; i < fieldNamePropertiesAmount; ++i) {\n            str += indexPartsFunctions[i](docData);\n        }\n        return str;\n    };\n    return ret;\n}\n\n\ndeclare type ParsedLengths = {\n    minimum: number;\n    maximum: number;\n    nonDecimals: number;\n    decimals: number;\n    roundedMinimum: number;\n};\nexport function getStringLengthOfIndexNumber(\n    schemaPart: JsonSchema\n): ParsedLengths {\n    const minimum = Math.floor(schemaPart.minimum as number);\n    const maximum = Math.ceil(schemaPart.maximum as number);\n    const multipleOf: number = schemaPart.multipleOf as number;\n\n    const valueSpan = maximum - minimum;\n    const nonDecimals = valueSpan.toString().length;\n\n    const multipleOfParts = multipleOf.toString().split('.');\n    let decimals = 0;\n    if (multipleOfParts.length > 1) {\n        decimals = multipleOfParts[1].length;\n    }\n    return {\n        minimum,\n        maximum,\n        nonDecimals,\n        decimals,\n        roundedMinimum: minimum\n    };\n}\n\nexport function getIndexStringLength<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): number {\n    const fieldNameProperties = getIndexMeta(schema, index);\n    let length = 0;\n    fieldNameProperties.forEach(props => {\n        const schemaPart = props.schemaPart;\n        const type = schemaPart.type;\n\n        if (type === 'string') {\n            length += schemaPart.maxLength as number;\n        } else if (type === 'boolean') {\n            length += 1;\n        } else {\n            const parsedLengths = props.parsedLengths as ParsedLengths;\n            length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n        }\n\n    });\n    return length;\n}\n\n\nexport function getPrimaryKeyFromIndexableString(\n    indexableString: string,\n    primaryKeyLength: number\n): string {\n    const paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n    // we can safely trim here because the primary key is not allowed to start or end with a space char.\n    const primaryKey = paddedPrimaryKey.trim();\n    return primaryKey;\n}\n\n\nexport function getNumberIndexString(\n    parsedLengths: ParsedLengths,\n    fieldValue: number\n): string {\n    /**\n     * Ensure that the given value is in the boundaries\n     * of the schema, otherwise it would create a broken index string.\n     * This can happen for example if you have a minimum of 0\n     * and run a query like\n     * selector {\n     *  numField: { $gt: -1000 }\n     * }\n     */\n    if (typeof fieldValue === 'undefined') {\n        fieldValue = 0;\n    }\n    if (fieldValue < parsedLengths.minimum) {\n        fieldValue = parsedLengths.minimum;\n    }\n    if (fieldValue > parsedLengths.maximum) {\n        fieldValue = parsedLengths.maximum;\n    }\n\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n    let str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n\n    if (parsedLengths.decimals > 0) {\n        const splitByDecimalPoint = fieldValue.toString().split('.');\n        const decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n        str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n    }\n    return str;\n}\n\nexport function getStartIndexStringFromLowerBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    lowerBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = lowerBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n                if (typeof bound === 'string') {\n                    str += (bound as string).padEnd(maxLength, ' ');\n                } else {\n                    // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n                    str += ''.padEnd(maxLength, ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '0';\n                } else if (bound === INDEX_MIN) {\n                    str += '0';\n                } else if (bound === INDEX_MAX) {\n                    str += '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MIN) {\n                    const fillChar = '0';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else if (bound === INDEX_MAX) {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        parsedLengths.maximum\n                    );\n                } else {\n                    const add = getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                    str += add;\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n\nexport function getStartIndexStringFromUpperBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    upperBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = upperBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n                if (typeof bound === 'string' && bound !== INDEX_MAX) {\n                    str += (bound as string).padEnd(maxLength, ' ');\n                } else if (bound === INDEX_MIN) {\n                    str += ''.padEnd(maxLength, ' ');\n                } else {\n                    str += ''.padEnd(maxLength, INDEX_MAX);\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MAX) {\n                    const fillChar = '9';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else if (bound === INDEX_MIN) {\n                    const fillChar = '0';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n/**\n * Used in storages where it is not possible\n * to define inclusiveEnd/inclusiveStart\n */\nexport function changeIndexableStringByOneQuantum(str: string, direction: 1 | -1): string {\n    const lastChar = str.slice(-1);\n    let charCode = lastChar.charCodeAt(0);\n    charCode = charCode + direction;\n    const withoutLastChar = str.slice(0, -1);\n    return withoutLastChar + String.fromCharCode(charCode);\n}\n"],
  "mappings": "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",
  "names": ["getIndexMeta", "schema", "index", "fieldNameProperties", "map", "fieldName", "schemaPart", "getSchemaByObjectPath", "Error", "type", "parsedLengths", "getStringLengthOfIndexNumber", "getValue", "objectPathMonad", "maxLength", "getIndexStringPart", "docData", "fieldValue", "padEnd", "getNumberIndexString", "ret", "getIndexableStringMonad", "fieldNamePropertiesAmount", "length", "indexPartsFunctions", "r", "str", "i", "minimum", "Math", "floor", "maximum", "ceil", "multipleOf", "valueSpan", "nonDecimals", "toString", "multipleOfParts", "split", "decimals", "roundedMinimum", "getIndexStringLength", "forEach", "props", "getPrimaryKeyFromIndexableString", "indexableString", "primaryKeyLength", "paddedPrimaryKey", "slice", "primaryKey", "trim", "nonDecimalsValueAsString", "padStart", "splitByDecimalPoint", "decimalValueAsString", "getStartIndexStringFromLowerBound", "lowerBound", "idx", "bound", "ensureNotFalsy", "INDEX_MIN", "INDEX_MAX", "boolToStr", "fillChar", "repeat", "add", "getStartIndexStringFromUpperBound", "upperBound", "changeIndexableStringByOneQuantum", "direction", "lastChar", "charCode", "charCodeAt", "withoutLastChar", "String", "fromCharCode"]
}
