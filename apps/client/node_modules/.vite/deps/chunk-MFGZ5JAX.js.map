{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/rx-schema.ts", "../../../../../node_modules/rxdb/src/rx-change-event.ts", "../../../../../node_modules/rxdb/src/incremental-write.ts", "../../../../../node_modules/rxdb/src/rx-document.ts", "../../../../../node_modules/rxdb/src/query-cache.ts", "../../../../../node_modules/rxdb/src/doc-cache.ts", "../../../../../node_modules/rxdb/src/rx-query-single-result.ts", "../../../../../node_modules/event-reduce-js/src/util.ts", "../../../../../node_modules/event-reduce-js/src/states/state-resolver.ts", "../../../../../node_modules/event-reduce-js/src/states/index.ts", "../../../../../node_modules/array-push-at-sort-position/dist/esm/index.js", "../../../../../node_modules/event-reduce-js/src/actions/action-functions.ts", "../../../../../node_modules/event-reduce-js/src/actions/index.ts", "../../../../../node_modules/binary-decision-diagram/src/minimal-string/string-format.ts", "../../../../../node_modules/binary-decision-diagram/src/util.ts", "../../../../../node_modules/binary-decision-diagram/src/minimal-string/minimal-string-to-simple-bdd.ts", "../../../../../node_modules/binary-decision-diagram/src/minimal-string/resolve-with-simple-bdd.ts", "../../../../../node_modules/event-reduce-js/src/bdd/bdd.generated.ts", "../../../../../node_modules/event-reduce-js/src/index.ts", "../../../../../node_modules/rxdb/src/event-reduce.ts", "../../../../../node_modules/rxdb/src/rx-query.ts", "../../../../../node_modules/rxdb/src/rx-database-internal-store.ts", "../../../../../node_modules/rxdb/src/rx-collection-helper.ts", "../../../../../node_modules/rxdb/src/rx-document-prototype-merge.ts", "../../../../../node_modules/rxdb/src/replication-protocol/default-conflict-handler.ts", "../../../../../node_modules/rxdb/src/change-event-buffer.ts", "../../../../../node_modules/rxdb/src/rx-collection.ts", "../../../../../node_modules/custom-idle-queue/dist/es/index.js", "../../../../../node_modules/rxdb/src/rx-database.ts"],
  "sourcesContent": ["import {\n    overwriteGetterForCaching,\n    isMaybeReadonlyArray,\n    deepEqual\n} from './plugins/utils/index.ts';\nimport {\n    newRxError,\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\n\nimport type {\n    DeepMutable,\n    DeepReadonly,\n    HashFunction,\n    MaybeReadonly,\n    RxDocument,\n    RxDocumentData,\n    RxJsonSchema,\n    StringKeys\n} from './types/index.d.ts';\nimport {\n    fillWithDefaultSettings,\n    getComposedPrimaryKeyOfDocumentData,\n    getFinalFields,\n    getPrimaryFieldOfPrimaryKey,\n    getSchemaByObjectPath,\n    normalizeRxJsonSchema\n} from './rx-schema-helper.ts';\nimport { overwritable } from './overwritable.ts';\n\nexport class RxSchema<RxDocType = any> {\n    public indexes: MaybeReadonly<string[]>[];\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public finalFields: string[];\n\n    constructor(\n        public readonly jsonSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        public readonly hashFunction: HashFunction\n    ) {\n        this.indexes = getIndexes(this.jsonSchema);\n\n        // primary is always required\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);\n\n        /**\n         * Many people accidentally put in wrong schema state\n         * without the dev-mode plugin, so we need this check here\n         * even in non-dev-mode.\n         */\n        if (!jsonSchema.properties[this.primaryPath].maxLength) {\n            throw newRxError('SC39', { schema: jsonSchema });\n        }\n\n        this.finalFields = getFinalFields(this.jsonSchema);\n    }\n\n    public get version(): number {\n        return this.jsonSchema.version;\n    }\n\n    public get defaultValues(): { [P in keyof RxDocType]: RxDocType[P] } {\n        const values = {} as { [P in keyof RxDocType]: RxDocType[P] };\n        Object\n            .entries(this.jsonSchema.properties)\n            .filter(([, v]) => Object.prototype.hasOwnProperty.call(v, 'default'))\n            .forEach(([k, v]) => (values as any)[k] = (v as any).default);\n        return overwriteGetterForCaching(\n            this,\n            'defaultValues',\n            values\n        );\n    }\n\n    /**\n     * @overrides itself on the first call\n     */\n    public get hash(): Promise<string> {\n        return overwriteGetterForCaching(\n            this,\n            'hash',\n            this.hashFunction(JSON.stringify(this.jsonSchema))\n        );\n    }\n\n    /**\n     * checks if a given change on a document is allowed\n     * Ensures that:\n     * - final fields are not modified\n     * @throws {Error} if not valid\n     */\n    validateChange(dataBefore: any, dataAfter: any): void {\n        this.finalFields.forEach(fieldName => {\n            if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {\n                throw newRxError('DOC9', {\n                    dataBefore,\n                    dataAfter,\n                    fieldName,\n                    schema: this.jsonSchema\n                });\n            }\n        });\n    }\n\n    /**\n     * creates the schema-based document-prototype,\n     * see RxCollection.getDocumentPrototype()\n     */\n    public getDocumentPrototype(): any {\n        const proto: any = {};\n\n        /**\n         * On the top level, we know all keys\n         * and therefore do not have to create a new Proxy object\n         * for each document. Instead we define the getter in the prototype once.\n         */\n        const pathProperties = getSchemaByObjectPath(\n            this.jsonSchema,\n            ''\n        );\n        Object.keys(pathProperties)\n            .forEach(key => {\n                const fullPath = key;\n\n                // getter - value\n                proto.__defineGetter__(\n                    key,\n                    function (this: RxDocument) {\n                        if (!this.get || typeof this.get !== 'function') {\n                            /**\n                             * When an object gets added to the state of a vuejs-component,\n                             * it happens that this getter is called with another scope.\n                             * To prevent errors, we have to return undefined in this case\n                             */\n                            return undefined;\n                        }\n                        const ret = this.get(fullPath);\n                        return ret;\n                    }\n                );\n                // getter - observable$\n                Object.defineProperty(proto, key + '$', {\n                    get: function () {\n                        return this.get$(fullPath);\n                    },\n                    enumerable: false,\n                    configurable: false\n                });\n                // getter - reactivity$$\n                Object.defineProperty(proto, key + '$$', {\n                    get: function () {\n                        return this.get$$(fullPath);\n                    },\n                    enumerable: false,\n                    configurable: false\n                });\n                // getter - populate_\n                Object.defineProperty(proto, key + '_', {\n                    get: function () {\n                        return this.populate(fullPath);\n                    },\n                    enumerable: false,\n                    configurable: false\n                });\n            });\n\n        overwriteGetterForCaching(\n            this,\n            'getDocumentPrototype',\n            () => proto\n        );\n        return proto;\n    }\n\n\n    getPrimaryOfDocumentData(\n        documentData: Partial<RxDocType>\n    ): string {\n        return getComposedPrimaryKeyOfDocumentData(\n            this.jsonSchema,\n            documentData\n        );\n    }\n}\n\nexport function getIndexes<RxDocType = any>(\n    jsonSchema: RxJsonSchema<RxDocType>\n): MaybeReadonly<string[]>[] {\n    return (jsonSchema.indexes || []).map(index => isMaybeReadonlyArray(index) ? index : [index]);\n}\n\n/**\n * array with previous version-numbers\n */\nexport function getPreviousVersions(schema: RxJsonSchema<any>): number[] {\n    const version = schema.version ? schema.version : 0;\n    let c = 0;\n    return new Array(version)\n        .fill(0)\n        .map(() => c++);\n}\n\nexport function createRxSchema<T>(\n    jsonSchema: RxJsonSchema<T>,\n    hashFunction: HashFunction,\n    runPreCreateHooks = true\n): RxSchema<T> {\n    if (runPreCreateHooks) {\n        runPluginHooks('preCreateRxSchema', jsonSchema);\n    }\n\n    let useJsonSchema = fillWithDefaultSettings(jsonSchema);\n    useJsonSchema = normalizeRxJsonSchema(useJsonSchema);\n    overwritable.deepFreezeWhenDevMode(useJsonSchema);\n\n    const schema = new RxSchema(useJsonSchema, hashFunction);\n    runPluginHooks('createRxSchema', schema);\n    return schema;\n}\n\nexport function isRxSchema(obj: any): boolean {\n    return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport function toTypedRxJsonSchema<T extends DeepReadonly<RxJsonSchema<any>>>(schema: T): DeepMutable<T> {\n    return schema as any;\n}\n", "/**\n * RxChangeEvents a emitted when something in the database changes\n * they can be grabbed by the observables of database, collection and document\n */\n\nimport type {\n    ChangeEvent as EventReduceChangeEvent,\n} from 'event-reduce-js';\nimport { overwritable } from './overwritable.ts';\n\nimport type {\n    EventBulk,\n    RxChangeEvent,\n    RxChangeEventBulk,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport { appendToArray, getFromMapOrCreate } from './plugins/utils/index.ts';\n\nexport function getDocumentDataOfRxChangeEvent<T>(\n    rxChangeEvent: RxStorageChangeEvent<T>\n): RxDocumentData<T> {\n    if ((rxChangeEvent as any).documentData) {\n        return (rxChangeEvent as any).documentData;\n    } else {\n        return (rxChangeEvent as any).previousDocumentData;\n    }\n}\n\n/**\n * Might return null which means an\n * already deleted document got modified but still is deleted.\n * These kind of events are not relevant for the event-reduce algorithm\n * and must be filtered out.\n */\nexport function rxChangeEventToEventReduceChangeEvent<DocType>(\n    rxChangeEvent: RxStorageChangeEvent<DocType>\n): EventReduceChangeEvent<DocType> | null {\n    switch (rxChangeEvent.operation) {\n        case 'INSERT':\n            return {\n                operation: rxChangeEvent.operation,\n                id: rxChangeEvent.documentId,\n                doc: rxChangeEvent.documentData as any,\n                previous: null\n            };\n        case 'UPDATE':\n            return {\n                operation: rxChangeEvent.operation,\n                id: rxChangeEvent.documentId,\n                doc: overwritable.deepFreezeWhenDevMode(rxChangeEvent.documentData) as any,\n                previous: rxChangeEvent.previousDocumentData ? rxChangeEvent.previousDocumentData as any : 'UNKNOWN'\n            };\n        case 'DELETE':\n            return {\n                operation: rxChangeEvent.operation,\n                id: rxChangeEvent.documentId,\n                doc: null,\n                previous: rxChangeEvent.previousDocumentData as DocType\n            };\n    }\n}\n\n/**\n * Flattens the given events into a single array of events.\n * Used mostly in tests.\n */\nexport function flattenEvents<EventType>(\n    input: EventBulk<EventType, any> | EventBulk<EventType, any>[] | EventType | EventType[]\n): EventType[] {\n    const output: EventType[] = [];\n    if (Array.isArray(input)) {\n        input.forEach(inputItem => {\n            const add = flattenEvents(inputItem);\n            appendToArray(output, add);\n        });\n    } else {\n        if ((input as any).id && (input as any).events) {\n            // is bulk\n            (input as EventBulk<EventType, any>)\n                .events\n                .forEach(ev => output.push(ev));\n        } else {\n            output.push(input as any);\n        }\n    }\n\n    const usedIds = new Set<string>();\n    const nonDuplicate: EventType[] = [];\n\n    function getEventId(ev: any): string {\n        return [\n            ev.documentId,\n            ev.documentData ? ev.documentData._rev : '',\n            ev.previousDocumentData ? ev.previousDocumentData._rev : ''\n        ].join('|');\n    }\n\n    output.forEach(ev => {\n        const eventId = getEventId(ev);\n        if (!usedIds.has(eventId)) {\n            usedIds.add(eventId);\n            nonDuplicate.push(ev);\n        }\n    });\n\n    return nonDuplicate;\n}\n\nconst EVENT_BULK_CACHE = new Map<RxChangeEventBulk<any>, RxChangeEvent<any>[]>();\nexport function rxChangeEventBulkToRxChangeEvents(\n    eventBulk: RxChangeEventBulk<any>\n) {\n    return getFromMapOrCreate(\n        EVENT_BULK_CACHE,\n        eventBulk,\n        () => {\n            const events: RxChangeEvent<any>[] = new Array(eventBulk.events.length);\n            const rawEvents = eventBulk.events;\n            const collectionName = eventBulk.collectionName;\n            const isLocal = eventBulk.isLocal;\n            const deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n            for (let index = 0; index < rawEvents.length; index++) {\n                const event = rawEvents[index];\n                events[index] = {\n                    documentId: event.documentId,\n                    collectionName,\n                    isLocal,\n                    operation: event.operation,\n                    documentData: deepFreezeWhenDevMode(event.documentData) as any,\n                    previousDocumentData: deepFreezeWhenDevMode(event.previousDocumentData) as any\n                };\n            }\n            return events;\n        }\n    );\n}\n", "import {\n    isBulkWriteConflictError,\n    rxStorageWriteErrorToRxError\n} from './rx-error.ts';\nimport type {\n    ModifyFunction,\n    BulkWriteRow,\n    MaybePromise,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxError,\n    RxStorageBulkWriteResponse,\n    RxStorageInstance,\n    StringKeys,\n    WithDeleted\n} from './types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    getFromMapOrCreate,\n    getFromMapOrThrow,\n    getHeightOfRevision,\n    stripMetaDataFromDocument\n} from './plugins/utils/index.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse } from './rx-storage-helper.ts';\n\n\n\nexport type IncrementalWriteModifier<RxDocType> = (\n    doc: RxDocumentData<RxDocType>\n) => MaybePromise<RxDocumentData<RxDocType>> | MaybePromise<RxDocumentWriteData<RxDocType>>;\n\n\ntype IncrementalWriteQueueItem<RxDocType> = {\n    lastKnownDocumentState: RxDocumentData<RxDocType>;\n    modifier: IncrementalWriteModifier<RxDocType>;\n    resolve: (d: RxDocumentData<RxDocType>) => void;\n    reject: (error: RxError) => void;\n};\n\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport class IncrementalWriteQueue<RxDocType> {\n    public queueByDocId = new Map<string, IncrementalWriteQueueItem<RxDocType>[]>();\n    public isRunning: boolean = false;\n\n    constructor(\n        public readonly storageInstance: RxStorageInstance<RxDocType, any, any>,\n        public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>,\n        // can be used to run hooks etc.\n        public readonly preWrite: (newData: RxDocumentData<RxDocType>, oldData: RxDocumentData<RxDocType>) => MaybePromise<void>,\n        public readonly postWrite: (docData: RxDocumentData<RxDocType>) => void\n\n    ) { }\n\n    addWrite(\n        lastKnownDocumentState: RxDocumentData<RxDocType>,\n        modifier: IncrementalWriteModifier<RxDocType>\n    ): Promise<RxDocumentData<RxDocType>> {\n        const docId: string = lastKnownDocumentState[this.primaryPath] as any;\n        const ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n        const ret = new Promise<RxDocumentData<RxDocType>>((resolve, reject) => {\n            const item: IncrementalWriteQueueItem<RxDocType> = {\n                lastKnownDocumentState,\n                modifier,\n                resolve,\n                reject\n            };\n            ensureNotFalsy(ar).push(item);\n            this.triggerRun();\n        });\n        return ret;\n    }\n\n    async triggerRun(): Promise<void> {\n        if (\n            this.isRunning === true ||\n            this.queueByDocId.size === 0\n        ) {\n            // already running\n            return;\n        }\n        this.isRunning = true;\n        const writeRows: BulkWriteRow<RxDocType>[] = [];\n\n        /**\n         * 'take over' so that while the async functions runs,\n         * new incremental updates could be added from the outside.\n         */\n        const itemsById = this.queueByDocId;\n        this.queueByDocId = new Map();\n        await Promise.all(\n            Array.from(itemsById.entries())\n                .map(async ([_docId, items]) => {\n                    const oldData = findNewestOfDocumentStates(\n                        items.map(i => i.lastKnownDocumentState)\n                    );\n                    let newData = oldData;\n                    for (const item of items) {\n                        try {\n                            newData = await item.modifier(\n                                /**\n                                 * We have to clone() each time because the modifier\n                                 * might throw while it already changed some properties\n                                 * of the document.\n                                 */\n                                clone(newData)\n                            ) as any;\n                        } catch (err: any) {\n                            item.reject(err);\n                            item.reject = () => { };\n                            item.resolve = () => { };\n                        }\n                    }\n\n                    try {\n                        await this.preWrite(newData, oldData);\n                    } catch (err: any) {\n                        /**\n                         * If the before-hooks fail,\n                         * we reject all of the writes because it is\n                         * not possible to determine which one is to blame.\n                         */\n                        items.forEach(item => item.reject(err));\n                        return;\n                    }\n                    writeRows.push({\n                        previous: oldData,\n                        document: newData\n                    });\n                })\n        );\n        const writeResult: RxStorageBulkWriteResponse<RxDocType> = writeRows.length > 0 ?\n            await this.storageInstance.bulkWrite(writeRows, 'incremental-write') :\n            { error: [] };\n\n        // process success\n        await Promise.all(\n            getWrittenDocumentsFromBulkWriteResponse(this.primaryPath, writeRows, writeResult).map(result => {\n                const docId = result[this.primaryPath] as string;\n                this.postWrite(result);\n                const items = getFromMapOrThrow(itemsById, docId);\n                items.forEach(item => item.resolve(result));\n            })\n        );\n\n        // process errors\n        writeResult.error\n            .forEach(error => {\n                const docId = error.documentId;\n                const items = getFromMapOrThrow(itemsById, docId);\n                const isConflict = isBulkWriteConflictError<RxDocType>(error);\n                if (isConflict) {\n                    // had conflict -> retry afterwards\n                    const ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n                    /**\n                     * Add the items back to this.queueByDocId\n                     * by maintaining the original order.\n                     */\n                    items\n                        .reverse()\n                        .forEach(item => {\n                            item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n                            ensureNotFalsy(ar).unshift(item);\n                        });\n                } else {\n                    // other error -> must be thrown\n                    const rxError = rxStorageWriteErrorToRxError(error);\n                    items.forEach(item => item.reject(rxError));\n                }\n            });\n        this.isRunning = false;\n\n        /**\n         * Always trigger another run\n         * because in between there might be new items\n         * been added to the queue.\n         */\n        return this.triggerRun();\n    }\n}\n\n\nexport function modifierFromPublicToInternal<RxDocType>(\n    publicModifier: ModifyFunction<RxDocType>\n): IncrementalWriteModifier<RxDocType> {\n    const ret = async (docData: RxDocumentData<RxDocType>) => {\n        const withoutMeta: WithDeleted<RxDocType> = stripMetaDataFromDocument(docData) as any;\n        withoutMeta._deleted = docData._deleted;\n        const modified = await publicModifier(withoutMeta);\n        const reattachedMeta: RxDocumentData<RxDocType> = Object.assign({}, modified, {\n            _meta: docData._meta,\n            _attachments: docData._attachments,\n            _rev: docData._rev,\n            _deleted: typeof (modified as WithDeleted<RxDocType>)._deleted !== 'undefined' ?\n                (modified as WithDeleted<RxDocType>)._deleted :\n                docData._deleted\n        });\n        if (typeof reattachedMeta._deleted === 'undefined') {\n            reattachedMeta._deleted = false;\n        }\n        return reattachedMeta;\n    };\n    return ret;\n}\n\n\nexport function findNewestOfDocumentStates<RxDocType>(\n    docs: RxDocumentData<RxDocType>[]\n): RxDocumentData<RxDocType> {\n\n    let newest = docs[0];\n    let newestRevisionHeight = getHeightOfRevision(newest._rev);\n    docs.forEach(doc => {\n        const height = getHeightOfRevision(doc._rev);\n        if (height > newestRevisionHeight) {\n            newest = doc;\n            newestRevisionHeight = height;\n        }\n    });\n    return newest;\n}\n", "import {\n    Observable\n} from 'rxjs';\nimport {\n    distinctUntilChanged,\n    filter,\n    map,\n    shareReplay,\n    startWith\n} from 'rxjs/operators';\nimport {\n    clone,\n    trimDots,\n    pluginMissing,\n    flatClone,\n    PROMISE_RESOLVE_NULL,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    getProperty,\n    getFromMapOrCreate,\n    ensureNotFalsy\n} from './plugins/utils/index.ts';\nimport {\n    newRxError\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\n\nimport type {\n    RxDocument,\n    RxCollection,\n    RxDocumentData,\n    RxDocumentWriteData,\n    UpdateQuery,\n    CRDTEntry,\n    ModifyFunction\n} from './types/index.d.ts';\nimport { getDocumentDataOfRxChangeEvent } from './rx-change-event.ts';\nimport { overwritable } from './overwritable.ts';\nimport { getSchemaByObjectPath } from './rx-schema-helper.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from './rx-storage-helper.ts';\nimport { modifierFromPublicToInternal } from './incremental-write.ts';\n\nexport const basePrototype = {\n    get primaryPath() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this.collection.schema.primaryPath;\n    },\n    get primary() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return (_this._data as any)[_this.primaryPath];\n    },\n    get revision() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this._data._rev;\n    },\n    get deleted$() {\n        const _this: RxDocument<any> = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this.$.pipe(\n            map((d: any) => d._data._deleted)\n        );\n    },\n    get deleted$$() {\n        const _this: RxDocument = this as any;\n        const reactivity = _this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            _this.deleted$,\n            _this.getLatest().deleted,\n            _this.collection.database\n        );\n    },\n    get deleted() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this._data._deleted;\n    },\n\n    getLatest(this: RxDocument): RxDocument {\n        const latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);\n        return this.collection._docCache.getCachedRxDocument(latestDocData);\n    },\n\n    /**\n     * returns the observable which emits the plain-data of this document\n     */\n    get $(): Observable<RxDocumentData<any>> {\n        const _this: RxDocument<{}, {}, {}> = this as any;\n        const id = this.primary;\n\n        return _this.collection.eventBulks$.pipe(\n            filter(bulk => !bulk.isLocal),\n            map(bulk => bulk.events.find(ev => ev.documentId === id)),\n            filter(event => !!event),\n            map(changeEvent => getDocumentDataOfRxChangeEvent(ensureNotFalsy(changeEvent))),\n            startWith(_this.collection._docCache.getLatestDocumentData(id)),\n            distinctUntilChanged((prev, curr) => prev._rev === curr._rev),\n            map(docData => (this as RxDocument<any>).collection._docCache.getCachedRxDocument(docData)),\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\n        );\n    },\n    get $$(): any {\n        const _this: RxDocument = this as any;\n        const reactivity = _this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            _this.$,\n            _this.getLatest()._data,\n            _this.collection.database\n        );\n    },\n\n    /**\n     * returns observable of the value of the given path\n     */\n    get$(this: RxDocument, path: string): Observable<any> {\n        if (overwritable.isDevMode()) {\n            if (path.includes('.item.')) {\n                throw newRxError('DOC1', {\n                    path\n                });\n            }\n\n            if (path === this.primaryPath) {\n                throw newRxError('DOC2');\n            }\n\n            // final fields cannot be modified and so also not observed\n            if (this.collection.schema.finalFields.includes(path)) {\n                throw newRxError('DOC3', {\n                    path\n                });\n            }\n\n            const schemaObj = getSchemaByObjectPath(\n                this.collection.schema.jsonSchema,\n                path\n            );\n\n            if (!schemaObj) {\n                throw newRxError('DOC4', {\n                    path\n                });\n            }\n        }\n\n        return this.$\n            .pipe(\n                map(data => getProperty(data, path)),\n                distinctUntilChanged()\n            );\n    },\n    get$$(this: RxDocument, path: string) {\n        const obs = this.get$(path);\n        const reactivity = this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            obs,\n            this.getLatest().get(path),\n            this.collection.database\n        );\n    },\n\n    /**\n     * populate the given path\n     */\n    populate(this: RxDocument, path: string): Promise<RxDocument | null> {\n        const schemaObj = getSchemaByObjectPath(\n            this.collection.schema.jsonSchema,\n            path\n        );\n        const value = this.get(path);\n        if (!value) {\n            return PROMISE_RESOLVE_NULL;\n        }\n        if (!schemaObj) {\n            throw newRxError('DOC5', {\n                path\n            });\n        }\n        if (!schemaObj.ref) {\n            throw newRxError('DOC6', {\n                path,\n                schemaObj\n            });\n        }\n\n        const refCollection: RxCollection = this.collection.database.collections[schemaObj.ref];\n        if (!refCollection) {\n            throw newRxError('DOC7', {\n                ref: schemaObj.ref,\n                path,\n                schemaObj\n            });\n        }\n\n        if (schemaObj.type === 'array') {\n            return refCollection.findByIds(value).exec().then(res => {\n                const valuesIterator = res.values();\n                return Array.from(valuesIterator) as any;\n            });\n        } else {\n            return refCollection.findOne(value).exec();\n        }\n    },\n    /**\n     * get data by objectPath\n     * @hotPath Performance here is really important,\n     * run some tests before changing anything.\n     */\n    get(this: RxDocument, objPath: string): any | null {\n        return getDocumentProperty(this, objPath);\n    },\n\n    toJSON(this: RxDocument, withMetaFields = false) {\n        if (!withMetaFields) {\n            const data = flatClone(this._data);\n            delete (data as any)._rev;\n            delete (data as any)._attachments;\n            delete (data as any)._deleted;\n            delete (data as any)._meta;\n            return overwritable.deepFreezeWhenDevMode(data);\n        } else {\n            return overwritable.deepFreezeWhenDevMode(this._data);\n        }\n    },\n    toMutableJSON(this: RxDocument, withMetaFields = false) {\n        return clone(this.toJSON(withMetaFields as any));\n    },\n\n    /**\n     * updates document\n     * @overwritten by plugin (optional)\n     * @param updateObj mongodb-like syntax\n     */\n    update(_updateObj: UpdateQuery<any>) {\n        throw pluginMissing('update');\n    },\n    incrementalUpdate(_updateObj: UpdateQuery<any>) {\n        throw pluginMissing('update');\n    },\n    updateCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]) {\n        throw pluginMissing('crdt');\n    },\n    putAttachment() {\n        throw pluginMissing('attachments');\n    },\n    putAttachmentBase64() {\n        throw pluginMissing('attachments');\n    },\n    getAttachment() {\n        throw pluginMissing('attachments');\n    },\n    allAttachments() {\n        throw pluginMissing('attachments');\n    },\n    get allAttachments$() {\n        throw pluginMissing('attachments');\n    },\n\n    async modify<RxDocType>(\n        this: RxDocument<RxDocType>,\n        mutationFunction: ModifyFunction<RxDocType>,\n        // used by some plugins that wrap the method\n        _context?: string\n    ): Promise<RxDocument> {\n        const oldData = this._data;\n        const newData: RxDocumentData<RxDocType> = await modifierFromPublicToInternal<RxDocType>(mutationFunction)(oldData) as any;\n        return this._saveData(newData, oldData) as any;\n    },\n\n    /**\n     * runs an incremental update over the document\n     * @param function that takes the document-data and returns a new data-object\n     */\n    incrementalModify(\n        this: RxDocument,\n        mutationFunction: ModifyFunction<any>,\n        // used by some plugins that wrap the method\n        _context?: string\n    ): Promise<RxDocument> {\n        return this.collection.incrementalWriteQueue.addWrite(\n            this._data,\n            modifierFromPublicToInternal(mutationFunction)\n        ).then(result => this.collection._docCache.getCachedRxDocument(result));\n    },\n\n    patch<RxDocType>(\n        this: RxDocument<RxDocType>,\n        patch: Partial<RxDocType>\n    ) {\n        const oldData = this._data;\n        const newData = clone(oldData);\n        Object\n            .entries(patch)\n            .forEach(([k, v]) => {\n                (newData as any)[k] = v;\n            });\n        return this._saveData(newData, oldData);\n    },\n\n    /**\n     * patches the given properties\n     */\n    incrementalPatch<RxDocumentType = any>(\n        this: RxDocument<RxDocumentType>,\n        patch: Partial<RxDocumentType>\n    ): Promise<RxDocument<RxDocumentType>> {\n        return this.incrementalModify((docData) => {\n            Object\n                .entries(patch)\n                .forEach(([k, v]) => {\n                    (docData as any)[k] = v;\n                });\n            return docData;\n        });\n    },\n\n    /**\n     * saves the new document-data\n     * and handles the events\n     */\n    async _saveData<RxDocType>(\n        this: RxDocument<RxDocType>,\n        newData: RxDocumentWriteData<RxDocType>,\n        oldData: RxDocumentData<RxDocType>\n    ): Promise<RxDocument<RxDocType>> {\n        newData = flatClone(newData);\n\n        // deleted documents cannot be changed\n        if (this._data._deleted) {\n            throw newRxError('DOC11', {\n                id: this.primary,\n                document: this\n            });\n        }\n        await beforeDocumentUpdateWrite(this.collection, newData, oldData);\n        const writeRows = [{\n            previous: oldData,\n            document: newData\n        }];\n        const writeResult = await this.collection.storageInstance.bulkWrite(writeRows, 'rx-document-save-data');\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);\n\n        await this.collection._runHooks('post', 'save', newData, this);\n        return this.collection._docCache.getCachedRxDocument(\n            getWrittenDocumentsFromBulkWriteResponse(\n                this.collection.schema.primaryPath,\n                writeRows,\n                writeResult\n            )[0]\n        );\n    },\n\n    /**\n     * Remove the document.\n     * Notice that there is no hard delete,\n     * instead deleted documents get flagged with _deleted=true.\n     */\n    async remove(this: RxDocument): Promise<RxDocument> {\n        if (this.deleted) {\n            return Promise.reject(newRxError('DOC13', {\n                document: this,\n                id: this.primary\n            }));\n        }\n\n        const removeResult = await this.collection.bulkRemove([this]);\n        if (removeResult.error.length > 0) {\n            const error = removeResult.error[0];\n            throwIfIsStorageWriteError(\n                this.collection,\n                this.primary,\n                this._data,\n                error\n            );\n        }\n        return removeResult.success[0];\n    },\n    incrementalRemove(this: RxDocument): Promise<RxDocument> {\n        return this.incrementalModify(async (docData) => {\n            await this.collection._runHooks('pre', 'remove', docData, this);\n            docData._deleted = true;\n            return docData;\n        }).then(async (newDoc) => {\n            await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);\n            return newDoc;\n        });\n    },\n    close() {\n        throw newRxError('DOC14');\n    }\n};\n\nexport function createRxDocumentConstructor(proto = basePrototype) {\n    const constructor = function RxDocumentConstructor(\n        this: RxDocument,\n        collection: RxCollection,\n        docData: RxDocumentData<any>\n    ) {\n        this.collection = collection;\n\n        // assume that this is always equal to the doc-data in the database\n        this._data = docData;\n        this._propertyCache = new Map<string, any>();\n\n        /**\n         * because of the prototype-merge,\n         * we can not use the native instanceof operator\n         */\n        this.isInstanceOfRxDocument = true;\n    };\n    constructor.prototype = proto;\n    return constructor;\n}\n\nexport function createWithConstructor<RxDocType>(\n    constructor: any,\n    collection: RxCollection<RxDocType>,\n    jsonData: RxDocumentData<RxDocType>\n): RxDocument<RxDocType> | null {\n    const doc = new constructor(collection, jsonData);\n    runPluginHooks('createRxDocument', doc);\n    return doc;\n}\n\nexport function isRxDocument(obj: any): boolean {\n    return typeof obj === 'object' && obj !== null && 'isInstanceOfRxDocument' in obj;\n}\n\n\nexport function beforeDocumentUpdateWrite<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    newData: RxDocumentWriteData<RxDocType>,\n    oldData: RxDocumentData<RxDocType>\n): Promise<any> {\n    /**\n     * Meta values must always be merged\n     * instead of overwritten.\n     * This ensures that different plugins do not overwrite\n     * each others meta properties.\n     */\n    newData._meta = Object.assign(\n        {},\n        oldData._meta,\n        newData._meta\n    );\n\n    // ensure modifications are ok\n    if (overwritable.isDevMode()) {\n        collection.schema.validateChange(oldData, newData);\n    }\n    return collection._runHooks('pre', 'save', newData, oldData);\n}\n\n\n\n\nfunction getDocumentProperty(doc: RxDocument, objPath: string): any | null {\n    return getFromMapOrCreate(\n        doc._propertyCache,\n        objPath,\n        () => {\n            const valueObj = getProperty(doc._data, objPath);\n\n            // direct return if array or non-object\n            if (\n                typeof valueObj !== 'object' ||\n                valueObj === null ||\n                Array.isArray(valueObj)\n            ) {\n                return overwritable.deepFreezeWhenDevMode(valueObj);\n            }\n            const proxy = new Proxy(\n                /**\n                 * In dev-mode, the _data is deep-frozen\n                 * so we have to flat clone here so that\n                 * the proxy can work.\n                 */\n                flatClone(valueObj),\n                {\n                    /**\n                     * @performance is really important here\n                     * because people access nested properties very often\n                     * and might not be aware that this is internally using a Proxy\n                     */\n                    get(target, property: any) {\n                        if (typeof property !== 'string') {\n                            return target[property];\n                        }\n\n\n                        const lastChar = property.charAt(property.length - 1);\n                        if (lastChar === '$') {\n                            if (property.endsWith('$$')) {\n                                const key = property.slice(0, -2);\n                                return doc.get$$(trimDots(objPath + '.' + key));\n                            } else {\n                                const key = property.slice(0, -1);\n                                return doc.get$(trimDots(objPath + '.' + key));\n                            }\n                        } else if (lastChar === '_') {\n                            const key = property.slice(0, -1);\n                            return doc.populate(trimDots(objPath + '.' + key));\n                        } else {\n\n                            /**\n                             * Performance shortcut\n                             * In most cases access to nested properties\n                             * will only access simple values which can be directly returned\n                             * without creating a new Proxy or utilizing the cache.\n                             */\n                            const plainValue = target[property];\n                            if (\n                                typeof plainValue === 'number' ||\n                                typeof plainValue === 'string' ||\n                                typeof plainValue === 'boolean'\n                            ) {\n                                return plainValue;\n                            }\n\n                            return getDocumentProperty(doc, trimDots(objPath + '.' + property));\n                        }\n                    }\n                });\n            return proxy;\n        }\n    );\n};\n", "/**\n * the query-cache makes sure that on every query-state, exactly one instance can exist\n * if you use the same mango-query more then once, it will reuse the first RxQuery\n */\nimport type {\n    RxQuery,\n    RxCacheReplacementPolicy,\n    RxCollection\n} from './types/index.d.ts';\nimport {\n    getFromMapOrCreate,\n    nextTick,\n    now,\n    requestIdlePromise\n} from './plugins/utils/index.ts';\n\nexport class QueryCache {\n    public _map: Map<string, RxQuery> = new Map();\n\n    /**\n     * check if an equal query is in the cache,\n     * if true, return the cached one,\n     * if false, save the given one and return it\n     */\n    getByQuery(rxQuery: RxQuery): RxQuery {\n        const stringRep = rxQuery.toString();\n        const ret = getFromMapOrCreate(\n            this._map,\n            stringRep,\n            () => rxQuery\n        );\n        return ret;\n    }\n}\n\nexport function createQueryCache() {\n    return new QueryCache();\n}\n\n\nexport function uncacheRxQuery(queryCache: QueryCache, rxQuery: RxQuery) {\n    rxQuery.uncached = true;\n    const stringRep = rxQuery.toString();\n    queryCache._map.delete(stringRep);\n\n}\n\n\nexport function countRxQuerySubscribers(rxQuery: RxQuery): number {\n    return rxQuery.refCount$.observers.length;\n}\n\n\nexport const DEFAULT_TRY_TO_KEEP_MAX = 100;\nexport const DEFAULT_UNEXECUTED_LIFETIME = 30 * 1000;\n\n/**\n * The default cache replacement policy\n * See docs-src/query-cache.md to learn how it should work.\n * Notice that this runs often and should block the cpu as less as possible\n * This is a monad which makes it easier to unit test\n */\nexport const defaultCacheReplacementPolicyMonad: (\n    tryToKeepMax: number,\n    unExecutedLifetime: number\n) => RxCacheReplacementPolicy = (\n    tryToKeepMax,\n    unExecutedLifetime\n) => (\n    _collection: RxCollection,\n    queryCache: QueryCache\n) => {\n            if (queryCache._map.size < tryToKeepMax) {\n                return;\n            }\n\n            const minUnExecutedLifetime = now() - unExecutedLifetime;\n            const maybeUncache: RxQuery[] = [];\n\n            const queriesInCache = Array.from(queryCache._map.values());\n            for (const rxQuery of queriesInCache) {\n                // filter out queries with subscribers\n                if (countRxQuerySubscribers(rxQuery) > 0) {\n                    continue;\n                }\n                // directly uncache queries that never executed and are older than unExecutedLifetime\n                if (rxQuery._lastEnsureEqual === 0 && rxQuery._creationTime < minUnExecutedLifetime) {\n                    uncacheRxQuery(queryCache, rxQuery);\n                    continue;\n                }\n                maybeUncache.push(rxQuery);\n            }\n\n            const mustUncache = maybeUncache.length - tryToKeepMax;\n            if (mustUncache <= 0) {\n                return;\n            }\n\n            const sortedByLastUsage = maybeUncache.sort((a, b) => a._lastEnsureEqual - b._lastEnsureEqual);\n            const toRemove = sortedByLastUsage.slice(0, mustUncache);\n            toRemove.forEach(rxQuery => uncacheRxQuery(queryCache, rxQuery));\n        };\n\n\nexport const defaultCacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicyMonad(\n    DEFAULT_TRY_TO_KEEP_MAX,\n    DEFAULT_UNEXECUTED_LIFETIME\n);\n\nexport const COLLECTIONS_WITH_RUNNING_CLEANUP: WeakSet<RxCollection> = new WeakSet();\n\n/**\n * Triggers the cache replacement policy after waitTime has passed.\n * We do not run this directly because at exactly the time a query is created,\n * we need all CPU to minimize latency.\n * Also this should not be triggered multiple times when waitTime is still waiting.\n */\nexport function triggerCacheReplacement(\n    rxCollection: RxCollection\n) {\n    if (COLLECTIONS_WITH_RUNNING_CLEANUP.has(rxCollection)) {\n        // already started\n        return;\n    }\n\n    COLLECTIONS_WITH_RUNNING_CLEANUP.add(rxCollection);\n\n    /**\n     * Do not run directly to not reduce result latency of a new query\n     */\n    nextTick() // wait at least one tick\n        .then(() => requestIdlePromise(200)) // and then wait for the CPU to be idle\n        .then(() => {\n            if (!rxCollection.closed) {\n                rxCollection.cacheReplacementPolicy(rxCollection, rxCollection._queryCache);\n            }\n            COLLECTIONS_WITH_RUNNING_CLEANUP.delete(rxCollection);\n        });\n}\n", "import type {\n    RxDocument,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport {\n    getFromMapOrThrow,\n    getHeightOfRevision,\n    overwriteGetterForCaching,\n    requestIdlePromiseNoQueue\n} from './plugins/utils/index.ts';\nimport {\n    overwritable\n} from './overwritable.ts';\nimport { Observable } from 'rxjs';\n\n/**\n * Because we have to create many cache items,\n * we use an array instead of an object with properties\n * for better performance and less memory usage.\n * @link https://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript\n */\ndeclare type CacheItem<RxDocType, OrmMethods> = [\n    /**\n     * Store the different document states of time\n     * based on their [revisionHeight+_meta.lwt] .\n     * We store WeakRefs so that we can later clean up\n     * document states that are no longer needed.\n     *\n     * Notice that we can not only rely on the revisionHeight\n     * because when cleanup is used, two document states can end up with\n     * the same revision but different _meta.lwt.\n     */\n    Map<string, WeakRef<RxDocument<RxDocType, OrmMethods>>>,\n\n    /**\n     * Store the latest known document state.\n     * As long as any state of the document is in the cache,\n     * we observe the changestream and update the latestDoc accordingly.\n     * This makes it easier to optimize performance on other parts\n     * because for each known document we can always get the current state\n     * in the storage.\n     * Also it makes it possible to call RxDocument.latest() in a non-async way\n     * to retrieve the latest document state or to observe$ some property.\n     *\n     * To not prevent the whole cacheItem from being garbage collected,\n     * we store only the document data here, but not the RxDocument.\n     */\n    RxDocumentData<RxDocType>\n];\n\n\n/**\n * @link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry\n */\ndeclare type FinalizationRegistryValue = {\n    docId: string;\n    revisionHeight: number;\n    lwt: number;\n};\n\n/**\n * The DocumentCache stores RxDocument objects\n * by their primary key and revision.\n * This is useful on client side applications where\n * it is not known how much memory can be used, so\n * we de-duplicate RxDocument states to save memory.\n * To not fill up the memory with old document states, the DocumentCache\n * only contains weak references to the RxDocuments themself.\n * @link https://caniuse.com/?search=weakref\n */\nexport class DocumentCache<RxDocType, OrmMethods> {\n    public readonly cacheItemByDocId = new Map<string, CacheItem<RxDocType, OrmMethods>>();\n\n    /**\n     * Process stuff lazy to not block the CPU\n     * on critical paths.\n     */\n    public readonly tasks = new Set<Function>();\n\n    /**\n     * Some JavaScript runtimes like QuickJS,\n     * so not have a FinalizationRegistry or WeakRef.\n     * Therefore we need a workaround which might waste a lot of memory,\n     * but at least works.\n     */\n    public readonly registry?: FinalizationRegistry<FinalizationRegistryValue> = typeof FinalizationRegistry === 'function' ?\n        new FinalizationRegistry<FinalizationRegistryValue>(docMeta => {\n            const docId = docMeta.docId;\n            const cacheItem = this.cacheItemByDocId.get(docId);\n            if (cacheItem) {\n                cacheItem[0].delete(docMeta.revisionHeight + docMeta.lwt + '');\n                if (cacheItem[0].size === 0) {\n                    /**\n                     * No state of the document is cached anymore,\n                     * so we can clean up.\n                     */\n                    this.cacheItemByDocId.delete(docId);\n                }\n            }\n        }) :\n        undefined;\n\n    constructor(\n        public readonly primaryPath: string,\n        public readonly changes$: Observable<RxStorageChangeEvent<RxDocType>[]>,\n        /**\n         * A method that can create a RxDocument by the given document data.\n         */\n        public documentCreator: (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods>\n    ) {\n        changes$.subscribe(events => {\n            this.tasks.add(() => {\n                const cacheItemByDocId = this.cacheItemByDocId;\n                for (let index = 0; index < events.length; index++) {\n                    const event = events[index];\n                    const cacheItem = cacheItemByDocId.get(event.documentId);\n                    if (cacheItem) {\n                        let documentData = event.documentData;\n                        if (!documentData) {\n                            documentData = event.previousDocumentData as any;\n                        }\n                        cacheItem[1] = documentData;\n                    }\n                }\n            });\n            if (this.tasks.size <= 1) {\n                requestIdlePromiseNoQueue().then(() => {\n                    this.processTasks();\n                });\n            }\n        });\n    }\n\n    public processTasks() {\n        if (this.tasks.size === 0) {\n            return;\n        }\n        const tasks = Array.from(this.tasks);\n        tasks.forEach(task => task());\n        this.tasks.clear();\n    }\n\n    /**\n     * Get the RxDocument from the cache\n     * and create a new one if not exits before.\n     * @overwrites itself with the actual function\n     * because this is @performance relevant.\n     * It is called on each document row for each write and read.\n     */\n    get getCachedRxDocuments(): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\n        const fn = getCachedRxDocumentMonad(this);\n        return overwriteGetterForCaching(\n            this,\n            'getCachedRxDocuments',\n            fn\n        );\n    }\n\n    get getCachedRxDocument(): (docData: RxDocumentData<RxDocType>) => RxDocument<RxDocType, OrmMethods> {\n        const fn = getCachedRxDocumentMonad(this);\n        return overwriteGetterForCaching(\n            this,\n            'getCachedRxDocument',\n            doc => fn([doc])[0]\n        );\n    }\n\n    /**\n     * Throws if not exists\n     */\n    public getLatestDocumentData(docId: string): RxDocumentData<RxDocType> {\n        this.processTasks();\n        const cacheItem = getFromMapOrThrow(this.cacheItemByDocId, docId);\n        return cacheItem[1];\n    }\n\n    public getLatestDocumentDataIfExists(docId: string): RxDocumentData<RxDocType> | undefined {\n        this.processTasks();\n        const cacheItem = this.cacheItemByDocId.get(docId);\n        if (cacheItem) {\n            return cacheItem[1];\n        }\n    }\n}\n\n/**\n * This function is called very very often.\n * @hotPath This is one of the most important methods for performance.\n * It is used in many places to transform the raw document data into RxDocuments.\n */\nfunction getCachedRxDocumentMonad<RxDocType, OrmMethods>(\n    docCache: DocumentCache<RxDocType, OrmMethods>\n): (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] {\n    const primaryPath = docCache.primaryPath;\n    const cacheItemByDocId = docCache.cacheItemByDocId;\n    const registry = docCache.registry;\n    const deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n    const documentCreator = docCache.documentCreator;\n    const fn: (docsData: RxDocumentData<RxDocType>[]) => RxDocument<RxDocType, OrmMethods>[] = (docsData: RxDocumentData<RxDocType>[]) => {\n        const ret: RxDocument<RxDocType, OrmMethods>[] = new Array(docsData.length);\n        const registryTasks: RxDocument<RxDocType, OrmMethods>[] = [];\n        for (let index = 0; index < docsData.length; index++) {\n            let docData = docsData[index];\n            const docId: string = (docData as any)[primaryPath];\n\n            const revisionHeight = getHeightOfRevision(docData._rev);\n\n            let byRev: Map<string, WeakRef<RxDocument<RxDocType, OrmMethods>>>;\n            let cachedRxDocumentWeakRef: WeakRef<RxDocument<RxDocType, OrmMethods>> | undefined;\n            let cacheItem = cacheItemByDocId.get(docId);\n            if (!cacheItem) {\n                byRev = new Map();\n                cacheItem = [\n                    byRev,\n                    docData\n                ];\n                cacheItemByDocId.set(docId, cacheItem);\n            } else {\n                byRev = cacheItem[0];\n                cachedRxDocumentWeakRef = byRev.get(revisionHeight + docData._meta.lwt + '');\n            }\n            let cachedRxDocument = cachedRxDocumentWeakRef ? cachedRxDocumentWeakRef.deref() : undefined;\n            if (!cachedRxDocument) {\n                docData = deepFreezeWhenDevMode(docData) as any;\n                cachedRxDocument = documentCreator(docData) as RxDocument<RxDocType, OrmMethods>;\n                byRev.set(revisionHeight + docData._meta.lwt + '', createWeakRefWithFallback(cachedRxDocument));\n                if (registry) {\n                    registryTasks.push(cachedRxDocument);\n                }\n            }\n            ret[index] = cachedRxDocument;\n        }\n        if (registryTasks.length > 0 && registry) {\n            /**\n             * Calling registry.register() has shown to have\n             * really bad performance. So we add the cached documents\n             * lazily.\n             */\n            docCache.tasks.add(() => {\n                for (let index = 0; index < registryTasks.length; index++) {\n                    const doc = registryTasks[index];\n                    registry.register(doc, {\n                        docId: doc.primary,\n                        revisionHeight: getHeightOfRevision(doc.revision),\n                        lwt: doc._data._meta.lwt\n                    });\n                }\n            });\n            if (docCache.tasks.size <= 1) {\n                requestIdlePromiseNoQueue().then(() => {\n                    docCache.processTasks();\n                });\n            }\n        }\n        return ret;\n    };\n    return fn;\n}\n\nexport function mapDocumentsDataToCacheDocs<RxDocType, OrmMethods>(\n    docCache: DocumentCache<RxDocType, OrmMethods>,\n    docsData: RxDocumentData<RxDocType>[]\n) {\n    const getCachedRxDocuments = docCache.getCachedRxDocuments;\n    return getCachedRxDocuments(docsData);\n}\n\n/**\n * Fallback for JavaScript runtimes that do not support WeakRef.\n * The fallback will keep the items in cache forever,\n * but at least works.\n */\nconst HAS_WEAK_REF = typeof WeakRef === 'function';\nconst createWeakRefWithFallback = HAS_WEAK_REF ? createWeakRef : createWeakRefFallback;\nfunction createWeakRef<T extends object>(obj: T): WeakRef<T> {\n    return new WeakRef(obj) as any;\n}\nfunction createWeakRefFallback<T extends object>(obj: T): WeakRef<T> {\n    return {\n        deref() {\n            return obj;\n        }\n    } as any;\n}\n", "import { mapDocumentsDataToCacheDocs } from './doc-cache.ts';\nimport { now, overwriteGetterForCaching } from './plugins/utils/index.ts';\nimport { newRxError } from './rx-error.ts';\nimport { RxQueryBase } from './rx-query.ts';\nimport type {\n    RxDocument,\n    RxDocumentData\n} from './types';\n\n/**\n * RxDB needs the query results in multiple formats.\n * Sometimes as a Map or an array with only the documentData.\n * For better performance we work with this class\n * that initializes stuff lazily so that\n * we can directly work with the query results after RxQuery.exec()\n */\nexport class RxQuerySingleResult<RxDocType> {\n    /**\n     * Time at which the current _result state was created.\n     * Used to determine if the result set has changed since X\n     * so that we do not emit the same result multiple times on subscription.\n     */\n    public readonly time = now();\n    public readonly documents: RxDocument<RxDocType>[];\n    constructor(\n        public readonly query: RxQueryBase<RxDocType, unknown>,\n        // only used internally, do not use outside, use this.docsData instead\n        docsDataFromStorageInstance: RxDocumentData<RxDocType>[],\n        // can be overwritten for count-queries\n        public readonly count: number,\n    ) {\n        this.documents = mapDocumentsDataToCacheDocs<RxDocType, any>(this.query.collection._docCache, docsDataFromStorageInstance);\n    }\n\n\n    /**\n     * Instead of using the newResultData in the result cache,\n     * we directly use the objects that are stored in the RxDocument\n     * to ensure we do not store the same data twice and fill up the memory.\n     * @overwrites itself with the actual value\n     */\n    get docsData(): RxDocumentData<RxDocType>[] {\n        return overwriteGetterForCaching(\n            this,\n            'docsData',\n            this.documents.map(d => d._data)\n        );\n    }\n\n\n    // A key->document map, used in the event reduce optimization.\n    get docsDataMap(): Map<string, RxDocumentData<RxDocType>> {\n        const map = new Map<string, RxDocumentData<RxDocType>>();\n        this.documents.forEach(d => {\n            map.set(d.primary, d._data);\n        });\n        return overwriteGetterForCaching(\n            this,\n            'docsDataMap',\n            map\n        );\n    }\n\n    get docsMap(): Map<string, RxDocument<RxDocType>> {\n        const map = new Map<string, RxDocument<RxDocType>>();\n        const documents = this.documents;\n        for (let i = 0; i < documents.length; i++) {\n            const doc = documents[i];\n            map.set(doc.primary, doc);\n        }\n        return overwriteGetterForCaching(\n            this,\n            'docsMap',\n            map\n        );\n    }\n\n    getValue(throwIfMissing?: boolean) {\n        const op = this.query.op;\n        if (op === 'count') {\n            return this.count;\n        } else if (op === 'findOne') {\n            // findOne()-queries emit RxDocument or null\n            const doc = this.documents.length === 0 ? null : this.documents[0];\n            if (!doc && throwIfMissing) {\n                throw newRxError('QU10', {\n                    collection: this.query.collection.name,\n                    query: this.query.mangoQuery,\n                    op\n                });\n            } else {\n                return doc;\n            }\n        } else if (op === 'findByIds') {\n            return this.docsMap;\n        } else {\n            // find()-queries emit RxDocument[]\n            // Flat copy the array so it won't matter if the user modifies it.\n            return this.documents.slice(0);\n        }\n    }\n}\n", "import type {\n    MongoQuery,\n    DeepReadonlyObject\n} from './types/index.js';\n\n\nexport function lastOfArray<T>(ar: T[]): T {\n    return ar[ar.length - 1];\n}\n\n/**\n * @link https://stackoverflow.com/a/5915122\n */\nexport function randomOfArray<T>(items: T[]): T {\n    return items[Math.floor(Math.random() * items.length)];\n}\n\nexport function shuffleArray<T>(arr: T[]): T[] {\n    return arr.slice().sort(() => (Math.random() - 0.5));\n}\n\n/**\n * normalizes sort-field\n * in: '-age'\n * out: 'age'\n */\nexport function normalizeSortField(field: string): string {\n    if (field.startsWith('-')) {\n        return field.substr(1);\n    } else {\n        return field;\n    }\n}\n\nexport function getSortFieldsOfQuery(query: MongoQuery): string[] {\n    if (!query.sort) {\n        // if no sort-order is set, use the primary key\n        return ['_id'];\n    }\n    return query.sort.map(maybeArray => {\n        if (Array.isArray(maybeArray)) {\n            return maybeArray[0].map((field: any) => normalizeSortField(field));\n        } else {\n            return normalizeSortField(maybeArray);\n        }\n    });\n}\n\n/**\n *  @link https://stackoverflow.com/a/1431113\n */\nexport function replaceCharAt(str: string, index: number, replacement: string) {\n    return str.substr(0, index) + replacement + str.substr(index + replacement.length);\n}\n\nexport function mapToObject<K, V>(map: Map<K, V>): {\n    [k: string]: V\n} {\n    const ret: any = {};\n    map.forEach(\n        (value: V, key: K) => {\n            ret[key as any] = value;\n        }\n    );\n    return ret;\n}\n\nexport function objectToMap<K, V>(object: {\n    [k: string]: V\n}): Map<K, V> {\n    const ret = new Map();\n    Object.entries(object).forEach(([k, v]) => {\n        ret.set(k, v);\n    });\n    return ret;\n}\n\nexport function cloneMap<K, V>(map: Map<K, V>): Map<K, V> {\n    const ret: any = new Map();\n    map.forEach(\n        (value: V, key: K) => {\n            ret[key as any] = value;\n        }\n    );\n    return ret;\n}\n\n/**\n * does a flat copy on the objects,\n * is about 3 times faster then using deepClone\n * @link https://jsperf.com/object-rest-spread-vs-clone/2\n */\nexport function flatClone<T>(obj: T | DeepReadonlyObject<T>): T {\n    return Object.assign({}, obj) as any;\n}\n\nexport function ensureNotFalsy<T>(obj: T | false | undefined | null): T {\n    if (!obj) {\n        throw new Error('ensureNotFalsy() is falsy');\n    }\n    return obj;\n}\n\nexport function mergeSets<T>(sets: Set<T>[]): Set<T> {\n    let ret: Set<T> = new Set();\n    sets.forEach(set => {\n        ret = new Set([...ret, ...set]);\n    });\n    return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/12830454/3443137\n */\nexport function roundToTwoDecimals(num: number): number {\n    return parseFloat(num.toFixed(2));\n}\n\n\nexport function isObject(value: null) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\n\nexport function getProperty(object: any, path: string | string[], value?: any) {\n    if (Array.isArray(path)) {\n        path = path.join('.');\n    }\n\n    if (!isObject(object as any) || typeof path !== 'string') {\n        return value === undefined ? object : value;\n    }\n\n    const pathArray = path.split('.');\n    if (pathArray.length === 0) {\n        return value;\n    }\n\n    for (let index = 0; index < pathArray.length; index++) {\n        const key = pathArray[index];\n\n        if (isStringIndex(object as any, key as any)) {\n            object = index === pathArray.length - 1 ? undefined : null;\n        } else {\n            object = (object as any)[key];\n        }\n\n        if (object === undefined || object === null) {\n            // `object` is either `undefined` or `null` so we want to stop the loop, and\n            // if this is not the last bit of the path, and\n            // if it didn't return `undefined`\n            // it would return `null` if `object` is `null`\n            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`\n            if (index !== pathArray.length - 1) {\n                return value;\n            }\n\n            break;\n        }\n    }\n\n    return object === undefined ? value : object;\n}\n\nfunction isStringIndex(object: any[], key: string) {\n    if (typeof key !== 'number' && Array.isArray(object)) {\n        const index = Number.parseInt(key, 10);\n        return Number.isInteger(index) && object[index] === object[key as any];\n    }\n\n    return false;\n}\n", "import type { StateResolveFunction } from '../types/index.js';\nimport { getProperty, lastOfArray } from '../util.js';\n\nexport const hasLimit: StateResolveFunction<any> = (input) => {\n    return !!input.queryParams.limit;\n};\n\nexport const isFindOne: StateResolveFunction<any> = (input) => {\n    return input.queryParams.limit === 1;\n};\n\nexport const hasSkip: StateResolveFunction<any> = (input) => {\n    if (input.queryParams.skip && input.queryParams.skip > 0) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nexport const isDelete: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'DELETE';\n};\n\nexport const isInsert: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'INSERT';\n};\n\nexport const isUpdate: StateResolveFunction<any> = (input) => {\n    return input.changeEvent.operation === 'UPDATE';\n};\n\n\nexport const wasLimitReached: StateResolveFunction<any> = (input) => {\n    return hasLimit(input) && input.previousResults.length >= (input.queryParams.limit as number);\n};\n\nexport const sortParamsChanged: StateResolveFunction<any> = (input) => {\n    const sortFields = input.queryParams.sortFields;\n    const prev = input.changeEvent.previous;\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    if (!prev) {\n        return true;\n    }\n\n    for (let i = 0; i < sortFields.length; i++) {\n        const field = sortFields[i];\n        const beforeData = getProperty(prev, field);\n        const afterData = getProperty(doc, field);\n        if (beforeData !== afterData) {\n            return true;\n        }\n    }\n    return false;\n};\n\nexport const wasInResult: StateResolveFunction<any> = (input) => {\n    const id = input.changeEvent.id;\n    if (input.keyDocumentMap) {\n        const has = input.keyDocumentMap.has(id);\n        return has;\n    } else {\n        const primary = input.queryParams.primaryKey;\n        const results = input.previousResults;\n        for (let i = 0; i < results.length; i++) {\n            const item = results[i];\n            if (item[primary] === id) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nexport const wasFirst: StateResolveFunction<any> = (input) => {\n    const first = input.previousResults[0];\n    if (first && first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\nexport const wasLast: StateResolveFunction<any> = (input) => {\n    const last = lastOfArray(input.previousResults);\n    if (last && last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    } else {\n        return false;\n    }\n};\n\n\nexport const wasSortedBeforeFirst: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n\n    /**\n     * If the changed document is the same as the first,\n     * we cannot sort-compare them, because it might end in a non-deterministic\n     * sort order. Because both document could be equal.\n     * So instead we have to return true.\n     */\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        prev,\n        first\n    );\n    return comp < 0;\n};\n\nexport const wasSortedAfterLast: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        prev,\n        last\n    );\n    return comp > 0;\n};\n\nexport const isSortedBeforeFirst: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n\n    const first = input.previousResults[0];\n    if (!first) {\n        return false;\n    }\n\n    if (first[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        doc,\n        first\n    );\n    return comp < 0;\n};\n\nexport const isSortedAfterLast: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n\n    const last = lastOfArray(input.previousResults);\n    if (!last) {\n        return false;\n    }\n\n    if (last[input.queryParams.primaryKey] === input.changeEvent.id) {\n        return true;\n    }\n\n    const comp = input.queryParams.sortComparator(\n        doc,\n        last\n    );\n    return comp > 0;\n};\n\n\nexport const wasMatching: StateResolveFunction<any> = (input) => {\n    const prev = input.changeEvent.previous;\n    if (!prev) {\n        return false;\n    }\n    return input.queryParams.queryMatcher(\n        prev\n    );\n};\n\nexport const doesMatchNow: StateResolveFunction<any> = (input) => {\n    const doc = input.changeEvent.doc;\n    if (!doc) {\n        return false;\n    }\n    const ret = input.queryParams.queryMatcher(\n        doc\n    );\n    return ret;\n};\n\n\nexport const wasResultsEmpty: StateResolveFunction<any> = (input) => {\n    return input.previousResults.length === 0;\n};\n", "import { ResolverFunctions } from 'binary-decision-diagram';\n\nimport type {\n    StateName,\n    StateResolveFunction,\n    StateSet,\n    StateResolveFunctionInput\n} from '../types/index.js';\n\nimport {\n    hasLimit,\n    isFindOne,\n    hasSkip,\n    wasResultsEmpty,\n    isDelete,\n    isInsert,\n    isUpdate,\n    wasLimitReached,\n    sortParamsChanged,\n    wasInResult,\n    wasFirst,\n    wasLast,\n    wasSortedBeforeFirst,\n    wasSortedAfterLast,\n    isSortedBeforeFirst,\n    isSortedAfterLast,\n    wasMatching,\n    doesMatchNow\n} from './state-resolver.js';\n\nexport * from './state-resolver.js';\n\n/**\n * all states ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedStateList: StateName[] = [\n    'isInsert',\n    'isUpdate',\n    'isDelete',\n    'hasLimit',\n    'isFindOne',\n    'hasSkip',\n    'wasResultsEmpty',\n    'wasLimitReached',\n    'wasFirst',\n    'wasLast',\n    'sortParamsChanged',\n    'wasInResult',\n    'wasSortedBeforeFirst',\n    'wasSortedAfterLast',\n    'isSortedBeforeFirst',\n    'isSortedAfterLast',\n    'wasMatching',\n    'doesMatchNow'\n];\n\nexport const stateResolveFunctions: {\n    readonly [k in StateName]: StateResolveFunction<any>\n} = {\n    isInsert,\n    isUpdate,\n    isDelete,\n    hasLimit,\n    isFindOne,\n    hasSkip,\n    wasResultsEmpty,\n    wasLimitReached,\n    wasFirst,\n    wasLast,\n    sortParamsChanged,\n    wasInResult,\n    wasSortedBeforeFirst,\n    wasSortedAfterLast,\n    isSortedBeforeFirst,\n    isSortedAfterLast,\n    wasMatching,\n    doesMatchNow\n};\n\nexport const stateResolveFunctionByIndex: ResolverFunctions<\n    StateResolveFunctionInput<any>\n> = {\n    0: isInsert,\n    1: isUpdate,\n    2: isDelete,\n    3: hasLimit,\n    4: isFindOne,\n    5: hasSkip,\n    6: wasResultsEmpty,\n    7: wasLimitReached,\n    8: wasFirst,\n    9: wasLast,\n    10: sortParamsChanged,\n    11: wasInResult,\n    12: wasSortedBeforeFirst,\n    13: wasSortedAfterLast,\n    14: isSortedBeforeFirst,\n    15: isSortedAfterLast,\n    16: wasMatching,\n    17: doesMatchNow\n};\n\nexport function resolveState<DocType>(\n    stateName: StateName,\n    input: StateResolveFunctionInput<DocType>\n): boolean {\n    const fn: StateResolveFunction<DocType> = stateResolveFunctions[stateName];\n    if (!fn) {\n        throw new Error('resolveState() has no function for ' + stateName);\n    }\n    return fn(input);\n}\n\nexport function getStateSet<DocType>(\n    input: StateResolveFunctionInput<DocType>\n): StateSet {\n    let set: StateSet = '';\n    for (let i = 0; i < orderedStateList.length; i++) {\n        const name: StateName = orderedStateList[i];\n        const value = resolveState(name, input);\n        const add = value ? '1' : '0';\n        set += add;\n    }\n    return set;\n}\n\nexport function logStateSet(stateSet: StateSet) {\n    orderedStateList.forEach((state, index) => {\n        console.log('state: ' + state + ' : ' + stateSet[index]);\n    });\n}\n", "/**\n * copied and adapted from npm 'binary-search-insert'\n * @link https://www.npmjs.com/package/binary-search-insert\n */\nexport function pushAtSortPosition(array, item, compareFunction, low) {\n  var length = array.length;\n  var high = length - 1;\n  var mid = 0;\n\n  /**\n   * Optimization shortcut.\n   */\n  if (length === 0) {\n    array.push(item);\n    return 0;\n  }\n\n  /**\n   * So we do not have to get the ret[mid] doc again\n   * at the last we store it here.\n   */\n  var lastMidDoc;\n  while (low <= high) {\n    // https://github.com/darkskyapp/binary-search\n    // http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html\n    mid = low + (high - low >> 1);\n    lastMidDoc = array[mid];\n    if (compareFunction(lastMidDoc, item) <= 0.0) {\n      // searching too low\n      low = mid + 1;\n    } else {\n      // searching too high\n      high = mid - 1;\n    }\n  }\n  if (compareFunction(lastMidDoc, item) <= 0.0) {\n    mid++;\n  }\n\n  /**\n   * Insert at correct position\n   */\n  array.splice(mid, 0, item);\n  return mid;\n}", "import {\n    pushAtSortPosition\n} from 'array-push-at-sort-position';\n\nimport type { ActionFunction } from '../types/index.js';\n\nexport const doNothing: ActionFunction<any> = (_input) => { };\n\nexport const insertFirst: ActionFunction<any> = (input) => {\n    input.previousResults.unshift(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(\n            input.changeEvent.id,\n            input.changeEvent.doc\n        );\n    }\n};\nexport const insertLast: ActionFunction<any> = (input) => {\n    input.previousResults.push(input.changeEvent.doc);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.set(\n            input.changeEvent.id,\n            input.changeEvent.doc\n        );\n    }\n};\nexport const removeFirstItem: ActionFunction<any> = (input) => {\n    const first = input.previousResults.shift();\n    if (input.keyDocumentMap && first) {\n        input.keyDocumentMap.delete(\n            first[input.queryParams.primaryKey]\n        );\n    }\n};\n\nexport const removeLastItem: ActionFunction<any> = (input) => {\n    const last = input.previousResults.pop();\n    if (input.keyDocumentMap && last) {\n        input.keyDocumentMap.delete(\n            last[input.queryParams.primaryKey]\n        );\n    }\n};\n\nexport const removeFirstInsertLast: ActionFunction<any> = (input) => {\n    removeFirstItem(input);\n    insertLast(input);\n};\n\nexport const removeLastInsertFirst: ActionFunction<any> = (input) => {\n    removeLastItem(input);\n    insertFirst(input);\n};\n\nexport const removeFirstInsertFirst: ActionFunction<any> = (input) => {\n    removeFirstItem(input);\n    insertFirst(input);\n};\n\nexport const removeLastInsertLast: ActionFunction<any> = (input) => {\n    removeLastItem(input);\n    insertLast(input);\n};\n\nexport const removeExisting: ActionFunction<any> = (input) => {\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.delete(\n            input.changeEvent.id\n        );\n    }\n\n    // find index of document\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // remove\n        if (item[primary] === input.changeEvent.id) {\n            results.splice(i, 1);\n            break;\n        }\n    }\n};\n\nexport const replaceExisting: ActionFunction<any> = (input) => {\n    // find index of document\n    const doc = input.changeEvent.doc;\n    const primary = input.queryParams.primaryKey;\n    const results = input.previousResults;\n    for (let i = 0; i < results.length; i++) {\n        const item = results[i];\n        // replace\n        if (item[primary] === input.changeEvent.id) {\n            results[i] = doc;\n            if (input.keyDocumentMap) {\n                input.keyDocumentMap.set(\n                    input.changeEvent.id,\n                    doc\n                );\n            }\n            break;\n        }\n    }\n};\n\n/**\n * this function always returns wrong results\n * it must be later optimised out\n * otherwise there is something broken\n */\nexport const alwaysWrong: ActionFunction<any> = (input) => {\n    const wrongHuman = {\n        _id: 'wrongHuman' + new Date().getTime()\n    };\n    input.previousResults.length = 0; // clear array\n    input.previousResults.push(wrongHuman);\n    if (input.keyDocumentMap) {\n        input.keyDocumentMap.clear();\n        input.keyDocumentMap.set(\n            wrongHuman._id,\n            wrongHuman\n        );\n    }\n};\n\nexport const insertAtSortPosition: ActionFunction<any> = (input) => {\n    const docId = input.changeEvent.id;\n    const doc = input.changeEvent.doc;\n    if (input.keyDocumentMap) {\n\n        if (input.keyDocumentMap.has(docId)) {\n            /**\n             * If document is already in results,\n             * we cannot add it again because it would throw on non-deterministic ordering.\n             */\n            return;\n        }\n\n        input.keyDocumentMap.set(\n            docId,\n            doc\n        );\n    } else {\n        const isDocInResults = input.previousResults.find((d: any) => d[input.queryParams.primaryKey] === docId);\n        /**\n         * If document is already in results,\n         * we cannot add it again because it would throw on non-deterministic ordering.\n         */\n        if (isDocInResults) {\n            return;\n        }\n    }\n\n    pushAtSortPosition(\n        input.previousResults,\n        doc,\n        input.queryParams.sortComparator,\n        0\n    );\n};\n\nexport const removeExistingAndInsertAtSortPosition: ActionFunction<any> = (input) => {\n    removeExisting(input);\n    insertAtSortPosition(input);\n};\n\nexport const runFullQueryAgain: ActionFunction<any> = (_input) => {\n    throw new Error('Action runFullQueryAgain must be implemented by yourself');\n};\n\nexport const unknownAction: ActionFunction<any> = (_input) => {\n    throw new Error('Action unknownAction should never be called');\n};\n", "import type {\n    ActionName,\n    ActionFunction\n} from '../types/index.js';\n\nimport {\n    doNothing,\n    insertFirst,\n    insertLast,\n    removeFirstItem,\n    removeLastItem,\n    removeFirstInsertLast,\n    removeLastInsertFirst,\n    removeExisting,\n    replaceExisting,\n    alwaysWrong,\n    insertAtSortPosition,\n    removeExistingAndInsertAtSortPosition,\n    runFullQueryAgain,\n    unknownAction,\n    removeFirstInsertFirst,\n    removeLastInsertLast\n} from './action-functions.js';\n\nexport * from './action-functions.js';\n\n/**\n * all actions ordered by performance-cost\n * cheapest first\n * TODO run tests on which is really the fastest\n */\nexport const orderedActionList: ActionName[] = [\n    'doNothing',\n    'insertFirst',\n    'insertLast',\n    'removeFirstItem',\n    'removeLastItem',\n    'removeFirstInsertLast',\n    'removeLastInsertFirst',\n    'removeFirstInsertFirst',\n    'removeLastInsertLast',\n    'removeExisting',\n    'replaceExisting',\n    'alwaysWrong',\n    'insertAtSortPosition',\n    'removeExistingAndInsertAtSortPosition',\n    'runFullQueryAgain',\n    'unknownAction'\n];\n\n\nexport const actionFunctions: {\n    [k in ActionName]: ActionFunction<any>\n} = {\n    doNothing,\n    insertFirst,\n    insertLast,\n    removeFirstItem,\n    removeLastItem,\n    removeFirstInsertLast,\n    removeLastInsertFirst,\n    removeFirstInsertFirst,\n    removeLastInsertLast,\n    removeExisting,\n    replaceExisting,\n    alwaysWrong,\n    insertAtSortPosition,\n    removeExistingAndInsertAtSortPosition,\n    runFullQueryAgain,\n    unknownAction\n};\n", "/*\nlet t = 0;\nwhile (t < 10000) {\n    const char = String.fromCharCode(t);\n    console.log(t + ' : ' + char);\n    t++;\n}\n*/\n\n/*\n\nTo have a really small string representation, we have to hack some stuff\nwhich makes is complicated but effective.\n\nRules for the string:\n- The string starts with a number like '23' that defines how many leaf-nodes we have\n- leaf nodes consist of two chars like 'ab'\n    - the first char is the id\n    - the second the value is a number you can get via String.charCodeAt()\n- Internal nodes have four chars like 'abcd'\n    - the first char is the id\n    - the second char is the id of the 0-branch\n    - the third char is the id of the 1-branch\n    - the last char is the id of the boolean-function (= level)\n- The last 3 chars of the string is the root node like 'abc'\n    - it looks like the internal-node but without the id (first char)\n\n*/\n\n// we use this because 39 is the quotes which causes problems\nexport const CHAR_CODE_OFFSET = 40; // String.fromCharCode(33) === ')'\n\n\nexport function getCharOfLevel(level: number): string {\n    const charCode = CHAR_CODE_OFFSET + level;\n    return String.fromCharCode(charCode);\n}\n\nexport function getNumberOfChar(char: string): number {\n    const charCode = char.charCodeAt(0);\n    return charCode - CHAR_CODE_OFFSET;\n}\n\nexport function getCharOfValue(value: number): string {\n    const charCode = CHAR_CODE_OFFSET + value;\n    return String.fromCharCode(charCode);\n}\n\n\nexport const FIRST_CHAR_CODE_FOR_ID = 97; // String.fromCharCode(97) === 'a'\n\nexport function getNextCharId(lastCode: number): {\n    char: string,\n    nextCode: number\n} {\n\n    // jump these codes because they look strange\n    if (lastCode >= 128 && lastCode <= 160) {\n        lastCode = 161;\n    }\n\n    const char = String.fromCharCode(lastCode);\n    return {\n        char,\n        nextCode: lastCode + 1\n    };\n}\n", "import type { BooleanString } from './types.ts';\n\nexport function booleanStringToBoolean(str: BooleanString): boolean {\n    if (str === '1') {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function booleanToBooleanString(b: boolean): BooleanString {\n    if (b) {\n        return '1';\n    } else {\n        return '0';\n    }\n}\n\nexport function oppositeBoolean(input: BooleanString): BooleanString {\n    if (input === '1') {\n        return '0';\n    } else {\n        return '1';\n    }\n}\n\nexport function lastChar(str: string): string {\n    return str.slice(-1);\n}\n\n/**\n * @link https://stackoverflow.com/a/1349426\n */\nfunction makeid(length: number = 6): string {\n    let result = '';\n    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const charactersLength = characters.length;\n    for (let i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n    return result;\n}\n\nconst nodeIdPrefix = makeid(4);\nlet lastIdGen = 0;\nexport function nextNodeId(): string {\n    const ret = 'node_' + nodeIdPrefix + '_' + lastIdGen;\n    lastIdGen++;\n    return ret;\n}\n\n/**\n * @link https://stackoverflow.com/a/16155417\n */\nexport function decimalToPaddedBinary(\n    decimal: number,\n    padding: number\n) {\n    const binary = (decimal >>> 0).toString(2);\n    const padded = binary.padStart(padding, '0');\n    return padded;\n}\n\nexport function oppositeBinary(i: string): string {\n    if (i === '1') {\n        return '0';\n    } else if (i === '0') {\n        return '1';\n    } else {\n        throw new Error('non-binary given');\n    }\n}\n\nexport function binaryToDecimal(binary: string): number {\n    return parseInt(binary, 2);\n}\n\nexport function minBinaryWithLength(length: number): string {\n    return new Array(length).fill(0).map(() => '0').join('');\n}\n\nexport function maxBinaryWithLength(length: number): string {\n    return new Array(length).fill(0).map(() => '1').join('');\n}\n\nexport function getNextStateSet(\n    stateSet: string\n): string {\n    const decimal = binaryToDecimal(stateSet);\n    const increase = decimal + 1;\n    const binary = decimalToPaddedBinary(increase, stateSet.length);\n    return binary;\n}\n\nexport function firstKeyOfMap(map: Map<string, any>): string {\n    const iterator1 = map.keys();\n    return iterator1.next().value;\n}\n\n/**\n * Shuffles array in place. ES6 version\n * @link https://stackoverflow.com/a/6274381\n */\nexport function shuffleArray<T>(a: T[]): T[] {\n    for (let i = a.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [a[j], a[i]];\n    }\n    return a;\n}\n\nexport function lastOfArray<T>(ar: T[]): T {\n    return ar[ar.length - 1];\n}\n\n/**\n * @link https://stackoverflow.com/a/6259536\n */\nexport function splitStringToChunks(str: string, chunkSize: number): string[] {\n    const chunks: string[] = [];\n\n    for (let i = 0, charsLength = str.length; i < charsLength; i += chunkSize) {\n        chunks.push(str.substring(i, i + chunkSize));\n    }\n    return chunks;\n}\n", "import {\n    SimpleBdd,\n    SimpleBddLeafNode\n} from '../types.js';\nimport { splitStringToChunks } from '../util.js';\nimport { getNumberOfChar } from './string-format.js';\n\nexport function minimalStringToSimpleBdd(\n    str: string\n): SimpleBdd {\n    const nodesById: Map<string, SimpleBdd | SimpleBddLeafNode> = new Map();\n\n    // parse leaf nodes\n    const leafNodeAmount = parseInt(str.charAt(0) + str.charAt(1), 10);\n    const lastLeafNodeChar = (2 + leafNodeAmount * 2);\n    const leafNodeChars = str.substring(2, lastLeafNodeChar);\n    const leafNodeChunks = splitStringToChunks(leafNodeChars, 2);\n    for (let i = 0; i < leafNodeChunks.length; i++) {\n        const chunk = leafNodeChunks[i];\n        const id = chunk.charAt(0);\n        const value: SimpleBddLeafNode = getNumberOfChar(chunk.charAt(1));\n        nodesById.set(id, value);\n    }\n\n    // parse internal nodes\n    const internalNodeChars = str.substring(lastLeafNodeChar, str.length - 3);\n    const internalNodeChunks = splitStringToChunks(internalNodeChars, 4);\n    for (let i = 0; i < internalNodeChunks.length; i++) {\n        const chunk = internalNodeChunks[i];\n        const id = chunk.charAt(0);\n        const idOf0Branch = chunk.charAt(1);\n        const idOf1Branch = chunk.charAt(2);\n        const level = getNumberOfChar(chunk.charAt(3));\n\n\n        if (!nodesById.has(idOf0Branch)) {\n            throw new Error('missing node with id ' + idOf0Branch);\n        }\n        if (!nodesById.has(idOf1Branch)) {\n            throw new Error('missing node with id ' + idOf1Branch);\n        }\n\n        const node0 = nodesById.get(idOf0Branch) as SimpleBdd;\n        const node1 = nodesById.get(idOf1Branch) as SimpleBdd;\n        const node: SimpleBdd = {\n            l: level, // level is first for prettier json output\n            0: node0,\n            1: node1\n        };\n        nodesById.set(id, node);\n    }\n\n    // parse root node\n    const last3 = str.slice(-3);\n    const idOf0 = last3.charAt(0);\n    const idOf1 = last3.charAt(1);\n    const levelOfRoot = getNumberOfChar(last3.charAt(2));\n    const nodeOf0 = nodesById.get(idOf0) as SimpleBdd;\n    const nodeOf1 = nodesById.get(idOf1) as SimpleBdd;\n    const rootNode: SimpleBdd = {\n        l: levelOfRoot,\n        0: nodeOf0,\n        1: nodeOf1,\n    };\n\n    return rootNode;\n}\n", "import {\n    SimpleBdd,\n    ResolverFunctions,\n    SimpleBddLeafNode\n} from '../types.js';\nimport { booleanToBooleanString } from '../util.js';\n\nexport function resolveWithSimpleBdd(\n    simpleBdd: SimpleBdd,\n    fns: ResolverFunctions,\n    input: any\n): number {\n    let currentNode: SimpleBdd | SimpleBddLeafNode = simpleBdd;\n    let currentLevel: number = simpleBdd.l;\n    while (true) {\n        const booleanResult = fns[currentLevel](input);\n        const branchKey = booleanToBooleanString(booleanResult);\n        currentNode = currentNode[branchKey];\n        if (typeof currentNode === 'number' || typeof currentNode === 'string') {\n            return currentNode as any;\n        } else {\n            currentLevel = currentNode.l;\n        }\n    }\n}\n", "import {\n    SimpleBdd,\n    minimalStringToSimpleBdd,\n    resolveWithSimpleBdd\n} from 'binary-decision-diagram';\nimport type { StateResolveFunctionInput } from '../types/index.js';\nimport { stateResolveFunctionByIndex } from '../states/index.js';\n\nexport const minimalBddString = '14a1b,c+d2e5f0g/h.i4j*k-l)m(n6oeh6pnm6qen6ril6snh6tin6ubo9vce9wmh9xns9yne9zmi9{cm9|ad9}cp9~aq9ae9bf9bq9cg9ck9cn9nd9np9nq9nf9ng9nm9nk9mr9ms9mt9mj9mk9ml9mn9mc8{8}888mn88m8m4z4w4z44444m4v7yn77~777n777m77m7m7m5m5m55m555m55m5m552|2u2222x222|222222n2n222n2/an/bn/cn///////////,cn,,,,,,,ac0bc00000000000m-m-----------3333(((++++11*m*.';\n\nlet simpleBdd: SimpleBdd | undefined;\nexport function getSimpleBdd() {\n    if (!simpleBdd) {\n        simpleBdd = minimalStringToSimpleBdd(minimalBddString);\n    }\n    return simpleBdd;\n}\n\nexport const resolveInput = (input: StateResolveFunctionInput<any>) => {\n    return resolveWithSimpleBdd(\n        getSimpleBdd(),\n        stateResolveFunctionByIndex,\n        input\n    );\n};\n", "import type {\n    ChangeEvent,\n    ActionName,\n    ResultKeyDocumentMap,\n    QueryParams,\n    StateSetToActionMap,\n    StateSet,\n    ActionFunction,\n    StateResolveFunctionInput\n} from './types/index.js';\nimport { getStateSet } from './states/index.js';\nimport { actionFunctions, orderedActionList } from './actions/index.js';\nimport { resolveInput } from './bdd/bdd.generated.js';\n\n/**\n * Export as type to ensure we do not\n * end with an import statement in the build output\n * which would increase the build size.\n */\nexport type {\n    ActionFunction,\n    ActionFunctionInput,\n    ActionName,\n    ChangeEvent,\n    ChangeEventBase,\n    ChangeEventDelete,\n    ChangeEventInsert,\n    ChangeEventUpdate,\n    MongoQuery,\n    QueryMatcher,\n    QueryParams,\n    ResultKeyDocumentMap,\n    DeterministicSortComparator,\n    StateName,\n    StateResolveFunction,\n    StateResolveFunctionInput,\n    StateSet,\n    StateSetToActionMap,\n    WriteOperation\n} from './types/index.js';\n\nexport * from './states/index.js';\nexport * from './util.js';\nexport * from './actions/index.js';\n\nexport function calculateActionFromMap<DocType>(\n    stateSetToActionMap: StateSetToActionMap,\n    input: StateResolveFunctionInput<DocType>\n): {\n    action: ActionName,\n    stateSet: StateSet\n} {\n    const stateSet: StateSet = getStateSet(input);\n    const actionName = stateSetToActionMap.get(stateSet);\n    if (!actionName) {\n        return {\n            action: 'runFullQueryAgain',\n            stateSet\n        };\n    } else {\n        return {\n            action: actionName,\n            stateSet\n        };\n    }\n}\n\nexport function calculateActionName<DocType>(\n    input: StateResolveFunctionInput<DocType>\n): ActionName {\n    const resolvedActionId = resolveInput(\n        input\n    );\n    return orderedActionList[resolvedActionId];\n}\n\nexport function calculateActionFunction<DocType>(\n    input: StateResolveFunctionInput<DocType>\n): ActionFunction<DocType> {\n    const actionName = calculateActionName(input);\n    return actionFunctions[actionName];\n}\n\n/**\n * for performance reasons,\n * @mutates the input\n * @returns the new results\n */\nexport function runAction<DocType>(\n    action: ActionName,\n    queryParams: QueryParams<DocType>,\n    changeEvent: ChangeEvent<DocType>,\n    previousResults: DocType[],\n    keyDocumentMap?: ResultKeyDocumentMap<DocType>\n): DocType[] {\n    const fn: ActionFunction<DocType> = actionFunctions[action];\n    fn({\n        queryParams,\n        changeEvent,\n        previousResults,\n        keyDocumentMap\n    });\n    return previousResults;\n}\n", "import {\n    ActionName,\n    calculateActionName,\n    runAction,\n    QueryParams,\n    QueryMatcher,\n    DeterministicSortComparator,\n    StateResolveFunctionInput,\n    ChangeEvent\n} from 'event-reduce-js';\nimport type {\n    RxQuery,\n    MangoQuery,\n    StringKeys,\n    RxDocumentData,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport { rxChangeEventToEventReduceChangeEvent } from './rx-change-event.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    getFromMapOrCreate\n} from './plugins/utils/index.ts';\nimport { getQueryMatcher, getSortComparator, normalizeMangoQuery } from './rx-query-helper.ts';\n\nexport type EventReduceResultNeg = {\n    runFullQueryAgain: true;\n};\nexport type EventReduceResultPos<RxDocumentType> = {\n    runFullQueryAgain: false;\n    changed: boolean;\n    newResults: RxDocumentType[];\n};\nexport type EventReduceResult<RxDocumentType> = EventReduceResultNeg | EventReduceResultPos<RxDocumentType>;\n\n\nexport function getSortFieldsOfQuery<RxDocType>(\n    primaryKey: StringKeys<RxDocumentData<RxDocType>>,\n    query: MangoQuery<RxDocType>\n): (string | StringKeys<RxDocType>)[] {\n    if (!query.sort || query.sort.length === 0) {\n        return [primaryKey];\n    } else {\n        return query.sort.map(part => Object.keys(part)[0]);\n    }\n}\n\n\n\nexport const RXQUERY_QUERY_PARAMS_CACHE: WeakMap<RxQuery, QueryParams<any>> = new WeakMap();\nexport function getQueryParams<RxDocType>(\n    rxQuery: RxQuery<RxDocType>\n): QueryParams<RxDocType> {\n    return getFromMapOrCreate(\n        RXQUERY_QUERY_PARAMS_CACHE,\n        rxQuery,\n        () => {\n            const collection = rxQuery.collection;\n            const normalizedMangoQuery = normalizeMangoQuery(\n                collection.storageInstance.schema,\n                clone(rxQuery.mangoQuery)\n            );\n            const primaryKey = collection.schema.primaryPath;\n\n            /**\n             * Create a custom sort comparator\n             * that uses the hooks to ensure\n             * we send for example compressed documents to be sorted by compressed queries.\n             */\n            const sortComparator = getSortComparator(\n                collection.schema.jsonSchema,\n                normalizedMangoQuery\n            );\n\n            const useSortComparator: DeterministicSortComparator<RxDocType> = (docA: RxDocType, docB: RxDocType) => {\n                const sortComparatorData = {\n                    docA,\n                    docB,\n                    rxQuery\n                };\n                return sortComparator(sortComparatorData.docA, sortComparatorData.docB);\n            };\n\n            /**\n             * Create a custom query matcher\n             * that uses the hooks to ensure\n             * we send for example compressed documents to match compressed queries.\n             */\n            const queryMatcher = getQueryMatcher(\n                collection.schema.jsonSchema,\n                normalizedMangoQuery\n            );\n            const useQueryMatcher: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType>) => {\n                const queryMatcherData = {\n                    doc,\n                    rxQuery\n                };\n                return queryMatcher(queryMatcherData.doc);\n            };\n\n            const ret: QueryParams<any> = {\n                primaryKey: rxQuery.collection.schema.primaryPath as any,\n                skip: normalizedMangoQuery.skip,\n                limit: normalizedMangoQuery.limit,\n                sortFields: getSortFieldsOfQuery(primaryKey, normalizedMangoQuery) as string[],\n                sortComparator: useSortComparator,\n                queryMatcher: useQueryMatcher\n            };\n            return ret;\n        }\n    );\n}\n\n\nexport function calculateNewResults<RxDocumentType>(\n    rxQuery: RxQuery<RxDocumentType>,\n    rxChangeEvents: RxStorageChangeEvent<RxDocumentType>[]\n): EventReduceResult<RxDocumentType> {\n    if (!rxQuery.collection.database.eventReduce) {\n        return {\n            runFullQueryAgain: true\n        };\n    }\n    const queryParams = getQueryParams(rxQuery);\n    const previousResults: RxDocumentType[] = ensureNotFalsy(rxQuery._result).docsData.slice(0);\n    const previousResultsMap: Map<string, RxDocumentType> = ensureNotFalsy(rxQuery._result).docsDataMap;\n    let changed: boolean = false;\n\n\n    const eventReduceEvents: ChangeEvent<RxDocumentType>[] = [];\n    for (let index = 0; index < rxChangeEvents.length; index++) {\n        const cE = rxChangeEvents[index];\n        const eventReduceEvent = rxChangeEventToEventReduceChangeEvent(cE);\n        if (eventReduceEvent) {\n            eventReduceEvents.push(eventReduceEvent);\n        }\n    }\n\n    const foundNonOptimizeable = eventReduceEvents.find(eventReduceEvent => {\n        const stateResolveFunctionInput: StateResolveFunctionInput<RxDocumentType> = {\n            queryParams,\n            changeEvent: eventReduceEvent,\n            previousResults,\n            keyDocumentMap: previousResultsMap\n        };\n\n        const actionName: ActionName = calculateActionName(stateResolveFunctionInput);\n        if (actionName === 'runFullQueryAgain') {\n            return true;\n        } else if (actionName !== 'doNothing') {\n            changed = true;\n            runAction(\n                actionName,\n                queryParams,\n                eventReduceEvent,\n                previousResults,\n                previousResultsMap\n            );\n            return false;\n        }\n    });\n    if (foundNonOptimizeable) {\n        return {\n            runFullQueryAgain: true,\n        };\n    } else {\n        return {\n            runFullQueryAgain: false,\n            changed,\n            newResults: previousResults\n        };\n    }\n}\n", "import {\n    BehaviorSubject,\n    Observable,\n    merge\n} from 'rxjs';\nimport {\n    mergeMap,\n    filter,\n    map,\n    startWith,\n    distinctUntilChanged,\n    shareReplay\n} from 'rxjs/operators';\nimport {\n    sortObject,\n    pluginMissing,\n    overwriteGetterForCaching,\n    now,\n    PROMISE_RESOLVE_FALSE,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    ensureNotFalsy,\n    areRxDocumentArraysEqual,\n    appendToArray\n} from './plugins/utils/index.ts';\nimport {\n    newRxError,\n    rxStorageWriteErrorToRxError\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\nimport type {\n    RxCollection,\n    RxDocument,\n    RxQueryOP,\n    RxQuery,\n    MangoQuery,\n    MangoQuerySortPart,\n    MangoQuerySelector,\n    PreparedQuery,\n    RxDocumentWriteData,\n    RxDocumentData,\n    QueryMatcher,\n    ModifyFunction,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport { calculateNewResults } from './event-reduce.ts';\nimport { triggerCacheReplacement } from './query-cache.ts';\nimport {\n    getQueryMatcher,\n    normalizeMangoQuery,\n    prepareQuery,\n    runQueryUpdateFunction\n\n} from './rx-query-helper.ts';\nimport { RxQuerySingleResult } from './rx-query-single-result.ts';\n\nlet _queryCount = 0;\nconst newQueryID = function (): number {\n    return ++_queryCount;\n};\n\nexport class RxQueryBase<\n    RxDocType,\n    RxQueryResult,\n    OrmMethods = {},\n    Reactivity = unknown,\n> {\n\n    public id: number = newQueryID();\n\n    /**\n     * Some stats then are used for debugging and cache replacement policies\n     */\n    public _execOverDatabaseCount: number = 0;\n    public _creationTime = now();\n\n    // used in the query-cache to determine if the RxQuery can be cleaned up.\n    public _lastEnsureEqual = 0;\n\n    public uncached = false;\n\n    // used to count the subscribers to the query\n    public refCount$ = new BehaviorSubject(null);\n\n    public isFindOneByIdQuery: false | string | string[];\n\n\n    /**\n     * Contains the current result state\n     * or null if query has not run yet.\n     */\n    public _result: RxQuerySingleResult<RxDocType> | null = null;\n\n\n    constructor(\n        public op: RxQueryOP,\n        public mangoQuery: Readonly<MangoQuery<RxDocType>>,\n        public collection: RxCollection<RxDocType>,\n        // used by some plugins\n        public other: any = {}\n    ) {\n        if (!mangoQuery) {\n            this.mangoQuery = _getDefaultQuery();\n        }\n\n        this.isFindOneByIdQuery = isFindOneByIdQuery(\n            this.collection.schema.primaryPath as string,\n            mangoQuery\n        );\n    }\n    get $(): Observable<RxQueryResult> {\n        if (!this._$) {\n            const results$ = this.collection.eventBulks$.pipe(\n                /**\n                 * Performance shortcut.\n                 * Changes to local documents are not relevant for the query.\n                 */\n                filter(bulk => !bulk.isLocal),\n                /**\n                 * Start once to ensure the querying also starts\n                 * when there where no changes.\n                 */\n                startWith(null),\n                // ensure query results are up to date.\n                mergeMap(() => _ensureEqual(this as any)),\n                // use the current result set, written by _ensureEqual().\n                map(() => this._result),\n                // do not run stuff above for each new subscriber, only once.\n                shareReplay(RXJS_SHARE_REPLAY_DEFAULTS),\n                // do not proceed if result set has not changed.\n                distinctUntilChanged((prev, curr) => {\n                    if (prev && prev.time === ensureNotFalsy(curr).time) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }),\n                filter(result => !!result),\n                /**\n                 * Map the result set to a single RxDocument or an array,\n                 * depending on query type\n                 */\n                map((result) => {\n                    return ensureNotFalsy(result).getValue();\n                })\n            );\n\n            this._$ = merge<any>(\n                results$,\n                /**\n                 * Also add the refCount$ to the query observable\n                 * to allow us to count the amount of subscribers.\n                 */\n                this.refCount$.pipe(\n                    filter(() => false)\n                )\n            );\n        }\n        return this._$ as any;\n    }\n\n    get $$(): Reactivity {\n        const reactivity = this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            this.$,\n            undefined,\n            this.collection.database\n        ) as any;\n    }\n\n    // stores the changeEvent-number of the last handled change-event\n    public _latestChangeEvent: -1 | number = -1;\n\n    /**\n     * ensures that the exec-runs\n     * are not run in parallel\n     */\n    public _ensureEqualQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n\n    /**\n     * Returns an observable that emits the results\n     * This should behave like an rxjs-BehaviorSubject which means:\n     * - Emit the current result-set on subscribe\n     * - Emit the new result-set when an RxChangeEvent comes in\n     * - Do not emit anything before the first result-set was created (no null)\n     */\n    public _$?: Observable<RxQueryResult>;\n\n    /**\n     * set the new result-data as result-docs of the query\n     * @param newResultData json-docs that were received from the storage\n     */\n    _setResultData(newResultData: RxDocumentData<RxDocType>[] | number | Map<string, RxDocumentData<RxDocType>>): void {\n        if (typeof newResultData === 'undefined') {\n            throw newRxError('QU18', {\n                database: this.collection.database.name,\n                collection: this.collection.name\n            });\n        }\n        if (typeof newResultData === 'number') {\n            this._result = new RxQuerySingleResult<RxDocType>(\n                this as any,\n                [],\n                newResultData\n            );\n            return;\n        } else if (newResultData instanceof Map) {\n            newResultData = Array.from((newResultData as Map<string, RxDocumentData<RxDocType>>).values());\n        }\n\n        const newQueryResult = new RxQuerySingleResult<RxDocType>(\n            this as any,\n            newResultData,\n            newResultData.length\n        );\n        this._result = newQueryResult;\n    }\n\n    /**\n     * executes the query on the database\n     * @return results-array with document-data\n     */\n    async _execOverDatabase(): Promise<RxDocumentData<RxDocType>[] | number> {\n        this._execOverDatabaseCount = this._execOverDatabaseCount + 1;\n        if (this.op === 'count') {\n            const preparedQuery = this.getPreparedQuery();\n            const result = await this.collection.storageInstance.count(preparedQuery);\n            if (result.mode === 'slow' && !this.collection.database.allowSlowCount) {\n                throw newRxError('QU14', {\n                    collection: this.collection,\n                    queryObj: this.mangoQuery\n                });\n            } else {\n                return result.count;\n            }\n        }\n\n        if (this.op === 'findByIds') {\n            const ids: string[] = ensureNotFalsy(this.mangoQuery.selector as any)[this.collection.schema.primaryPath].$in;\n            const ret = new Map<string, RxDocument<RxDocType>>();\n            const mustBeQueried: string[] = [];\n            // first try to fill from docCache\n            ids.forEach(id => {\n                const docData = this.collection._docCache.getLatestDocumentDataIfExists(id);\n                if (docData) {\n                    if (!docData._deleted) {\n                        const doc = this.collection._docCache.getCachedRxDocument(docData);\n                        ret.set(id, doc);\n                    }\n                } else {\n                    mustBeQueried.push(id);\n                }\n            });\n            // everything which was not in docCache must be fetched from the storage\n            if (mustBeQueried.length > 0) {\n                const docs = await this.collection.storageInstance.findDocumentsById(mustBeQueried, false);\n                docs.forEach(docData => {\n                    const doc = this.collection._docCache.getCachedRxDocument(docData);\n                    ret.set(doc.primary, doc);\n                });\n            }\n            return ret as any;\n        }\n\n\n        const docsPromise = queryCollection<RxDocType>(this as any);\n        return docsPromise.then(docs => {\n            return docs;\n        });\n    }\n\n    /**\n     * Execute the query\n     * To have an easier implementations,\n     * just subscribe and use the first result\n     */\n    public exec(throwIfMissing: true): Promise<RxDocument<RxDocType, OrmMethods, Reactivity>>;\n    public exec(): Promise<RxQueryResult>;\n    public async exec(throwIfMissing?: boolean): Promise<any> {\n        if (throwIfMissing && this.op !== 'findOne') {\n            throw newRxError('QU9', {\n                collection: this.collection.name,\n                query: this.mangoQuery,\n                op: this.op\n            });\n        }\n\n        /**\n         * run _ensureEqual() here,\n         * this will make sure that errors in the query which throw inside of the RxStorage,\n         * will be thrown at this execution context and not in the background.\n         */\n        await _ensureEqual(this as any);\n        const useResult = ensureNotFalsy(this._result);\n        return useResult.getValue(throwIfMissing);\n    }\n\n\n\n    /**\n     * cached call to get the queryMatcher\n     * @overwrites itself with the actual value\n     */\n    get queryMatcher(): QueryMatcher<RxDocumentWriteData<RxDocType>> {\n        const schema = this.collection.schema.jsonSchema;\n        const normalizedQuery = normalizeMangoQuery(\n            this.collection.schema.jsonSchema,\n            this.mangoQuery\n        );\n        return overwriteGetterForCaching(\n            this,\n            'queryMatcher',\n            getQueryMatcher(\n                schema,\n                normalizedQuery\n            ) as any\n        );\n    }\n\n    /**\n     * returns a string that is used for equal-comparisons\n     * @overwrites itself with the actual value\n     */\n    toString(): string {\n        const stringObj = sortObject({\n            op: this.op,\n            query: normalizeMangoQuery<RxDocType>(\n                this.collection.schema.jsonSchema,\n                this.mangoQuery\n            ),\n            other: this.other\n        }, true);\n        const value = JSON.stringify(stringObj);\n        this.toString = () => value;\n        return value;\n    }\n\n    /**\n     * returns the prepared query\n     * which can be send to the storage instance to query for documents.\n     * @overwrites itself with the actual value.\n     */\n    getPreparedQuery(): PreparedQuery<RxDocType> {\n        const hookInput = {\n            rxQuery: this,\n            // can be mutated by the hooks so we have to deep clone first.\n            mangoQuery: normalizeMangoQuery<RxDocType>(\n                this.collection.schema.jsonSchema,\n                this.mangoQuery\n            )\n        };\n        (hookInput.mangoQuery.selector as any)._deleted = { $eq: false };\n        if (hookInput.mangoQuery.index) {\n            hookInput.mangoQuery.index.unshift('_deleted');\n        }\n        runPluginHooks('prePrepareQuery', hookInput);\n\n        const value = prepareQuery(\n            this.collection.schema.jsonSchema,\n            hookInput.mangoQuery as any\n        );\n\n        this.getPreparedQuery = () => value;\n        return value;\n    }\n\n    /**\n     * returns true if the document matches the query,\n     * does not use the 'skip' and 'limit'\n     */\n    doesDocumentDataMatch(docData: RxDocType | any): boolean {\n        // if doc is deleted, it cannot match\n        if (docData._deleted) {\n            return false;\n        }\n\n        return this.queryMatcher(docData);\n    }\n\n    /**\n     * deletes all found documents\n     * @return promise with deleted documents\n     */\n    async remove(): Promise<RxQueryResult> {\n        const docs = await this.exec();\n        if (Array.isArray(docs)) {\n            const result = await this.collection.bulkRemove(docs);\n            if (result.error.length > 0) {\n                throw rxStorageWriteErrorToRxError(result.error[0]);\n            } else {\n                return result.success as any;\n            }\n        } else {\n            return (docs as any).remove();\n        }\n    }\n    incrementalRemove(): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalRemove(),\n        );\n    }\n\n\n    /**\n     * helper function to transform RxQueryBase to RxQuery type\n     */\n    get asRxQuery(): RxQuery<RxDocType, RxQueryResult> {\n        return this as any;\n    }\n\n    /**\n     * updates all found documents\n     * @overwritten by plugin (optional)\n     */\n    update(_updateObj: any): Promise<RxQueryResult> {\n        throw pluginMissing('update');\n    }\n\n    patch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.patch(patch),\n        );\n    }\n    incrementalPatch(patch: Partial<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalPatch(patch),\n        );\n    }\n    modify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.modify(mutationFunction),\n        );\n    }\n    incrementalModify(mutationFunction: ModifyFunction<RxDocType>): Promise<RxQueryResult> {\n        return runQueryUpdateFunction(\n            this.asRxQuery,\n            (doc) => doc.incrementalModify(mutationFunction),\n        );\n    }\n\n\n    // we only set some methods of query-builder here\n    // because the others depend on these ones\n    where(_queryObj: MangoQuerySelector<RxDocType> | keyof RxDocType | string): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    sort(_params: string | MangoQuerySortPart<RxDocType>): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    skip(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n    limit(_amount: number | null): RxQuery<RxDocType, RxQueryResult> {\n        throw pluginMissing('query-builder');\n    }\n}\n\n\nexport function _getDefaultQuery<RxDocType>(): MangoQuery<RxDocType> {\n    return {\n        selector: {}\n    };\n}\n\n/**\n * run this query through the QueryCache\n */\nexport function tunnelQueryCache<RxDocumentType, RxQueryResult>(\n    rxQuery: RxQueryBase<RxDocumentType, RxQueryResult>\n): RxQuery<RxDocumentType, RxQueryResult> {\n    return rxQuery.collection._queryCache.getByQuery(rxQuery as any);\n}\n\nexport function createRxQuery<RxDocType>(\n    op: RxQueryOP,\n    queryObj: MangoQuery<RxDocType>,\n    collection: RxCollection<RxDocType>,\n    other?: any\n) {\n    runPluginHooks('preCreateRxQuery', {\n        op,\n        queryObj,\n        collection,\n        other\n    });\n\n    let ret = new RxQueryBase<RxDocType, any>(op, queryObj, collection, other);\n\n    // ensure when created with same params, only one is created\n    ret = tunnelQueryCache(ret);\n    triggerCacheReplacement(collection);\n\n    return ret;\n}\n\n/**\n * Check if the current results-state is in sync with the database\n * which means that no write event happened since the last run.\n * @return false if not which means it should re-execute\n */\nfunction _isResultsInSync(rxQuery: RxQueryBase<any, any>): boolean {\n    const currentLatestEventNumber = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n    if (rxQuery._latestChangeEvent >= currentLatestEventNumber) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/**\n * wraps __ensureEqual()\n * to ensure it does not run in parallel\n * @return true if has changed, false if not\n */\nasync function _ensureEqual(rxQuery: RxQueryBase<any, any>): Promise<boolean> {\n    if (rxQuery.collection.awaitBeforeReads.size > 0) {\n        await Promise.all(Array.from(rxQuery.collection.awaitBeforeReads).map(fn => fn()));\n    }\n\n    // Optimisation shortcut\n    if (\n        rxQuery.collection.database.closed ||\n        _isResultsInSync(rxQuery)\n    ) {\n        return false;\n    }\n\n    rxQuery._ensureEqualQueue = rxQuery._ensureEqualQueue\n        .then(() => __ensureEqual(rxQuery));\n    return rxQuery._ensureEqualQueue;\n}\n\n/**\n * ensures that the results of this query is equal to the results which a query over the database would give\n * @return true if results have changed\n */\nfunction __ensureEqual<RxDocType>(rxQuery: RxQueryBase<RxDocType, any>): Promise<boolean> {\n    rxQuery._lastEnsureEqual = now();\n\n    /**\n     * Optimisation shortcuts\n     */\n    if (\n        // db is closed\n        rxQuery.collection.database.closed ||\n        // nothing happened since last run\n        _isResultsInSync(rxQuery)\n    ) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n\n    let ret = false;\n    let mustReExec = false; // if this becomes true, a whole execution over the database is made\n    if (rxQuery._latestChangeEvent === -1) {\n        // have not executed yet -> must run\n        mustReExec = true;\n    }\n\n    /**\n     * try to use EventReduce to calculate the new results\n     */\n    if (!mustReExec) {\n        const missedChangeEvents = rxQuery.asRxQuery.collection._changeEventBuffer.getFrom(rxQuery._latestChangeEvent + 1);\n        if (missedChangeEvents === null) {\n            // changeEventBuffer is of bounds -> we must re-execute over the database\n            mustReExec = true;\n        } else {\n            rxQuery._latestChangeEvent = rxQuery.asRxQuery.collection._changeEventBuffer.getCounter();\n\n            const runChangeEvents: RxStorageChangeEvent<RxDocType>[] = rxQuery.asRxQuery.collection\n                ._changeEventBuffer\n                .reduceByLastOfDoc(missedChangeEvents);\n\n            if (rxQuery.op === 'count') {\n                // 'count' query\n                const previousCount = ensureNotFalsy(rxQuery._result).count;\n                let newCount = previousCount;\n                runChangeEvents.forEach(cE => {\n                    const didMatchBefore = cE.previousDocumentData && rxQuery.doesDocumentDataMatch(cE.previousDocumentData);\n                    const doesMatchNow = rxQuery.doesDocumentDataMatch(cE.documentData);\n\n                    if (!didMatchBefore && doesMatchNow) {\n                        newCount++;\n                    }\n                    if (didMatchBefore && !doesMatchNow) {\n                        newCount--;\n                    }\n                });\n                if (newCount !== previousCount) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newCount as any);\n                }\n            } else {\n                // 'find' or 'findOne' query\n                const eventReduceResult = calculateNewResults(\n                    rxQuery as any,\n                    runChangeEvents\n                );\n                if (eventReduceResult.runFullQueryAgain) {\n                    // could not calculate the new results, execute must be done\n                    mustReExec = true;\n                } else if (eventReduceResult.changed) {\n                    // we got the new results, we do not have to re-execute, mustReExec stays false\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(eventReduceResult.newResults as any);\n                }\n            }\n        }\n    }\n\n    // oh no we have to re-execute the whole query over the database\n    if (mustReExec) {\n        return rxQuery._execOverDatabase()\n            .then(newResultData => {\n\n                /**\n                 * The RxStorage is defined to always first emit events and then return\n                 * on bulkWrite() calls. So here we have to use the counter AFTER the execOverDatabase()\n                 * has been run, not the one from before.\n                 */\n                rxQuery._latestChangeEvent = rxQuery.collection._changeEventBuffer.getCounter();\n\n                // A count query needs a different has-changed check.\n                if (typeof newResultData === 'number') {\n                    if (\n                        !rxQuery._result ||\n                        newResultData !== rxQuery._result.count\n                    ) {\n                        ret = true;\n                        rxQuery._setResultData(newResultData as any);\n                    }\n                    return ret;\n                }\n                if (\n                    !rxQuery._result ||\n                    !areRxDocumentArraysEqual(\n                        rxQuery.collection.schema.primaryPath,\n                        newResultData,\n                        rxQuery._result.docsData\n                    )\n                ) {\n                    ret = true; // true because results changed\n                    rxQuery._setResultData(newResultData as any);\n                }\n                return ret;\n            });\n    }\n    return Promise.resolve(ret); // true if results have changed\n}\n\n\n/**\n * Runs the query over the storage instance\n * of the collection.\n * Does some optimizations to ensure findById is used\n * when specific queries are used.\n */\nexport async function queryCollection<RxDocType>(\n    rxQuery: RxQuery<RxDocType> | RxQueryBase<RxDocType, any>\n): Promise<RxDocumentData<RxDocType>[]> {\n    let docs: RxDocumentData<RxDocType>[] = [];\n    const collection = rxQuery.collection;\n\n    /**\n     * Optimizations shortcut.\n     * If query is find-one-document-by-id,\n     * then we do not have to use the slow query() method\n     * but instead can use findDocumentsById()\n     */\n    if (rxQuery.isFindOneByIdQuery) {\n        if (Array.isArray(rxQuery.isFindOneByIdQuery)) {\n            let docIds = rxQuery.isFindOneByIdQuery;\n            docIds = docIds.filter(docId => {\n                // first try to fill from docCache\n                const docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n                if (docData) {\n                    if (!docData._deleted) {\n                        docs.push(docData);\n                    }\n                    return false;\n                } else {\n                    return true;\n                }\n            });\n            // otherwise get from storage\n            if (docIds.length > 0) {\n                const docsFromStorage = await collection.storageInstance.findDocumentsById(docIds, false);\n                appendToArray(docs, docsFromStorage);\n            }\n        } else {\n            const docId = rxQuery.isFindOneByIdQuery;\n\n            // first try to fill from docCache\n            let docData = rxQuery.collection._docCache.getLatestDocumentDataIfExists(docId);\n            if (!docData) {\n                // otherwise get from storage\n                const fromStorageList = await collection.storageInstance.findDocumentsById([docId], false);\n                if (fromStorageList[0]) {\n                    docData = fromStorageList[0];\n                }\n            }\n            if (docData && !docData._deleted) {\n                docs.push(docData);\n            }\n        }\n    } else {\n        const preparedQuery = rxQuery.getPreparedQuery();\n        const queryResult = await collection.storageInstance.query(preparedQuery);\n        docs = queryResult.documents;\n    }\n    return docs;\n\n}\n\n/**\n * Returns true if the given query\n * selects exactly one document by its id.\n * Used to optimize performance because these kind of\n * queries do not have to run over an index and can use get-by-id instead.\n * Returns false if no query of that kind.\n * Returns the document id otherwise.\n */\nexport function isFindOneByIdQuery(\n    primaryPath: string,\n    query: MangoQuery<any>\n): false | string | string[] {\n    // must have exactly one operator which must be $eq || $in\n    if (\n        !query.skip &&\n        query.selector &&\n        Object.keys(query.selector).length === 1 &&\n        query.selector[primaryPath]\n    ) {\n        const value: any = query.selector[primaryPath];\n        if (typeof value === 'string') {\n            return value;\n        } else if (\n            Object.keys(value).length === 1 &&\n            typeof value.$eq === 'string'\n        ) {\n            return value.$eq;\n        }\n\n        // same with $in string arrays\n        if (\n            Object.keys(value).length === 1 &&\n            Array.isArray(value.$eq) &&\n            // must only contain strings\n            !(value.$eq as any[]).find(r => typeof r !== 'string')\n        ) {\n            return value.$eq;\n        }\n    }\n    return false;\n}\n\n\n\nexport function isRxQuery(obj: any): boolean {\n    return obj instanceof RxQueryBase;\n}\n", "import {\n    isBulkWriteConflictError,\n    newRxError\n} from './rx-error.ts';\nimport {\n    fillWithDefaultSettings,\n    getComposedPrimaryKeyOfDocumentData\n} from './rx-schema-helper.ts';\nimport { getSingleDocument, getWrittenDocumentsFromBulkWriteResponse, writeSingle } from './rx-storage-helper.ts';\nimport type {\n    CollectionsOfDatabase,\n    InternalStoreCollectionDocType,\n    InternalStoreDocType,\n    InternalStoreStorageTokenDocType,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageInstance,\n    RxStorageWriteErrorConflict\n} from './types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    randomToken\n} from './plugins/utils/index.ts';\nimport { prepareQuery } from './rx-query-helper.ts';\n\nexport const INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport const INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\nexport const INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\nexport const INTERNAL_CONTEXT_PIPELINE_CHECKPOINT = 'rx-pipeline-checkpoint';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport const INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\n\nexport const INTERNAL_STORE_SCHEMA: RxJsonSchema<RxDocumentData<InternalStoreDocType<any>>> = fillWithDefaultSettings({\n    version: 0,\n    title: INTERNAL_STORE_SCHEMA_TITLE,\n    primaryKey: {\n        key: 'id',\n        fields: [\n            'context',\n            'key'\n        ],\n        separator: '|'\n    },\n    type: 'object',\n    properties: {\n        id: {\n            type: 'string',\n            maxLength: 200\n        },\n        key: {\n            type: 'string'\n        },\n        context: {\n            type: 'string',\n            enum: [\n                INTERNAL_CONTEXT_COLLECTION,\n                INTERNAL_CONTEXT_STORAGE_TOKEN,\n                INTERNAL_CONTEXT_MIGRATION_STATUS,\n                INTERNAL_CONTEXT_PIPELINE_CHECKPOINT,\n                'OTHER'\n            ]\n        },\n        data: {\n            type: 'object',\n            additionalProperties: true\n        }\n    },\n    indexes: [],\n    required: [\n        'key',\n        'context',\n        'data'\n    ],\n    additionalProperties: false,\n    /**\n     * If the sharding plugin is used,\n     * it must not shard on the internal RxStorageInstance\n     * because that one anyway has only a small amount of documents\n     * and also its creation is in the hot path of the initial page load,\n     * so we should spend less time creating multiple RxStorageInstances.\n     */\n    sharding: {\n        shards: 1,\n        mode: 'collection'\n    }\n});\n\n\nexport function getPrimaryKeyOfInternalDocument(\n    key: string,\n    context: string\n): string {\n    return getComposedPrimaryKeyOfDocumentData<InternalStoreDocType>(\n        INTERNAL_STORE_SCHEMA,\n        {\n            key,\n            context\n        }\n    );\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(\n    storageInstance: RxStorageInstance<InternalStoreDocType<any>, any, any>\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\n    const getAllQueryPrepared = prepareQuery<InternalStoreDocType<any>>(\n        storageInstance.schema,\n        {\n            selector: {\n                context: INTERNAL_CONTEXT_COLLECTION,\n                _deleted: {\n                    $eq: false\n                }\n            },\n            sort: [{ id: 'asc' }],\n            skip: 0\n        }\n    );\n    const queryResult = await storageInstance.query(getAllQueryPrepared);\n    const allDocs = queryResult.documents;\n    return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport const STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\n\nexport const STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(\n    STORAGE_TOKEN_DOCUMENT_KEY,\n    INTERNAL_CONTEXT_STORAGE_TOKEN\n);\n\nexport async function ensureStorageTokenDocumentExists<Collections extends CollectionsOfDatabase = any>(\n    rxDatabase: RxDatabase<Collections>\n): Promise<RxDocumentData<InternalStoreStorageTokenDocType>> {\n\n    /**\n     * To have less read-write cycles,\n     * we just try to insert a new document\n     * and only fetch the existing one if a conflict happened.\n     */\n    const storageToken = randomToken(10);\n\n    const passwordHash = rxDatabase.password ?\n        await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) :\n        undefined;\n\n    const docData: RxDocumentData<InternalStoreStorageTokenDocType> = {\n        id: STORAGE_TOKEN_DOCUMENT_ID,\n        context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n        key: STORAGE_TOKEN_DOCUMENT_KEY,\n        data: {\n            rxdbVersion: rxDatabase.rxdbVersion,\n            token: storageToken,\n            /**\n             * We add the instance token here\n             * to be able to detect if a given RxDatabase instance\n             * is the first instance that was ever created\n             * or if databases have existed earlier on that storage\n             * with the same database name.\n             */\n            instanceToken: rxDatabase.token,\n            passwordHash\n        },\n        _deleted: false,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n    };\n\n    const writeRows = [{ document: docData }];\n    const writeResult = await rxDatabase.internalStore.bulkWrite(\n        writeRows,\n        'internal-add-storage-token'\n    );\n    if (!writeResult.error[0]) {\n        return getWrittenDocumentsFromBulkWriteResponse(\n            'id',\n            writeRows,\n            writeResult\n        )[0];\n    }\n\n    /**\n     * If we get a 409 error,\n     * it means another instance already inserted the storage token.\n     * So we get that token from the database and return that one.\n     */\n    const error = ensureNotFalsy(writeResult.error[0]);\n    if (\n        error.isError &&\n        isBulkWriteConflictError(error)\n    ) {\n        const conflictError = (error as RxStorageWriteErrorConflict<InternalStoreStorageTokenDocType>);\n\n        if (\n            !isDatabaseStateVersionCompatibleWithDatabaseCode(\n                conflictError.documentInDb.data.rxdbVersion,\n                rxDatabase.rxdbVersion\n            )\n        ) {\n            throw newRxError('DM5', {\n                args: {\n                    database: rxDatabase.name,\n                    databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\n                    codeVersion: rxDatabase.rxdbVersion\n                }\n            });\n        }\n\n        if (\n            passwordHash &&\n            passwordHash !== conflictError.documentInDb.data.passwordHash\n        ) {\n            throw newRxError('DB1', {\n                passwordHash,\n                existingPasswordHash: conflictError.documentInDb.data.passwordHash\n            });\n        }\n\n        const storageTokenDocInDb = conflictError.documentInDb;\n        return ensureNotFalsy(storageTokenDocInDb);\n    }\n    throw error;\n}\n\n\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(\n    databaseStateVersion: string,\n    codeVersion: string\n): boolean {\n    if (!databaseStateVersion) {\n        return false;\n    }\n\n    const stateMajor = databaseStateVersion.split('.')[0];\n    const codeMajor = codeVersion.split('.')[0];\n\n    /**\n     * Version v15 data must be upwards compatible to v16\n     */\n    if (stateMajor === '15' && codeMajor === '16') {\n        return true;\n    }\n\n    if (stateMajor !== codeMajor) {\n        return false;\n    }\n\n    return true;\n}\n\n\n\n\n\nexport async function addConnectedStorageToCollection(\n    collection: RxCollection<any, unknown, unknown, unknown>,\n    storageCollectionName: string,\n    schema: RxJsonSchema<any>\n) {\n\n    if (collection.schema.version !== schema.version) {\n        throw newRxError('SNH', {\n            schema,\n            version: collection.schema.version,\n            name: collection.name,\n            collection,\n            args: {\n                storageCollectionName\n            }\n        });\n    }\n\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\n        collectionNameWithVersion,\n        INTERNAL_CONTEXT_COLLECTION\n    );\n\n    while (true) {\n        const collectionDoc = await getSingleDocument(\n            collection.database.internalStore,\n            collectionDocId\n        );\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\n\n        // do nothing if already in array\n        const alreadyThere = saveData.data.connectedStorages\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n        if (alreadyThere) {\n            return;\n        }\n\n        // otherwise add to array and save\n        saveData.data.connectedStorages.push({\n            collectionName: storageCollectionName,\n            schema\n        });\n        try {\n            await writeSingle(\n                collection.database.internalStore,\n                {\n                    previous: ensureNotFalsy(collectionDoc),\n                    document: saveData\n                },\n                'add-connected-storage-to-collection'\n            );\n        } catch (err) {\n            if (!isBulkWriteConflictError(err)) {\n                throw err;\n            }\n            // retry on conflict\n        }\n    }\n}\n\nexport async function removeConnectedStorageFromCollection(\n    collection: RxCollection<any, unknown, unknown, unknown>,\n    storageCollectionName: string,\n    schema: RxJsonSchema<any>\n) {\n    if (collection.schema.version !== schema.version) {\n        throw newRxError('SNH', {\n            schema,\n            version: collection.schema.version,\n            name: collection.name,\n            collection,\n            args: {\n                storageCollectionName\n            }\n        });\n    }\n\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\n        collectionNameWithVersion,\n        INTERNAL_CONTEXT_COLLECTION\n    );\n\n    while (true) {\n        const collectionDoc = await getSingleDocument(\n            collection.database.internalStore,\n            collectionDocId\n        );\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\n\n        // do nothing if not there\n        const isThere = saveData.data.connectedStorages\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n        if (!isThere) {\n            return;\n        }\n\n        // otherwise remove from array and save\n        saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\n        try {\n            await writeSingle(\n                collection.database.internalStore,\n                {\n                    previous: ensureNotFalsy(collectionDoc),\n                    document: saveData\n                },\n                'remove-connected-storage-from-collection'\n            );\n        } catch (err) {\n            if (!isBulkWriteConflictError(err)) {\n                throw err;\n            }\n            // retry on conflict\n        }\n    }\n}\n\n\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nexport function _collectionNamePrimary(name: string, schema: RxJsonSchema<any>) {\n    return name + '-' + schema.version;\n}\n", "import type {\n    HashFunction,\n    InternalStoreDocType,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams\n} from './types/index.d.ts';\nimport {\n    createRevision,\n    flatClone,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    now\n} from './plugins/utils/index.ts';\nimport {\n    fillObjectWithDefaults,\n    fillPrimaryKey\n} from './rx-schema-helper.ts';\nimport type { RxSchema } from './rx-schema.ts';\nimport { runAsyncPluginHooks } from './hooks.ts';\nimport { getAllCollectionDocuments } from './rx-database-internal-store.ts';\nimport { flatCloneDocWithMeta } from './rx-storage-helper.ts';\nimport { overwritable } from './overwritable.ts';\nimport type { RxCollectionBase } from './rx-collection.ts';\nimport { newRxError } from './rx-error.ts';\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nexport function fillObjectDataBeforeInsert<RxDocType>(\n    schema: RxSchema<RxDocType>,\n    data: Partial<RxDocumentData<RxDocType>> | any\n): RxDocumentData<RxDocType> {\n    data = flatClone(data);\n    data = fillObjectWithDefaults(schema, data);\n    if (typeof schema.jsonSchema.primaryKey !== 'string') {\n        data = fillPrimaryKey(\n            schema.primaryPath,\n            schema.jsonSchema,\n            data\n        );\n    }\n    data._meta = getDefaultRxDocumentMeta();\n    if (!Object.prototype.hasOwnProperty.call(data, '_deleted')) {\n        data._deleted = false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(data, '_attachments')) {\n        data._attachments = {};\n    }\n    if (!Object.prototype.hasOwnProperty.call(data, '_rev')) {\n        data._rev = getDefaultRevision();\n    }\n    return data;\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nexport async function createRxCollectionStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>(\n    rxDatabase: RxDatabase<{}, Internals, InstanceCreationOptions>,\n    storageInstanceCreationParams: RxStorageInstanceCreationParams<RxDocumentType, InstanceCreationOptions>\n): Promise<RxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>> {\n    storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;\n    const storageInstance = await rxDatabase.storage.createStorageInstance<RxDocumentType>(\n        storageInstanceCreationParams\n    );\n    return storageInstance;\n}\n\n/**\n * Removes the main storage of the collection\n * and all connected storages like the ones from the replication meta etc.\n */\nexport async function removeCollectionStorages(\n    storage: RxStorage<any, any>,\n    databaseInternalStorage: RxStorageInstance<InternalStoreDocType<any>, any, any>,\n    databaseInstanceToken: string,\n    databaseName: string,\n    collectionName: string,\n    multiInstance: boolean,\n    password?: string,\n    /**\n     * If no hash function is provided,\n     * we assume that the whole internal store is removed anyway\n     * so we do not have to delete the meta documents.\n     */\n    hashFunction?: HashFunction,\n) {\n    const allCollectionMetaDocs = await getAllCollectionDocuments(\n        databaseInternalStorage\n    );\n    const relevantCollectionMetaDocs = allCollectionMetaDocs\n        .filter(metaDoc => metaDoc.data.name === collectionName);\n    let removeStorages: {\n        collectionName: string;\n        schema: RxJsonSchema<any>;\n        isCollection: boolean;\n    }[] = [];\n    relevantCollectionMetaDocs.forEach(metaDoc => {\n        removeStorages.push({\n            collectionName: metaDoc.data.name,\n            schema: metaDoc.data.schema,\n            isCollection: true\n        });\n        metaDoc.data.connectedStorages.forEach(row => removeStorages.push({\n            collectionName: row.collectionName,\n            isCollection: false,\n            schema: row.schema\n        }));\n    });\n\n    // ensure uniqueness\n    const alreadyAdded = new Set<string>();\n    removeStorages = removeStorages.filter(row => {\n        const key = row.collectionName + '||' + row.schema.version;\n        if (alreadyAdded.has(key)) {\n            return false;\n        } else {\n            alreadyAdded.add(key);\n            return true;\n        }\n    });\n\n    // remove all the storages\n    await Promise.all(\n        removeStorages\n            .map(async (row) => {\n                const storageInstance = await storage.createStorageInstance<any>({\n                    collectionName: row.collectionName,\n                    databaseInstanceToken,\n                    databaseName,\n                    /**\n                     * multiInstance must be set to true if multiInstance\n                     * was true on the database\n                     * so that the storageInstance can inform other\n                     * instances about being removed.\n                     */\n                    multiInstance,\n                    options: {},\n                    schema: row.schema,\n                    password,\n                    devMode: overwritable.isDevMode()\n                });\n                await storageInstance.remove();\n                if (row.isCollection) {\n                    await runAsyncPluginHooks('postRemoveRxCollection', {\n                        storage,\n                        databaseName: databaseName,\n                        collectionName\n                    });\n                }\n            })\n    );\n\n    // remove the meta documents\n    if (hashFunction) {\n        const writeRows = relevantCollectionMetaDocs.map(doc => {\n            const writeDoc = flatCloneDocWithMeta(doc);\n            writeDoc._deleted = true;\n            writeDoc._meta.lwt = now();\n            writeDoc._rev = createRevision(\n                databaseInstanceToken,\n                doc\n            );\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        await databaseInternalStorage.bulkWrite(\n            writeRows,\n            'rx-database-remove-collection-all'\n        );\n    }\n}\n\n\nexport function ensureRxCollectionIsNotClosed(\n    collection: RxCollection | RxCollectionBase<any, any, any, any, any>\n) {\n    if (collection.closed) {\n        throw newRxError(\n            'COL21',\n            {\n                collection: collection.name,\n                version: collection.schema.version\n            }\n        );\n    }\n}\n", "/**\n * For the ORM capabilities,\n * we have to merge the document prototype\n * with the ORM functions and the data\n * We do this iterating over the properties and\n * adding them to a new object.\n * In the future we should do this by chaining the __proto__ objects\n */\n\nimport type {\n    RxCollection,\n    RxDocument,\n    RxDocumentData\n} from './types/index.d.ts';\nimport {\n    createRxDocumentConstructor,\n    basePrototype,\n    createWithConstructor as createRxDocumentWithConstructor\n} from './rx-document.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\nimport { overwritable } from './overwritable.ts';\nimport { getFromMapOrCreate } from './plugins/utils/index.ts';\n\nconst constructorForCollection = new WeakMap();\n\nexport function getDocumentPrototype(\n    rxCollection: RxCollection\n): any {\n    const schemaProto = rxCollection.schema.getDocumentPrototype();\n    const ormProto = getDocumentOrmPrototype(rxCollection);\n    const baseProto = basePrototype;\n    const proto = {};\n    [\n        schemaProto,\n        ormProto,\n        baseProto\n    ].forEach(obj => {\n        const props = Object.getOwnPropertyNames(obj);\n        props.forEach(key => {\n            const desc: any = Object.getOwnPropertyDescriptor(obj, key);\n            /**\n             * When enumerable is true, it will show on console dir(instance)\n             * To not pollute the output, only getters and methods are enumerable\n             */\n            let enumerable = true;\n            if (\n                key.startsWith('_') ||\n                key.endsWith('_') ||\n                key.startsWith('$') ||\n                key.endsWith('$')\n            ) enumerable = false;\n\n            if (typeof desc.value === 'function') {\n                // when getting a function, we automatically do a .bind(this)\n                Object.defineProperty(proto, key, {\n                    get() {\n                        return desc.value.bind(this);\n                    },\n                    enumerable,\n                    configurable: false\n                });\n\n            } else {\n                desc.enumerable = enumerable;\n                desc.configurable = false;\n                if (desc.writable)\n                    desc.writable = false;\n                Object.defineProperty(proto, key, desc);\n            }\n        });\n    });\n    return proto;\n}\n\nexport function getRxDocumentConstructor<RxDocType, ORM>(\n    rxCollection: RxCollection<RxDocType, ORM>\n) {\n    return getFromMapOrCreate(\n        constructorForCollection,\n        rxCollection,\n        () => createRxDocumentConstructor(\n            getDocumentPrototype(rxCollection as any)\n        )\n    );\n}\n\n/**\n * Create a RxDocument-instance from the jsonData\n * and the prototype merge.\n * You should never call this method directly,\n * instead you should get the document from collection._docCache.getCachedRxDocument().\n */\nexport function createNewRxDocument<RxDocType, ORM, Reactivity>(\n    rxCollection: RxCollection<RxDocType, ORM, {}, {}, Reactivity>,\n    documentConstructor: any,\n    docData: RxDocumentData<RxDocType>\n): RxDocument<RxDocType, ORM, Reactivity> {\n    const doc = createRxDocumentWithConstructor(\n        documentConstructor,\n        rxCollection as any,\n        overwritable.deepFreezeWhenDevMode(docData as any)\n    );\n    rxCollection._runHooksSync('post', 'create', docData, doc);\n    runPluginHooks('postCreateRxDocument', doc);\n    return doc as any;\n}\n\n\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n */\nexport function getDocumentOrmPrototype(rxCollection: RxCollection): any {\n    const proto: any = {};\n    Object\n        .entries(rxCollection.methods)\n        .forEach(([k, v]) => {\n            proto[k] = v;\n        });\n    return proto;\n}\n", "import {\n    deepEqual,\n    flatClone\n} from '../plugins/utils/index.ts';\nimport { stripAttachmentsDataFromDocument } from '../rx-storage-helper.ts';\nimport type { RxConflictHandler, RxDocumentData } from '../types';\n\nexport const defaultConflictHandler: RxConflictHandler<any> = {\n    isEqual(a, b, _ctx) {\n        a = addAttachmentsIfNotExists(a);\n        b = addAttachmentsIfNotExists(b);\n\n        /**\n         * If the documents are deep equal,\n         * we have no conflict.\n         * On your custom conflict handler you might only\n         * check some properties, like the updatedAt time,\n         * for better performance, because deepEqual is expensive.\n        */\n        const ret = deepEqual(\n            stripAttachmentsDataFromDocument(a),\n            stripAttachmentsDataFromDocument(b)\n        );\n\n        return ret;\n    },\n    resolve(i) {\n        /**\n         * The default conflict handler will always\n         * drop the fork state and use the master state instead.\n         */\n        return i.realMasterState;\n    }\n};\n\n\nfunction addAttachmentsIfNotExists<T>(d: RxDocumentData<T>): RxDocumentData<T> {\n    if (!d._attachments) {\n        d = flatClone(d);\n        d._attachments = {};\n    }\n    return d;\n}\n", "/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\nimport {\n    Subscription\n} from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport type {\n    RxCollection,\n    RxStorageChangeEvent\n} from './types/index.d.ts';\nimport {\n    appendToArray,\n    requestIdlePromiseNoQueue\n} from './plugins/utils/index.ts';\n\n\n/**\n * This buffer rembemers previous change events\n * so that queries can use them on .exec()\n * to calculate the new result set via event-reduce instead\n * of running the query against the storage.\n */\nexport class ChangeEventBuffer<RxDocType> {\n    /**\n     * These properties are private to ensure they cannot\n     * be read without first processing the lazy tasks.\n     */\n    private subs: Subscription[] = [];\n    private counter: number = 0;\n    private eventCounterMap: WeakMap<\n        RxStorageChangeEvent<RxDocType>,\n        number\n    > = new WeakMap();\n    /**\n     * array with changeEvents\n     * starts with oldest known event, ends with newest\n    */\n    private buffer: RxStorageChangeEvent<RxDocType>[] = [];\n\n    public limit: number = 100;\n\n\n\n    private tasks = new Set<Function>();\n\n    constructor(\n        public collection: RxCollection\n    ) {\n        this.subs.push(\n            this.collection.eventBulks$.pipe(\n                filter(bulk => !bulk.isLocal)\n            ).subscribe(eventBulk => {\n                this.tasks.add(() => this._handleChangeEvents(eventBulk.events));\n                if (this.tasks.size <= 1) {\n                    requestIdlePromiseNoQueue().then(() => {\n                        this.processTasks();\n                    });\n                }\n            })\n        );\n    }\n\n    private processTasks() {\n        if (this.tasks.size === 0) {\n            return;\n        }\n        const tasks = Array.from(this.tasks);\n        tasks.forEach(task => task());\n        this.tasks.clear();\n    }\n\n    private _handleChangeEvents(events: RxStorageChangeEvent<RxDocType>[]) {\n        const counterBefore = this.counter;\n        this.counter = this.counter + events.length;\n        if (events.length > this.limit) {\n            this.buffer = events.slice(events.length * -1);\n        } else {\n            appendToArray(this.buffer, events);\n            this.buffer = this.buffer.slice(this.limit * -1);\n        }\n        const counterBase = counterBefore + 1;\n        const eventCounterMap = this.eventCounterMap;\n        for (let index = 0; index < events.length; index++) {\n            const event = events[index];\n            eventCounterMap.set(event, counterBase + index);\n        }\n    }\n\n    getCounter() {\n        this.processTasks();\n        return this.counter;\n    }\n    getBuffer() {\n        this.processTasks();\n        return this.buffer;\n    }\n\n    /**\n     * gets the array-index for the given pointer\n     * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n     */\n    getArrayIndexByPointer(pointer: number): number | null {\n        this.processTasks();\n        const oldestEvent = this.buffer[0];\n        const oldestCounter = this.eventCounterMap.get(\n            oldestEvent\n        ) as number;\n\n        if (pointer < oldestCounter)\n            return null; // out of bounds\n\n        const rest = pointer - oldestCounter;\n        return rest;\n    }\n\n    /**\n     * get all changeEvents which came in later than the pointer-event\n     * @return array with change-events. If null, pointer out of bounds\n     */\n    getFrom(pointer: number): RxStorageChangeEvent<RxDocType>[] | null {\n        this.processTasks();\n        const ret = [];\n        let currentIndex = this.getArrayIndexByPointer(pointer);\n        if (currentIndex === null) // out of bounds\n            return null;\n\n        while (true) {\n            const nextEvent = this.buffer[currentIndex];\n            currentIndex++;\n            if (!nextEvent) {\n                return ret;\n            } else {\n                ret.push(nextEvent);\n            }\n        }\n    }\n\n    runFrom(pointer: number, fn: Function) {\n        this.processTasks();\n        const ret = this.getFrom(pointer);\n        if (ret === null) {\n            throw new Error('out of bounds');\n        } else {\n            ret.forEach(cE => fn(cE));\n        }\n    }\n\n    /**\n     * no matter how many operations are done on one document,\n     * only the last operation has to be checked to calculate the new state\n     * this function reduces the events to the last ChangeEvent of each doc.\n     * This functionality is currently disabled. It is questionable if\n     * pre-merging the events would really be faster or actually slower.\n     */\n    reduceByLastOfDoc(changeEvents: RxStorageChangeEvent<RxDocType>[]): RxStorageChangeEvent<RxDocType>[] {\n        this.processTasks();\n        return changeEvents.slice(0);\n    }\n\n    close() {\n        this.tasks.clear();\n        this.subs.forEach(sub => sub.unsubscribe());\n    }\n}\n\nexport function createChangeEventBuffer<RxdocType>(\n    collection: RxCollection<RxdocType, any>\n) {\n    return new ChangeEventBuffer<RxdocType>(collection);\n}\n", "import {\n    filter,\n    map,\n    mergeMap\n} from 'rxjs';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID,\n    NON_PREMIUM_COLLECTION_LIMIT,\n    hasPremiumFlag\n} from './plugins/utils/index.ts';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance,\n    removeCollectionStorages,\n    ensureRxCollectionIsNotClosed\n} from './rx-collection-helper.ts';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query.ts';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error.ts';\nimport type {\n    RxMigrationState\n} from './plugins/migration-schema/index.ts';\nimport {\n    DocumentCache,\n    mapDocumentsDataToCacheDocs\n} from './doc-cache.ts';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache.ts';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer.ts';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks.ts';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageWriteError,\n    RxDocumentData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase,\n    RxConflictHandler,\n    MaybePromise,\n    CRDTEntry,\n    MangoQuerySelectorAndIndex,\n    MigrationStrategies\n} from './types/index.d.ts';\n\nimport {\n    RxSchema\n} from './rx-schema.ts';\n\nimport {\n    createNewRxDocument,\n    getRxDocumentConstructor\n} from './rx-document-prototype-merge.ts';\nimport {\n    getWrappedStorageInstance,\n    getWrittenDocumentsFromBulkWriteResponse,\n    throwIfIsStorageWriteError,\n    WrappedRxStorageInstance\n} from './rx-storage-helper.ts';\nimport { IncrementalWriteQueue } from './incremental-write.ts';\nimport { beforeDocumentUpdateWrite } from './rx-document.ts';\nimport { overwritable } from './overwritable.ts';\nimport type { RxPipeline, RxPipelineOptions } from './plugins/pipeline/index.ts';\nimport { defaultConflictHandler } from './replication-protocol/default-conflict-handler.ts';\nimport { rxChangeEventBulkToRxChangeEvents } from './rx-change-event.ts';\n\nconst HOOKS_WHEN = ['pre', 'post'] as const;\ntype HookWhenType = typeof HOOKS_WHEN[number];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'] as const;\ntype HookKeyType = typeof HOOKS_KEYS[number];\nlet hooksApplied = false;\n\nexport const OPEN_COLLECTIONS = new Set<RxCollectionBase<any, any, any>>();\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any; },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any; },\n    Reactivity = any\n> {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: WrappedRxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n    public incrementalWriteQueue: IncrementalWriteQueue<RxDocumentType> = {} as any;\n\n\n    /**\n     * Before reads, all these methods are awaited. Used to \"block\" reads\n     * depending on other processes, like when the RxPipeline is running.\n     */\n    public readonly awaitBeforeReads = new Set<() => MaybePromise<any>>();\n\n    constructor(\n        public readonly database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions, Reactivity>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: MigrationStrategies = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {},\n        public conflictHandler: RxConflictHandler<RxDocumentType> = defaultConflictHandler\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n\n\n        if (database) { // might be falsy on pseudoInstance\n            this.eventBulks$ = database.eventBulks$.pipe(\n                filter(changeEventBulk => changeEventBulk.collectionName === this.name)\n            );\n        } else { }\n\n\n        /**\n         * Must be last because the hooks might throw on dev-mode\n         * checks and we do not want to have broken collections here.\n         * RxCollection instances created for testings do not have a database\n         * so we do not add these to the list.\n         */\n        if (this.database) {\n            OPEN_COLLECTIONS.add(this);\n        }\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    public _incrementalUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: {\n        [key in HookKeyType]: {\n            [when in HookWhenType]: {\n                series: Function[];\n                parallel: Function[];\n            };\n        }\n    } = {} as any;\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocumentCache<RxDocumentType, OrmMethods> = {} as any;\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public checkpoint$: Observable<any> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer<RxDocumentType> = {} as ChangeEventBuffer<RxDocumentType>;\n\n    /**\n     * Internally only use eventBulks$\n     * Do not use .$ or .observable$ because that has to transform\n     * the events which decreases performance.\n     */\n    public readonly eventBulks$: Observable<RxChangeEventBulk<any>> = {} as any;\n\n\n    /**\n     * When the collection is closed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n    */\n    public onClose: (() => MaybePromise<any>)[] = [];\n    public closed = false;\n\n    public onRemove: (() => MaybePromise<any>)[] = [];\n\n    public async prepare(): Promise<void> {\n\n        if (!(await hasPremiumFlag())) {\n\n            /**\n             * When used in a test suite, we often open and close many databases with collections\n             * while not awaiting the database.close() call to improve the test times.\n             * So when reopening collections and the OPEN_COLLECTIONS size is full,\n             * we retry after some times to account for this.\n             */\n            let count = 0;\n            while (count < 10 && OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n                count++;\n                await this.promiseWait(30);\n            }\n            if (OPEN_COLLECTIONS.size > NON_PREMIUM_COLLECTION_LIMIT) {\n                throw newRxError('COL23', {\n                    database: this.database.name,\n                    collection: this.name,\n                    args: {\n                        existing: Array.from(OPEN_COLLECTIONS.values()).map(c => ({\n                            db: c.database ? c.database.name : '',\n                            c: c.name\n                        }))\n                    }\n                });\n            }\n        }\n\n\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n        this.incrementalWriteQueue = new IncrementalWriteQueue<RxDocumentType>(\n            this.storageInstance,\n            this.schema.primaryPath,\n            (newData, oldData) => beforeDocumentUpdateWrite(this as any, newData, oldData),\n            result => this._runHooks('post', 'save', result)\n        );\n\n        this.$ = this.eventBulks$.pipe(\n            mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk)),\n        );\n        this.checkpoint$ = this.eventBulks$.pipe(\n            map(changeEventBulk => changeEventBulk.checkpoint),\n        );\n\n        this._changeEventBuffer = createChangeEventBuffer<RxDocumentType>(this.asRxCollection);\n        let documentConstructor: any;\n        this._docCache = new DocumentCache(\n            this.schema.primaryPath,\n            this.eventBulks$.pipe(\n                filter(bulk => !bulk.isLocal),\n                map(bulk => bulk.events)\n            ),\n            docData => {\n                if (!documentConstructor) {\n                    documentConstructor = getRxDocumentConstructor(this.asRxCollection);\n                }\n                return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\n            }\n        );\n\n\n        const listenToRemoveSub = this.database.internalStore.changeStream().pipe(\n            filter(bulk => {\n                const key = this.name + '-' + this.schema.version;\n                const found = bulk.events.find(event => {\n                    return (\n                        event.documentData.context === 'collection' &&\n                        event.documentData.key === key &&\n                        event.operation === 'DELETE'\n                    );\n                });\n                return !!found;\n            })\n        ).subscribe(async () => {\n            await this.close();\n            await Promise.all(this.onRemove.map(fn => fn()));\n        });\n        this._subs.push(listenToRemoveSub);\n\n\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                isLocal: false,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events: eventBulk.events,\n                databaseToken: this.database.token,\n                checkpoint: eventBulk.checkpoint,\n                context: eventBulk.context\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    /**\n     * Manually call the cleanup function of the storage.\n     * @link https://rxdb.info/cleanup.html\n     */\n    cleanup(_minimumDeletedTime?: number): Promise<boolean> {\n        ensureRxCollectionIsNotClosed(this);\n        throw pluginMissing('cleanup');\n    }\n\n    // overwritten by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration-schema');\n    }\n    getMigrationState(): RxMigrationState {\n        throw pluginMissing('migration-schema');\n    }\n    startMigration(batchSize: number = 10): Promise<void> {\n        ensureRxCollectionIsNotClosed(this);\n        return this.getMigrationState().startMigration(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getMigrationState().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotClosed(this);\n        const writeResult = await this.bulkInsert([json as any]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, (json as any)[this.schema.primaryPath] as any, json, isError as any);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n        return insertResult;\n    }\n\n    async insertIfNotExists(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        const writeResult = await this.bulkInsert([json as any]);\n        if (writeResult.error.length > 0) {\n            const error = writeResult.error[0];\n            if (error.status === 409) {\n                const conflictDocData = error.documentInDb;\n                return mapDocumentsDataToCacheDocs(this._docCache, [conflictDocData])[0];\n\n            } else {\n                throw error;\n            }\n        }\n        return writeResult.success[0];\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotClosed(this);\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n        */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const primaryPath = this.schema.primaryPath;\n\n        const ids = new Set<string>();\n\n        /**\n         * This code is a bit redundant for better performance.\n         * Instead of iterating multiple times,\n         * we directly transform the input to a write-row array.\n         */\n        let insertRows: BulkWriteRow<RxDocumentType>[];\n        if (this.hasHooks('pre', 'insert')) {\n            insertRows = await Promise.all(\n                docsData.map(docData => {\n                    const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n                    return this._runHooks('pre', 'insert', useDocData)\n                        .then(() => {\n                            ids.add((useDocData as any)[primaryPath]);\n                            return { document: useDocData };\n                        });\n                })\n            );\n        } else {\n            insertRows = new Array(docsData.length);\n            const schema = this.schema;\n            for (let index = 0; index < docsData.length; index++) {\n                const docData = docsData[index];\n                const useDocData = fillObjectDataBeforeInsert(schema, docData);\n                ids.add((useDocData as any)[primaryPath]);\n                insertRows[index] = { document: useDocData };\n            }\n        }\n\n\n        if (ids.size !== docsData.length) {\n            throw newRxError('COL22', {\n                collection: this.name,\n                args: {\n                    documents: docsData\n                }\n            });\n        }\n\n        const results = await this.storageInstance.bulkWrite(\n            insertRows,\n            'rx-collection-bulk-insert'\n        );\n\n\n        /**\n         * Often the user does not need to access the RxDocuments of the bulkInsert() call.\n         * So we transform the data to RxDocuments only if needed to use less CPU performance.\n         */\n        let rxDocuments: RxDocument<RxDocumentType, OrmMethods>[];\n        const collection = this;\n        const ret = {\n            get success() {\n                if (!rxDocuments) {\n                    const success = getWrittenDocumentsFromBulkWriteResponse(\n                        collection.schema.primaryPath,\n                        insertRows,\n                        results\n                    );\n                    rxDocuments = mapDocumentsDataToCacheDocs<RxDocumentType, OrmMethods>(collection._docCache, success);\n                }\n                return rxDocuments;\n            },\n            error: results.error\n        };\n\n        if (this.hasHooks('post', 'insert')) {\n            const docsMap: Map<string, RxDocumentType> = new Map();\n            insertRows.forEach(row => {\n                const doc = row.document;\n                docsMap.set((doc as any)[primaryPath] as any, doc);\n            });\n            await Promise.all(\n                ret.success.map(doc => {\n                    return this._runHooks(\n                        'post',\n                        'insert',\n                        docsMap.get(doc.primary),\n                        doc\n                    );\n                })\n            );\n        }\n\n        return ret;\n    }\n\n    async bulkRemove(\n        /**\n         * You can either remove the documents by their ids\n         * or by directly providing the RxDocument instances\n         * if you have them already. This improves performance a bit.\n         */\n        idsOrDocs: string[] | RxDocument<RxDocumentType>[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotClosed(this);\n        const primaryPath = this.schema.primaryPath;\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (idsOrDocs.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        let rxDocumentMap: Map<string, RxDocument<RxDocumentType, OrmMethods>>;\n        if (typeof idsOrDocs[0] === 'string') {\n            rxDocumentMap = await this.findByIds(idsOrDocs as string[]).exec();\n        } else {\n            rxDocumentMap = new Map();\n            (idsOrDocs as RxDocument<RxDocumentType, OrmMethods>[]).forEach(d => rxDocumentMap.set(d.primary, d));\n        }\n\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = rxDocument.toMutableJSON(true) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(\n            removeDocs,\n            'rx-collection-bulk-remove'\n        );\n\n\n        const success = getWrittenDocumentsFromBulkWriteResponse(\n            this.schema.primaryPath,\n            removeDocs,\n            results\n        );\n\n        const deletedRxDocuments: RxDocument<RxDocumentType, OrmMethods>[] = [];\n        const successIds: string[] = success.map(d => {\n            const id = d[primaryPath] as string;\n            const doc = this._docCache.getCachedRxDocument(d);\n            deletedRxDocuments.push(doc);\n            return id;\n        });\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n\n        return {\n            success: deletedRxDocuments,\n            error: results.error\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotClosed(this);\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        const success = insertResult.success.slice(0);\n        const error: RxStorageWriteError<RxDocumentType>[] = [];\n\n        // update the ones that existed already\n        await Promise.all(\n            insertResult.error.map(async (err) => {\n                if (err.status !== 409) {\n                    error.push(err);\n                } else {\n                    const id = err.documentId;\n                    const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                    const docDataInDb = ensureNotFalsy(err.documentInDb);\n                    const doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\n                    const newDoc = await doc.incrementalModify(() => writeData);\n                    success.push(newDoc);\n                }\n            })\n        );\n        return {\n            error,\n            success\n        };\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    async upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotClosed(this);\n        const bulkResult = await this.bulkUpsert([json]);\n        throwIfIsStorageWriteError<RxDocumentType>(\n            this.asRxCollection,\n            (json as any)[this.schema.primaryPath],\n            json as any,\n            bulkResult.error[0]\n        );\n        return bulkResult.success[0];\n    }\n\n    /**\n     * upserts to a RxDocument, uses incrementalModify if document already exists\n     */\n    incrementalUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotClosed(this);\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it won't try 2 parallel runs\n        let queue = this._incrementalUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _incrementalUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted) => {\n                if (!wasInserted.inserted) {\n                    return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._incrementalUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[],\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n\n        runPluginHooks('prePrepareRxQuery', {\n            op: 'find',\n            queryObj,\n            collection: this\n        });\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(\n        queryObj?: MangoQueryNoLimit<RxDocumentType> | string\n    ): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods> | null,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n\n        runPluginHooks('prePrepareRxQuery', {\n            op: 'findOne',\n            queryObj,\n            collection: this\n        });\n\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n            // cannot have limit on findOne queries because it will be overwritten\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            queryObj = flatClone(queryObj);\n            (queryObj as any).limit = 1;\n            query = createRxQuery<RxDocumentType>('findOne', queryObj, this as any);\n        }\n\n\n        return query as any;\n    }\n\n    count(queryObj?: MangoQuerySelectorAndIndex<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        number,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n        const query = createRxQuery('count', queryObj, this as any);\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    findByIds(\n        ids: string[]\n    ): RxQuery<\n        RxDocumentType,\n        Map<string, RxDocument<RxDocumentType, OrmMethods>>,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotClosed(this);\n        const mangoQuery: MangoQuery<RxDocumentType> = {\n            selector: {\n                [this.schema.primaryPath]: {\n                    $in: ids.slice(0)\n                }\n            } as any\n        };\n        const query = createRxQuery('findByIds', mangoQuery, this as any);\n        return query as any;\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    insertCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]): RxDocument<RxDocumentType, OrmMethods> {\n        throw pluginMissing('crdt');\n    }\n\n\n    addPipeline(_options: RxPipelineOptions<RxDocumentType>): Promise<RxPipeline<RxDocumentType>> {\n        throw pluginMissing('pipeline');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: HookWhenType, key: HookKeyType, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: HookWhenType, key: HookKeyType) {\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n        return this.hooks[key][when];\n    }\n\n    hasHooks(when: HookWhenType, key: HookKeyType) {\n        /**\n         * Performance shortcut\n         * so that we not have to build the empty object.\n         */\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return false;\n        }\n\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return false;\n        }\n        return hooks.series.length > 0 || hooks.parallel.length > 0;\n    }\n\n    _runHooks(when: HookWhenType, key: HookKeyType, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: HookWhenType, key: HookKeyType, data: any, instance: any) {\n        if (!this.hasHooks(when, key)) {\n            return;\n        }\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is closed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    async close(): Promise<boolean> {\n        if (this.closed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        OPEN_COLLECTIONS.delete(this);\n\n\n        await Promise.all(this.onClose.map(fn => fn()));\n\n        /**\n         * Settings closed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.closed = true;\n\n\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.close();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                /**\n                 * Unsubscribing must be done AFTER the storageInstance.close()\n                 * Because the conflict handling is part of the subscriptions and\n                 * otherwise there might be open conflicts to be resolved which\n                 * will then stuck and never resolve.\n                 */\n                this._subs.forEach(sub => sub.unsubscribe());\n\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postCloseRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    async remove(): Promise<any> {\n        await this.close();\n        await Promise.all(this.onRemove.map(fn => fn()));\n        /**\n         * TODO here we should pass the already existing\n         * storage instances instead of creating new ones.\n         */\n        await removeCollectionStorages(\n            this.database.storage,\n            this.database.internalStore,\n            this.database.token,\n            this.database.name,\n            this.name,\n            this.database.multiInstance,\n            this.database.password,\n            this.database.hashFunction\n        );\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods, any, Reactivity> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _incrementalUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.incrementalModify((_innerDoc) => {\n        return json;\n    });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists<RxDocType>(\n    rxCollection: RxCollection<RxDocType>,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument<RxDocType>;\n        inserted: boolean;\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n    if (docDataFromCache) {\n        return Promise.resolve({\n            doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport async function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy,\n        conflictHandler = defaultConflictHandler\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance,\n        password: database.password,\n        devMode: overwritable.isDevMode()\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    const storageInstance = await createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    );\n\n    const collection = new RxCollectionBase(\n        database,\n        name,\n        schema,\n        storageInstance,\n        instanceCreationOptions,\n        migrationStrategies,\n        methods,\n        attachments,\n        options,\n        cacheReplacementPolicy,\n        statics,\n        conflictHandler\n    );\n\n    try {\n        await collection.prepare();\n\n        // ORM add statics\n        Object\n            .entries(statics)\n            .forEach(([funName, fun]) => {\n                Object.defineProperty(collection, funName, {\n                    get: () => (fun as any).bind(collection)\n                });\n            });\n\n        runPluginHooks('createRxCollection', {\n            collection,\n            creator: {\n                name,\n                schema,\n                storageInstance,\n                instanceCreationOptions,\n                migrationStrategies,\n                methods,\n                attachments,\n                options,\n                cacheReplacementPolicy,\n                localDocuments,\n                statics\n            }\n        });\n\n        /**\n         * Migration must run after the hooks so that the\n         * dev-mode can check up front if the\n         * migration strategies are correctly set.\n         */\n        if (autoMigrate && collection.schema.version !== 0) {\n            await collection.migratePromise();\n        }\n\n    } catch (err) {\n        /**\n         * If the collection creation fails,\n         * we yet have to close the storage instances.\n         */\n        OPEN_COLLECTIONS.delete(collection);\n        await storageInstance.close();\n        throw err;\n    }\n\n    return collection as any;\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n", "/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n  this._qC = 0;\n\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n  this._iC = new Set();\n\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n  this._lHN = 0;\n\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n    _tryIdleCall(this);\n  },\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @performance is really important here because\n   * it is often used in hot paths.\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n    this._qC++;\n    var maybePromise;\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n        throw err;\n      });\n    }\n  },\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n      resolve();\n    };\n    prom._manRes = resolveFromOutside;\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n    this._iC.add(prom);\n    _tryIdleCall(this);\n    return prom;\n  },\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n    this._hPM.set(handle, promise);\n    this._pHM.set(promise, handle);\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n    this.cancelIdlePromise(promise);\n  },\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n    this._qC = 0;\n    this._iC.clear();\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n  var iterator = idleQueue._iC.values();\n  var oldestPromise = iterator.next().value;\n  oldestPromise._manRes();\n\n  // try to call the next tick\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return;\n\n  // remove timeout if exists\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj);\n\n  // remove handle-nr if exists\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n    idleQueue._hPM[\"delete\"](handle);\n    idleQueue._pHM[\"delete\"](promise);\n  }\n\n  // remove from queue\n  idleQueue._iC[\"delete\"](promise);\n}\n\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\nfunction _tryIdleCall(idleQueue) {\n  // console.log('_tryIdleCall:');\n  // console.dir({\n  //     try: idleQueue._tryIR,\n  //     size: idleQueue._iC.size\n  // });\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true;\n\n  // w8 one tick\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      }\n\n      // ressource is idle\n      _resolveOneIdleCall(idleQueue);\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}", "import { IdleQueue } from 'custom-idle-queue';\nimport type {\n    LeaderElector\n} from 'broadcast-channel';\nimport { ObliviousSet } from 'oblivious-set';\nimport type {\n    CollectionsOfDatabase,\n    RxDatabase,\n    RxCollectionCreator,\n    RxJsonSchema,\n    RxCollection,\n    RxDumpDatabase,\n    RxDumpDatabaseAny,\n    BackupOptions,\n    RxStorage,\n    RxStorageInstance,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxDatabaseCreator,\n    RxChangeEventBulk,\n    RxDocumentData,\n    RxCleanupPolicy,\n    InternalStoreDocType,\n    InternalStoreStorageTokenDocType,\n    InternalStoreCollectionDocType,\n    RxTypeError,\n    RxError,\n    HashFunction,\n    MaybePromise,\n    RxState\n} from './types/index.d.ts';\n\nimport {\n    pluginMissing,\n    flatClone,\n    PROMISE_RESOLVE_FALSE,\n    randomToken,\n    ensureNotFalsy,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    defaultHashSha256,\n    RXDB_VERSION\n} from './plugins/utils/index.ts';\nimport {\n    newRxError\n} from './rx-error.ts';\nimport {\n    createRxSchema,\n    RxSchema\n} from './rx-schema.ts';\nimport {\n    runPluginHooks,\n    runAsyncPluginHooks\n} from './hooks.ts';\nimport {\n    Subject,\n    Subscription,\n    Observable\n} from 'rxjs';\nimport {\n    mergeMap\n} from 'rxjs/operators';\nimport {\n    createRxCollection\n} from './rx-collection.ts';\nimport {\n    flatCloneDocWithMeta,\n    getSingleDocument,\n    getWrappedStorageInstance,\n    INTERNAL_STORAGE_NAME,\n    WrappedRxStorageInstance\n} from './rx-storage-helper.ts';\nimport type { RxBackupState } from './plugins/backup/index.ts';\nimport {\n    ensureStorageTokenDocumentExists,\n    getAllCollectionDocuments,\n    getPrimaryKeyOfInternalDocument,\n    INTERNAL_CONTEXT_COLLECTION,\n    INTERNAL_STORE_SCHEMA,\n    _collectionNamePrimary\n} from './rx-database-internal-store.ts';\nimport { removeCollectionStorages } from './rx-collection-helper.ts';\nimport { overwritable } from './overwritable.ts';\nimport type { RxMigrationState } from './plugins/migration-schema/index.ts';\nimport type { RxReactivityFactory } from './types/plugins/reactivity.d.ts';\nimport { rxChangeEventBulkToRxChangeEvents } from './rx-change-event.ts';\n\n/**\n * stores the used database names+storage names\n * so we can throw when the same database is created more then once.\n */\nconst USED_DATABASE_NAMES: Set<string> = new Set();\nconst DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP = new Map<string, Set<Promise<RxDatabase>>>();\n\nlet DB_COUNT = 0;\n\nexport class RxDatabaseBase<\n    Internals,\n    InstanceCreationOptions,\n    Collections = CollectionsOfDatabase,\n    Reactivity = unknown\n> {\n\n    public readonly idleQueue: IdleQueue = new IdleQueue();\n    public readonly rxdbVersion = RXDB_VERSION;\n\n    /**\n     * Contains all known non-closed storage instances\n     * that belong to this database.\n     * Used in plugins and unit tests.\n     */\n    public readonly storageInstances = new Set<WrappedRxStorageInstance<any, Internals, InstanceCreationOptions>>();\n\n    constructor(\n        public readonly name: string,\n        /**\n         * Uniquely identifies the instance\n         * of this RxDatabase.\n         */\n        public readonly token: string,\n        public readonly storage: RxStorage<Internals, InstanceCreationOptions>,\n        public readonly instanceCreationOptions: InstanceCreationOptions,\n        public readonly password: any,\n        public readonly multiInstance: boolean,\n        public readonly eventReduce: boolean = false,\n        public options: any = {},\n        /**\n         * Stores information documents about the collections of the database\n         */\n        public readonly internalStore: RxStorageInstance<InternalStoreDocType, Internals, InstanceCreationOptions>,\n        public readonly hashFunction: HashFunction,\n        public readonly cleanupPolicy?: Partial<RxCleanupPolicy>,\n        public readonly allowSlowCount?: boolean,\n        public readonly reactivity?: RxReactivityFactory<any>,\n        public readonly onClosed?: () => void,\n    ) {\n        DB_COUNT++;\n\n        /**\n         * In the dev-mode, we create a pseudoInstance\n         * to get all properties of RxDatabase and ensure they do not\n         * conflict with the collection names etc.\n         * So only if it is not pseudoInstance,\n         * we have all values to prepare a real RxDatabase.\n         *\n         * TODO this is ugly, we should use a different way in the dev-mode\n         * so that all non-dev-mode code can be cleaner.\n         */\n        if (this.name !== 'pseudoInstance') {\n            /**\n             * Wrap the internal store\n             * to ensure that calls to it also end up in\n             * calculation of the idle state and the hooks.\n             */\n            this.internalStore = getWrappedStorageInstance(\n                this.asRxDatabase,\n                internalStore,\n                INTERNAL_STORE_SCHEMA\n            );\n\n            /**\n             * Start writing the storage token.\n             * Do not await the creation because it would run\n             * in a critical path that increases startup time.\n             *\n             * Writing the token takes about 20 milliseconds\n             * even on a fast adapter, so this is worth it.\n             */\n            this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase)\n                .catch(err => this.startupErrors.push(err) as any);\n            this.storageToken = this.storageTokenDocument\n                .then(doc => doc.data.token)\n                .catch(err => this.startupErrors.push(err) as any);\n        }\n    }\n\n    get $(): Observable<RxChangeEvent<any>> {\n        return this.observable$;\n    }\n\n    public getReactivityFactory(): RxReactivityFactory<Reactivity> {\n        if (!this.reactivity) {\n            throw newRxError('DB14', { database: this.name });\n        }\n        return this.reactivity;\n    }\n\n    public _subs: Subscription[] = [];\n\n    /**\n     * Because having unhandled exceptions would fail,\n     * we have to store the async errors of the constructor here\n     * so we can throw them later.\n     */\n    public startupErrors: (RxError | RxTypeError)[] = [];\n\n    /**\n     * When the database is closed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n    public onClose: (() => MaybePromise<any>)[] = [];\n    public closed: boolean = false;\n    public collections: Collections = {} as any;\n    public states: { [name: string]: RxState<any, Reactivity>; } = {};\n\n    /**\n     * Internally only use eventBulks$\n     * Do not use .$ or .observable$ because that has to transform\n     * the events which decreases performance.\n     */\n    public readonly eventBulks$: Subject<RxChangeEventBulk<any>> = new Subject();\n\n    private closePromise: Promise<boolean> | null = null;\n\n    private observable$: Observable<RxChangeEvent<any>> = this.eventBulks$\n        .pipe(\n            mergeMap(changeEventBulk => rxChangeEventBulkToRxChangeEvents(changeEventBulk))\n        );\n\n    /**\n     * Unique token that is stored with the data.\n     * Used to detect if the dataset has been deleted\n     * and if two RxDatabase instances work on the same dataset or not.\n     *\n     * Because reading and writing the storageToken runs in the hot path\n     * of database creation, we do not await the storageWrites but instead\n     * work with the promise when we need the value.\n     */\n    public storageToken: Promise<string> = PROMISE_RESOLVE_FALSE as any;\n    /**\n     * Stores the whole state of the internal storage token document.\n     * We need this in some plugins.\n     */\n    public storageTokenDocument: Promise<RxDocumentData<InternalStoreStorageTokenDocType>> = PROMISE_RESOLVE_FALSE as any;\n\n    /**\n     * Contains the ids of all event bulks that have been emitted\n     * by the database.\n     * Used to detect duplicates that come in again via BroadcastChannel\n     * or other streams.\n     * In the past we tried to remove this and to ensure\n     * all storages only emit the same event bulks only once\n     * but it turns out this is just not possible for all storages.\n     * JavaScript processes, workers and browser tabs can be closed and started at any time\n     * which can cause cases where it is not possible to know if an event bulk has been emitted already.\n     */\n    public emittedEventBulkIds: ObliviousSet<string> = new ObliviousSet(60 * 1000);\n\n    /**\n     * This is the main handle-point for all change events\n     * ChangeEvents created by this instance go:\n     * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n     * ChangeEvents created by other instances go:\n     * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n     */\n    $emit(changeEventBulk: RxChangeEventBulk<any>) {\n        if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n            return;\n        }\n        this.emittedEventBulkIds.add(changeEventBulk.id);\n        this.eventBulks$.next(changeEventBulk);\n    }\n\n    /**\n     * removes the collection-doc from the internalStore\n     */\n    async removeCollectionDoc(name: string, schema: any): Promise<void> {\n        const doc = await getSingleDocument(\n            this.internalStore,\n            getPrimaryKeyOfInternalDocument(\n                _collectionNamePrimary(name, schema),\n                INTERNAL_CONTEXT_COLLECTION\n            )\n        );\n        if (!doc) {\n            throw newRxError('SNH', { name, schema });\n        }\n        const writeDoc = flatCloneDocWithMeta(doc);\n        writeDoc._deleted = true;\n\n        await this.internalStore.bulkWrite([{\n            document: writeDoc,\n            previous: doc\n        }], 'rx-database-remove-collection');\n    }\n\n    /**\n     * creates multiple RxCollections at once\n     * to be much faster by saving db txs and doing stuff in bulk-operations\n     * This function is not called often, but mostly in the critical path at the initial page load\n     * So it must be as fast as possible.\n     */\n    async addCollections<CreatedCollections = Partial<Collections>>(collectionCreators: {\n        [key in keyof CreatedCollections]: RxCollectionCreator<any>\n    }): Promise<{ [key in keyof CreatedCollections]: RxCollection<any, {}, {}, {}, Reactivity> }> {\n        const jsonSchemas: { [key in keyof CreatedCollections]: RxJsonSchema<any> } = {} as any;\n        const schemas: { [key in keyof CreatedCollections]: RxSchema<any> } = {} as any;\n        const bulkPutDocs: BulkWriteRow<InternalStoreCollectionDocType>[] = [];\n        const useArgsByCollectionName: any = {};\n\n        await Promise.all(\n            Object.entries(collectionCreators).map(async ([name, args]) => {\n                const collectionName: keyof CreatedCollections = name as any;\n                const rxJsonSchema = (args as RxCollectionCreator<any>).schema;\n                jsonSchemas[collectionName] = rxJsonSchema;\n                const schema = createRxSchema(rxJsonSchema, this.hashFunction);\n                schemas[collectionName] = schema;\n\n                // collection already exists\n                if ((this.collections as any)[name]) {\n                    throw newRxError('DB3', {\n                        name\n                    });\n                }\n\n                const collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n                const collectionDocData: RxDocumentData<InternalStoreCollectionDocType> = {\n                    id: getPrimaryKeyOfInternalDocument(\n                        collectionNameWithVersion,\n                        INTERNAL_CONTEXT_COLLECTION\n                    ),\n                    key: collectionNameWithVersion,\n                    context: INTERNAL_CONTEXT_COLLECTION,\n                    data: {\n                        name: collectionName as any,\n                        schemaHash: await schema.hash,\n                        schema: schema.jsonSchema,\n                        version: schema.version,\n                        connectedStorages: []\n                    },\n                    _deleted: false,\n                    _meta: getDefaultRxDocumentMeta(),\n                    _rev: getDefaultRevision(),\n                    _attachments: {}\n                };\n                bulkPutDocs.push({\n                    document: collectionDocData\n                });\n\n                const useArgs: any = Object.assign(\n                    {},\n                    args,\n                    {\n                        name: collectionName,\n                        schema,\n                        database: this\n                    }\n                );\n\n                // run hooks\n                const hookData: RxCollectionCreator<any> & { name: string; } = flatClone(args) as any;\n                (hookData as any).database = this;\n                hookData.name = name;\n                runPluginHooks('preCreateRxCollection', hookData);\n                useArgs.conflictHandler = hookData.conflictHandler;\n\n                useArgsByCollectionName[collectionName] = useArgs;\n            })\n        );\n\n\n        const putDocsResult = await this.internalStore.bulkWrite(\n            bulkPutDocs,\n            'rx-database-add-collection'\n        );\n\n        await ensureNoStartupErrors(this);\n\n        await Promise.all(\n            putDocsResult.error.map(async (error) => {\n                if (error.status !== 409) {\n                    throw newRxError('DB12', {\n                        database: this.name,\n                        writeError: error\n                    });\n                }\n                const docInDb: RxDocumentData<InternalStoreCollectionDocType> = ensureNotFalsy(error.documentInDb);\n                const collectionName = docInDb.data.name;\n                const schema = (schemas as any)[collectionName];\n                // collection already exists but has different schema\n                if (docInDb.data.schemaHash !== await schema.hash) {\n                    throw newRxError('DB6', {\n                        database: this.name,\n                        collection: collectionName,\n                        previousSchemaHash: docInDb.data.schemaHash,\n                        schemaHash: await schema.hash,\n                        previousSchema: docInDb.data.schema,\n                        schema: ensureNotFalsy((jsonSchemas as any)[collectionName])\n                    });\n                }\n            })\n        );\n\n        const ret: { [key in keyof CreatedCollections]: RxCollection<any, {}, {}, {}, Reactivity> } = {} as any;\n        await Promise.all(\n            Object.keys(collectionCreators).map(async (collectionName) => {\n                const useArgs = useArgsByCollectionName[collectionName];\n                const collection = await createRxCollection(useArgs);\n                (ret as any)[collectionName] = collection;\n\n                // set as getter to the database\n                (this.collections as any)[collectionName] = collection;\n                if (!(this as any)[collectionName]) {\n                    Object.defineProperty(this, collectionName, {\n                        get: () => (this.collections as any)[collectionName]\n                    });\n                }\n            })\n        );\n\n        return ret;\n    }\n\n    /**\n     * runs the given function between idleQueue-locking\n     */\n    lockedRun<T>(fn: (...args: any[]) => T): T extends Promise<any> ? T : Promise<T> {\n        return this.idleQueue.wrapCall(fn) as any;\n    }\n\n    requestIdlePromise() {\n        return this.idleQueue.requestIdlePromise();\n    }\n\n    /**\n     * Export database to a JSON friendly format.\n     */\n    exportJSON(_collections?: string[]): Promise<RxDumpDatabase<Collections>>;\n    exportJSON(_collections?: string[]): Promise<RxDumpDatabaseAny<Collections>>;\n    exportJSON(_collections?: string[]): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    addState<T = any>(_name?: string): Promise<RxState<T, Reactivity>> {\n        throw pluginMissing('state');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n     * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n     * since data could be encrypted.\n     */\n    importJSON(_exportedJSON: RxDumpDatabaseAny<Collections>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    backup(_options: BackupOptions): RxBackupState {\n        throw pluginMissing('backup');\n    }\n\n    public leaderElector(): LeaderElector {\n        throw pluginMissing('leader-election');\n    }\n\n    public isLeader(): boolean {\n        throw pluginMissing('leader-election');\n    }\n    /**\n     * returns a promise which resolves when the instance becomes leader\n     */\n    public waitForLeadership(): Promise<boolean> {\n        throw pluginMissing('leader-election');\n    }\n\n    public migrationStates(): Observable<RxMigrationState[]> {\n        throw pluginMissing('migration-schema');\n    }\n\n    /**\n     * closes the database-instance and all collections\n     */\n    public close(): Promise<boolean> {\n        if (this.closePromise) {\n            return this.closePromise;\n        }\n\n        const { promise, resolve } = createPromiseWithResolvers<boolean>();\n        const resolveClosePromise = (result: boolean) => {\n            if (this.onClosed) {\n                this.onClosed();\n            }\n            this.closed = true;\n            resolve(result);\n        };\n        this.closePromise = promise;\n\n        (async () => {\n            await runAsyncPluginHooks('preCloseRxDatabase', this);\n            /**\n             * Complete the event stream\n             * to stop all subscribers who forgot to unsubscribe.\n             */\n            this.eventBulks$.complete();\n\n            DB_COUNT--;\n            this._subs.map(sub => sub.unsubscribe());\n\n            /**\n             * closing the pseudo instance will throw\n             * because stuff is missing\n             * TODO we should not need the pseudo instance on runtime.\n             * we should generate the property list on build time.\n             */\n            if (this.name === 'pseudoInstance') {\n                resolveClosePromise(false);\n                return;\n            }\n\n            /**\n             * First wait until the database is idle\n             */\n            return this.requestIdlePromise()\n                .then(() => Promise.all(this.onClose.map(fn => fn())))\n                // close all collections\n                .then(() => Promise.all(\n                    Object.keys(this.collections as any)\n                        .map(key => (this.collections as any)[key])\n                        .map(col => col.close())\n                ))\n                // close internal storage instances\n                .then(() => this.internalStore.close())\n                .then(() => resolveClosePromise(true));\n        })();\n\n        return promise;\n    }\n\n    /**\n     * deletes the database and its stored data.\n     * Returns the names of all removed collections.\n     */\n    remove(): Promise<string[]> {\n        return this\n            .close()\n            .then(() => removeRxDatabase(this.name, this.storage, this.multiInstance, this.password));\n    }\n\n    get asRxDatabase(): RxDatabase<\n        {},\n        Internals,\n        InstanceCreationOptions,\n        Reactivity\n    > {\n        return this as any;\n    }\n}\n\n/**\n * checks if an instance with same name and storage already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(\n    name: string,\n    storage: RxStorage<any, any>\n) {\n    if (USED_DATABASE_NAMES.has(getDatabaseNameKey(name, storage))) {\n        throw newRxError('DB8', {\n            name,\n            storage: storage.name,\n            link: 'https://rxdb.info/rx-database.html#ignoreduplicate'\n        });\n    }\n}\n\n/**\n * ponyfill for https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\n */\nfunction createPromiseWithResolvers<T>() {\n    let resolve!: (value: T | PromiseLike<T>) => void;\n    let reject!: (reason?: any) => void;\n    const promise = new Promise<T>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n    return { promise, resolve, reject };\n}\n\nfunction getDatabaseNameKey(\n    name: string,\n    storage: RxStorage<any, any>\n) {\n    return storage.name + '|' + name;\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport async function createRxDatabaseStorageInstance<Internals, InstanceCreationOptions>(\n    databaseInstanceToken: string,\n    storage: RxStorage<Internals, InstanceCreationOptions>,\n    databaseName: string,\n    options: InstanceCreationOptions,\n    multiInstance: boolean,\n    password?: string\n): Promise<RxStorageInstance<InternalStoreDocType, Internals, InstanceCreationOptions>> {\n    const internalStore = await storage.createStorageInstance<InternalStoreDocType>(\n        {\n            databaseInstanceToken,\n            databaseName,\n            collectionName: INTERNAL_STORAGE_NAME,\n            schema: INTERNAL_STORE_SCHEMA,\n            options,\n            multiInstance,\n            password,\n            devMode: overwritable.isDevMode()\n        }\n    );\n    return internalStore;\n}\n\nexport function createRxDatabase<\n    Collections = { [key: string]: RxCollection; },\n    Internals = any,\n    InstanceCreationOptions = any,\n    Reactivity = unknown\n>(\n    {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance = true,\n        eventReduce = true,\n        ignoreDuplicate = false,\n        options = {},\n        cleanupPolicy,\n        closeDuplicates = false,\n        allowSlowCount = false,\n        localDocuments = false,\n        hashFunction = defaultHashSha256,\n        reactivity\n    }: RxDatabaseCreator<Internals, InstanceCreationOptions, Reactivity>\n): Promise<\n    RxDatabase<Collections, Internals, InstanceCreationOptions, Reactivity>\n> {\n    runPluginHooks('preCreateRxDatabase', {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n    });\n\n    const databaseNameKey = getDatabaseNameKey(name, storage);\n    const databaseNameKeyUnclosedInstancesSet = DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.get(databaseNameKey) || new Set();\n    const instancePromiseWithResolvers = createPromiseWithResolvers<RxDatabase<Collections, Internals, InstanceCreationOptions, Reactivity>>();\n    const closeDuplicatesPromises = Array.from(databaseNameKeyUnclosedInstancesSet);\n    const onInstanceClosed = () => {\n        databaseNameKeyUnclosedInstancesSet.delete(instancePromiseWithResolvers.promise as any as Promise<RxDatabase>);\n        USED_DATABASE_NAMES.delete(databaseNameKey);\n    };\n\n    databaseNameKeyUnclosedInstancesSet.add(instancePromiseWithResolvers.promise as any as Promise<RxDatabase>);\n    DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP.set(databaseNameKey, databaseNameKeyUnclosedInstancesSet);\n\n    (async () => {\n        if (closeDuplicates) {\n            await Promise.all(\n                closeDuplicatesPromises.map((unclosedInstancePromise) =>\n                    unclosedInstancePromise\n                        .catch(() => null)\n                        .then((instance) => instance && instance.close())\n                )\n            );\n        }\n\n        if (ignoreDuplicate) {\n            if (!overwritable.isDevMode()) {\n                throw newRxError('DB9', {\n                    database: name\n                });\n            }\n        } else {\n            // check if combination already used\n            throwIfDatabaseNameUsed(name, storage);\n        }\n\n        USED_DATABASE_NAMES.add(databaseNameKey);\n\n        const databaseInstanceToken = randomToken(10);\n        const storageInstance = await createRxDatabaseStorageInstance<\n            Internals,\n            InstanceCreationOptions\n        >(\n            databaseInstanceToken,\n            storage,\n            name,\n            instanceCreationOptions as any,\n            multiInstance,\n            password\n        );\n        const rxDatabase = new RxDatabaseBase(\n            name,\n            databaseInstanceToken,\n            storage,\n            instanceCreationOptions,\n            password,\n            multiInstance,\n            eventReduce,\n            options,\n            storageInstance,\n            hashFunction,\n            cleanupPolicy,\n            allowSlowCount,\n            reactivity,\n            onInstanceClosed\n        ) as RxDatabase<Collections>;\n\n        await runAsyncPluginHooks('createRxDatabase', {\n            database: rxDatabase,\n            creator: {\n                storage,\n                instanceCreationOptions,\n                name,\n                password,\n                multiInstance,\n                eventReduce,\n                ignoreDuplicate,\n                options,\n                localDocuments\n            }\n        });\n\n        return rxDatabase;\n    })()\n        .then((rxDatabase) => {\n            instancePromiseWithResolvers.resolve(rxDatabase);\n        })\n        .catch((err) => {\n            instancePromiseWithResolvers.reject(err);\n            onInstanceClosed();\n        });\n\n    return instancePromiseWithResolvers.promise;\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport async function removeRxDatabase(\n    databaseName: string,\n    storage: RxStorage<any, any>,\n    multiInstance: boolean = true,\n    password?: string\n): Promise<string[]> {\n    const databaseInstanceToken = randomToken(10);\n    const dbInternalsStorageInstance = await createRxDatabaseStorageInstance(\n        databaseInstanceToken,\n        storage,\n        databaseName,\n        {},\n        multiInstance,\n        password\n    );\n    const collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);\n    const collectionNames = new Set<string>();\n    collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n    const removedCollectionNames: string[] = Array.from(collectionNames);\n\n    await Promise.all(\n        removedCollectionNames.map(collectionName => removeCollectionStorages(\n            storage,\n            dbInternalsStorageInstance,\n            databaseInstanceToken,\n            databaseName,\n            collectionName,\n            multiInstance,\n            password\n        ))\n    );\n\n    await runAsyncPluginHooks('postRemoveRxDatabase', {\n        databaseName,\n        storage\n    });\n\n    await dbInternalsStorageInstance.remove();\n    return removedCollectionNames;\n}\n\nexport function isRxDatabase(obj: any) {\n    return obj instanceof RxDatabaseBase;\n}\n\nexport function dbCount(): number {\n    return DB_COUNT;\n}\n\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport async function isRxDatabaseFirstTimeInstantiated(\n    database: RxDatabase\n): Promise<boolean> {\n    const tokenDoc = await database.storageTokenDocument;\n    return tokenDoc.data.instanceToken === database.token;\n}\n\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nexport async function ensureNoStartupErrors(\n    rxDatabase: RxDatabaseBase<any, any, any, any>\n) {\n    await rxDatabase.storageToken;\n    if (rxDatabase.startupErrors[0]) {\n        throw rxDatabase.startupErrors[0];\n    }\n}\n"],
  "mappings": "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",
  "names": ["RxSchema", "jsonSchema", "hashFunction", "indexes", "getIndexes", "primaryPath", "getPrimaryFieldOfPrimaryKey", "primaryKey", "properties", "maxLength", "newRxError", "schema", "finalFields", "getFinalFields", "_proto", "prototype", "validateChange", "dataBefore", "dataAfter", "forEach", "fieldName", "deepEqual", "getDocumentPrototype", "proto", "pathProperties", "getSchemaByObjectPath", "Object", "keys", "key", "fullPath", "__defineGetter__", "get", "undefined", "ret", "defineProperty", "get$", "enumerable", "configurable", "get$$", "populate", "overwriteGetterForCaching", "getPrimaryOfDocumentData", "documentData", "getComposedPrimaryKeyOfDocumentData", "_createClass", "version", "values", "entries", "filter", "v", "hasOwnProperty", "call", "k", "default", "JSON", "stringify", "map", "index", "isMaybeReadonlyArray", "getPreviousVersions", "c", "Array", "fill", "createRxSchema", "runPreCreateHooks", "runPluginHooks", "useJsonSchema", "fillWithDefaultSettings", "normalizeRxJsonSchema", "overwritable", "deepFreezeWhenDevMode", "isRxSchema", "obj", "toTypedRxJsonSchema", "getDocumentDataOfRxChangeEvent", "rxChangeEvent", "documentData", "previousDocumentData", "rxChangeEventToEventReduceChangeEvent", "operation", "id", "documentId", "doc", "previous", "overwritable", "deepFreezeWhenDevMode", "flattenEvents", "input", "output", "Array", "isArray", "forEach", "inputItem", "add", "appendToArray", "events", "ev", "push", "usedIds", "Set", "nonDuplicate", "getEventId", "_rev", "join", "eventId", "has", "EVENT_BULK_CACHE", "Map", "rxChangeEventBulkToRxChangeEvents", "eventBulk", "getFromMapOrCreate", "length", "rawEvents", "collectionName", "isLocal", "index", "event", "IncrementalWriteQueue", "storageInstance", "primaryPath", "preWrite", "postWrite", "queueByDocId", "Map", "isRunning", "_proto", "prototype", "addWrite", "lastKnownDocumentState", "modifier", "docId", "ar", "getFromMapOrCreate", "ret", "Promise", "resolve", "reject", "item", "ensureNotFalsy", "push", "triggerRun", "size", "writeRows", "itemsById", "all", "Array", "from", "entries", "map", "_docId", "items", "oldData", "findNewestOfDocumentStates", "i", "newData", "clone", "err", "forEach", "previous", "document", "writeResult", "length", "bulkWrite", "error", "getWrittenDocumentsFromBulkWriteResponse", "result", "getFromMapOrThrow", "documentId", "isConflict", "isBulkWriteConflictError", "reverse", "documentInDb", "unshift", "rxError", "rxStorageWriteErrorToRxError", "modifierFromPublicToInternal", "publicModifier", "docData", "withoutMeta", "stripMetaDataFromDocument", "_deleted", "modified", "reattachedMeta", "Object", "assign", "_meta", "_attachments", "_rev", "docs", "newest", "newestRevisionHeight", "getHeightOfRevision", "doc", "height", "basePrototype", "primaryPath", "_this", "isInstanceOfRxDocument", "undefined", "collection", "schema", "primary", "_data", "revision", "_rev", "deleted$", "$", "pipe", "map", "d", "_deleted", "deleted$$", "reactivity", "database", "getReactivityFactory", "fromObservable", "getLatest", "deleted", "latestDocData", "_docCache", "getLatestDocumentData", "getCachedRxDocument", "id", "eventBulks$", "filter", "bulk", "isLocal", "events", "find", "ev", "documentId", "event", "changeEvent", "getDocumentDataOfRxChangeEvent", "ensureNotFalsy", "startWith", "distinctUntilChanged", "prev", "curr", "docData", "shareReplay", "RXJS_SHARE_REPLAY_DEFAULTS", "$$", "get$", "path", "overwritable", "isDevMode", "includes", "newRxError", "finalFields", "schemaObj", "getSchemaByObjectPath", "jsonSchema", "data", "getProperty", "get$$", "obs", "get", "populate", "value", "PROMISE_RESOLVE_NULL", "ref", "refCollection", "collections", "type", "findByIds", "exec", "then", "res", "valuesIterator", "values", "Array", "from", "findOne", "objPath", "getDocumentProperty", "toJSON", "withMetaFields", "flatClone", "_attachments", "_meta", "deepFreezeWhenDevMode", "toMutableJSON", "clone", "update", "_updateObj", "pluginMissing", "incrementalUpdate", "updateCRDT", "putAttachment", "putAttachmentBase64", "getAttachment", "allAttachments", "allAttachments$", "modify", "mutationFunction", "_context", "oldData", "newData", "modifierFromPublicToInternal", "_saveData", "incrementalModify", "incrementalWriteQueue", "addWrite", "result", "patch", "Object", "entries", "forEach", "k", "v", "incrementalPatch", "document", "beforeDocumentUpdateWrite", "writeRows", "previous", "writeResult", "storageInstance", "bulkWrite", "isError", "error", "throwIfIsStorageWriteError", "_runHooks", "getWrittenDocumentsFromBulkWriteResponse", "remove", "Promise", "reject", "removeResult", "bulkRemove", "length", "success", "incrementalRemove", "newDoc", "close", "createRxDocumentConstructor", "proto", "constructor", "RxDocumentConstructor", "_propertyCache", "Map", "prototype", "createWithConstructor", "jsonData", "doc", "runPluginHooks", "isRxDocument", "obj", "assign", "validateChange", "getFromMapOrCreate", "valueObj", "isArray", "proxy", "Proxy", "target", "property", "lastChar", "charAt", "endsWith", "key", "slice", "trimDots", "plainValue", "QueryCache", "_map", "Map", "_proto", "prototype", "getByQuery", "rxQuery", "stringRep", "toString", "ret", "getFromMapOrCreate", "createQueryCache", "uncacheRxQuery", "queryCache", "uncached", "delete", "countRxQuerySubscribers", "refCount$", "observers", "length", "DEFAULT_TRY_TO_KEEP_MAX", "DEFAULT_UNEXECUTED_LIFETIME", "defaultCacheReplacementPolicyMonad", "tryToKeepMax", "unExecutedLifetime", "_collection", "size", "minUnExecutedLifetime", "now", "maybeUncache", "queriesInCache", "Array", "from", "values", "_lastEnsureEqual", "_creationTime", "push", "mustUncache", "sortedByLastUsage", "sort", "a", "b", "toRemove", "slice", "forEach", "defaultCacheReplacementPolicy", "COLLECTIONS_WITH_RUNNING_CLEANUP", "WeakSet", "triggerCacheReplacement", "rxCollection", "has", "add", "nextTick", "then", "requestIdlePromise", "closed", "cacheReplacementPolicy", "_queryCache", "DocumentCache", "primaryPath", "changes$", "documentCreator", "cacheItemByDocId", "Map", "tasks", "Set", "registry", "FinalizationRegistry", "docMeta", "docId", "cacheItem", "get", "delete", "revisionHeight", "lwt", "size", "undefined", "subscribe", "events", "add", "index", "length", "event", "documentId", "documentData", "previousDocumentData", "requestIdlePromiseNoQueue", "then", "processTasks", "_proto", "prototype", "Array", "from", "forEach", "task", "clear", "getLatestDocumentData", "getFromMapOrThrow", "getLatestDocumentDataIfExists", "_createClass", "key", "fn", "getCachedRxDocumentMonad", "overwriteGetterForCaching", "doc", "docCache", "deepFreezeWhenDevMode", "overwritable", "docsData", "ret", "registryTasks", "docData", "getHeightOfRevision", "_rev", "byRev", "cachedRxDocumentWeakRef", "set", "_meta", "cachedRxDocument", "deref", "createWeakRefWithFallback", "push", "register", "primary", "revision", "_data", "mapDocumentsDataToCacheDocs", "getCachedRxDocuments", "HAS_WEAK_REF", "WeakRef", "createWeakRef", "createWeakRefFallback", "obj", "RxQuerySingleResult", "query", "docsDataFromStorageInstance", "count", "time", "now", "documents", "mapDocumentsDataToCacheDocs", "collection", "_docCache", "_proto", "prototype", "getValue", "throwIfMissing", "op", "doc", "length", "newRxError", "name", "mangoQuery", "docsMap", "slice", "_createClass", "key", "get", "overwriteGetterForCaching", "map", "d", "_data", "Map", "forEach", "set", "primary", "i", "getProperty", "getProperty", "simpleBdd", "getSortFieldsOfQuery", "primaryKey", "query", "sort", "length", "map", "part", "Object", "keys", "RXQUERY_QUERY_PARAMS_CACHE", "WeakMap", "getQueryParams", "rxQuery", "getFromMapOrCreate", "collection", "normalizedMangoQuery", "normalizeMangoQuery", "storageInstance", "schema", "clone", "mangoQuery", "primaryPath", "sortComparator", "getSortComparator", "jsonSchema", "useSortComparator", "docA", "docB", "sortComparatorData", "queryMatcher", "getQueryMatcher", "useQueryMatcher", "doc", "queryMatcherData", "ret", "skip", "limit", "sortFields", "calculateNewResults", "rxChangeEvents", "database", "eventReduce", "runFullQueryAgain", "queryParams", "previousResults", "ensureNotFalsy", "_result", "docsData", "slice", "previousResultsMap", "docsDataMap", "changed", "eventReduceEvents", "index", "cE", "eventReduceEvent", "rxChangeEventToEventReduceChangeEvent", "push", "foundNonOptimizeable", "find", "stateResolveFunctionInput", "changeEvent", "keyDocumentMap", "actionName", "calculateActionName", "runAction", "newResults", "_queryCount", "newQueryID", "RxQueryBase", "op", "mangoQuery", "collection", "other", "id", "_execOverDatabaseCount", "_creationTime", "now", "_lastEnsureEqual", "uncached", "refCount$", "BehaviorSubject", "_result", "_latestChangeEvent", "_ensureEqualQueue", "PROMISE_RESOLVE_FALSE", "_getDefaultQuery", "isFindOneByIdQuery", "schema", "primaryPath", "_proto", "prototype", "_setResultData", "newResultData", "newRxError", "database", "name", "RxQuerySingleResult", "Map", "Array", "from", "values", "newQueryResult", "length", "_execOverDatabase", "preparedQuery", "getPreparedQuery", "result", "storageInstance", "count", "mode", "allowSlowCount", "queryObj", "ids", "ensureNotFalsy", "selector", "$in", "ret", "mustBeQueried", "forEach", "docData", "_docCache", "getLatestDocumentDataIfExists", "_deleted", "doc", "getCachedRxDocument", "set", "push", "docs", "findDocumentsById", "primary", "docsPromise", "queryCollection", "then", "exec", "throwIfMissing", "query", "_ensureEqual", "useResult", "getValue", "toString", "stringObj", "sortObject", "normalizeMangoQuery", "jsonSchema", "value", "JSON", "stringify", "hookInput", "rxQuery", "$eq", "index", "unshift", "runPluginHooks", "prepareQuery", "doesDocumentDataMatch", "queryMatcher", "remove", "isArray", "bulkRemove", "error", "rxStorageWriteErrorToRxError", "success", "incrementalRemove", "runQueryUpdateFunction", "asRxQuery", "update", "_updateObj", "pluginMissing", "patch", "incrementalPatch", "modify", "mutationFunction", "incrementalModify", "where", "_queryObj", "sort", "_params", "skip", "_amount", "limit", "_createClass", "key", "get", "_$", "results$", "eventBulks$", "pipe", "filter", "bulk", "isLocal", "startWith", "mergeMap", "map", "shareReplay", "RXJS_SHARE_REPLAY_DEFAULTS", "distinctUntilChanged", "prev", "curr", "time", "merge", "reactivity", "getReactivityFactory", "fromObservable", "$", "undefined", "normalizedQuery", "overwriteGetterForCaching", "getQueryMatcher", "tunnelQueryCache", "_queryCache", "getByQuery", "createRxQuery", "triggerCacheReplacement", "_isResultsInSync", "currentLatestEventNumber", "_changeEventBuffer", "getCounter", "awaitBeforeReads", "size", "Promise", "all", "fn", "closed", "__ensureEqual", "mustReExec", "missedChangeEvents", "getFrom", "runChangeEvents", "reduceByLastOfDoc", "previousCount", "newCount", "cE", "didMatchBefore", "previousDocumentData", "doesMatchNow", "documentData", "eventReduceResult", "calculateNewResults", "runFullQueryAgain", "changed", "newResults", "areRxDocumentArraysEqual", "docsData", "resolve", "docIds", "docId", "docsFromStorage", "appendToArray", "fromStorageList", "queryResult", "documents", "Object", "keys", "find", "r", "isRxQuery", "obj", "INTERNAL_CONTEXT_COLLECTION", "INTERNAL_CONTEXT_STORAGE_TOKEN", "INTERNAL_CONTEXT_MIGRATION_STATUS", "INTERNAL_CONTEXT_PIPELINE_CHECKPOINT", "INTERNAL_STORE_SCHEMA_TITLE", "INTERNAL_STORE_SCHEMA", "fillWithDefaultSettings", "version", "title", "primaryKey", "key", "fields", "separator", "type", "properties", "id", "maxLength", "context", "enum", "data", "additionalProperties", "indexes", "required", "sharding", "shards", "mode", "getPrimaryKeyOfInternalDocument", "getComposedPrimaryKeyOfDocumentData", "getAllCollectionDocuments", "storageInstance", "getAllQueryPrepared", "prepareQuery", "schema", "selector", "_deleted", "$eq", "sort", "skip", "queryResult", "query", "allDocs", "documents", "STORAGE_TOKEN_DOCUMENT_KEY", "STORAGE_TOKEN_DOCUMENT_ID", "ensureStorageTokenDocumentExists", "rxDatabase", "storageToken", "randomToken", "passwordHash", "password", "hashFunction", "JSON", "stringify", "undefined", "docData", "rxdbVersion", "token", "instanceToken", "_meta", "getDefaultRxDocumentMeta", "_rev", "getDefaultRevision", "_attachments", "writeRows", "document", "writeResult", "internalStore", "bulkWrite", "error", "getWrittenDocumentsFromBulkWriteResponse", "ensureNotFalsy", "isError", "isBulkWriteConflictError", "conflictError", "isDatabaseStateVersionCompatibleWithDatabaseCode", "documentInDb", "newRxError", "args", "database", "name", "databaseStateVersion", "codeVersion", "existingPasswordHash", "storageTokenDocInDb", "stateMajor", "split", "codeMajor", "addConnectedStorageToCollection", "collection", "storageCollectionName", "collectionNameWithVersion", "_collectionNamePrimary", "jsonSchema", "collectionDocId", "collectionDoc", "getSingleDocument", "saveData", "clone", "alreadyThere", "connectedStorages", "find", "row", "collectionName", "push", "writeSingle", "previous", "err", "removeConnectedStorageFromCollection", "isThere", "filter", "item", "fillObjectDataBeforeInsert", "schema", "data", "flatClone", "fillObjectWithDefaults", "jsonSchema", "primaryKey", "fillPrimaryKey", "primaryPath", "_meta", "getDefaultRxDocumentMeta", "Object", "prototype", "hasOwnProperty", "call", "_deleted", "_attachments", "_rev", "getDefaultRevision", "createRxCollectionStorageInstance", "rxDatabase", "storageInstanceCreationParams", "multiInstance", "storageInstance", "storage", "createStorageInstance", "removeCollectionStorages", "databaseInternalStorage", "databaseInstanceToken", "databaseName", "collectionName", "password", "hashFunction", "allCollectionMetaDocs", "getAllCollectionDocuments", "relevantCollectionMetaDocs", "filter", "metaDoc", "name", "removeStorages", "forEach", "push", "isCollection", "connectedStorages", "row", "alreadyAdded", "Set", "key", "version", "has", "add", "Promise", "all", "map", "options", "devMode", "overwritable", "isDevMode", "remove", "runAsyncPluginHooks", "writeRows", "doc", "writeDoc", "flatCloneDocWithMeta", "lwt", "now", "createRevision", "previous", "document", "bulkWrite", "ensureRxCollectionIsNotClosed", "collection", "closed", "newRxError", "constructorForCollection", "WeakMap", "getDocumentPrototype", "rxCollection", "schemaProto", "schema", "ormProto", "getDocumentOrmPrototype", "baseProto", "basePrototype", "proto", "forEach", "obj", "props", "Object", "getOwnPropertyNames", "key", "desc", "getOwnPropertyDescriptor", "enumerable", "startsWith", "endsWith", "value", "defineProperty", "get", "bind", "configurable", "writable", "getRxDocumentConstructor", "getFromMapOrCreate", "createRxDocumentConstructor", "createNewRxDocument", "documentConstructor", "docData", "doc", "createRxDocumentWithConstructor", "overwritable", "deepFreezeWhenDevMode", "_runHooksSync", "runPluginHooks", "entries", "methods", "k", "v", "defaultConflictHandler", "isEqual", "a", "b", "_ctx", "addAttachmentsIfNotExists", "ret", "deepEqual", "stripAttachmentsDataFromDocument", "resolve", "i", "realMasterState", "d", "_attachments", "flatClone", "ChangeEventBuffer", "collection", "subs", "counter", "eventCounterMap", "WeakMap", "buffer", "limit", "tasks", "Set", "push", "eventBulks$", "pipe", "filter", "bulk", "isLocal", "subscribe", "eventBulk", "add", "_handleChangeEvents", "events", "size", "requestIdlePromiseNoQueue", "then", "processTasks", "_proto", "prototype", "Array", "from", "forEach", "task", "clear", "counterBefore", "length", "slice", "appendToArray", "counterBase", "index", "event", "set", "getCounter", "getBuffer", "getArrayIndexByPointer", "pointer", "oldestEvent", "oldestCounter", "get", "rest", "getFrom", "ret", "currentIndex", "nextEvent", "runFrom", "fn", "Error", "cE", "reduceByLastOfDoc", "changeEvents", "close", "sub", "unsubscribe", "createChangeEventBuffer", "HOOKS_WHEN", "HOOKS_KEYS", "hooksApplied", "OPEN_COLLECTIONS", "Set", "RxCollectionBase", "database", "name", "schema", "internalStorageInstance", "instanceCreationOptions", "migrationStrategies", "methods", "attachments", "options", "cacheReplacementPolicy", "defaultCacheReplacementPolicy", "statics", "conflictHandler", "defaultConflictHandler", "storageInstance", "timeouts", "incrementalWriteQueue", "awaitBeforeReads", "_incrementalUpsertQueues", "Map", "synced", "hooks", "_subs", "_docCache", "_queryCache", "createQueryCache", "$", "checkpoint$", "_changeEventBuffer", "eventBulks$", "onClose", "closed", "onRemove", "_applyHookFunctions", "asRxCollection", "pipe", "filter", "changeEventBulk", "collectionName", "add", "_proto", "prototype", "prepare", "hasPremiumFlag", "count", "size", "NON_PREMIUM_COLLECTION_LIMIT", "promiseWait", "newRxError", "collection", "args", "existing", "Array", "from", "values", "map", "c", "db", "getWrappedStorageInstance", "jsonSchema", "IncrementalWriteQueue", "primaryPath", "newData", "oldData", "beforeDocumentUpdateWrite", "result", "_runHooks", "mergeMap", "rxChangeEventBulkToRxChangeEvents", "checkpoint", "createChangeEventBuffer", "documentConstructor", "DocumentCache", "bulk", "isLocal", "events", "docData", "getRxDocumentConstructor", "createNewRxDocument", "listenToRemoveSub", "internalStore", "changeStream", "key", "version", "found", "find", "event", "documentData", "context", "operation", "subscribe", "close", "Promise", "all", "fn", "push", "databaseStorageToken", "storageToken", "subDocs", "eventBulk", "id", "internal", "databaseToken", "token", "$emit", "PROMISE_RESOLVE_VOID", "cleanup", "_minimumDeletedTime", "ensureRxCollectionIsNotClosed", "pluginMissing", "migrationNeeded", "getMigrationState", "startMigration", "batchSize", "migratePromise", "insert", "json", "writeResult", "bulkInsert", "isError", "error", "throwIfIsStorageWriteError", "insertResult", "ensureNotFalsy", "success", "insertIfNotExists", "length", "status", "conflictDocData", "documentInDb", "mapDocumentsDataToCacheDocs", "docsData", "ids", "insertRows", "hasHooks", "useDocData", "fillObjectDataBeforeInsert", "then", "document", "index", "documents", "results", "bulkWrite", "rxDocuments", "ret", "getWrittenDocumentsFromBulkWriteResponse", "docsMap", "forEach", "row", "doc", "set", "get", "primary", "bulkRemove", "idsOrDocs", "rxDocumentMap", "findByIds", "exec", "d", "rxDocument", "data", "toMutableJSON", "removeDocs", "writeDoc", "flatClone", "_deleted", "previous", "deletedRxDocuments", "successIds", "getCachedRxDocument", "bulkUpsert", "insertData", "useJsonByDocId", "useJson", "slice", "err", "documentId", "writeData", "getFromMapOrThrow", "docDataInDb", "getCachedRxDocuments", "newDoc", "incrementalModify", "upsert", "bulkResult", "incrementalUpsert", "queue", "_incrementalUpsertEnsureRxDocumentExists", "wasInserted", "inserted", "_incrementalUpsertUpdate", "queryObj", "runPluginHooks", "op", "_getDefaultQuery", "query", "createRxQuery", "findOne", "selector", "limit", "mangoQuery", "$in", "exportJSON", "importJSON", "_exportedJSON", "insertCRDT", "_updateObj", "addPipeline", "_options", "addHook", "when", "fun", "parallel", "newRxTypeError", "includes", "boundFun", "bind", "runName", "series", "getHooks", "instance", "tasks", "hook", "promiseSeries", "_runHooksSync", "time", "res", "timeout", "setTimeout", "delete", "PROMISE_RESOLVE_FALSE", "clearTimeout", "requestIdlePromise", "sub", "unsubscribe", "collections", "runAsyncPluginHooks", "remove", "removeCollectionStorages", "storage", "multiInstance", "password", "hashFunction", "_createClass", "cE", "colProto", "Object", "getPrototypeOf", "fnName", "ucfirst", "_innerDoc", "rxCollection", "docDataFromCache", "getLatestDocumentDataIfExists", "resolve", "createRxCollection", "autoMigrate", "localDocuments", "storageInstanceCreationParams", "databaseInstanceToken", "databaseName", "devMode", "overwritable", "isDevMode", "createRxCollectionStorageInstance", "entries", "funName", "defineProperty", "creator", "isRxCollection", "obj", "IdleQueue", "requestIdlePromise", "resolveFromOutside", "USED_DATABASE_NAMES", "Set", "DATABASE_UNCLOSED_INSTANCE_PROMISE_MAP", "Map", "DB_COUNT", "RxDatabaseBase", "name", "token", "storage", "instanceCreationOptions", "password", "multiInstance", "eventReduce", "options", "internalStore", "hashFunction", "cleanupPolicy", "allowSlowCount", "reactivity", "onClosed", "idleQueue", "IdleQueue", "rxdbVersion", "RXDB_VERSION", "storageInstances", "_subs", "startupErrors", "onClose", "closed", "collections", "states", "eventBulks$", "Subject", "closePromise", "observable$", "pipe", "mergeMap", "changeEventBulk", "rxChangeEventBulkToRxChangeEvents", "storageToken", "PROMISE_RESOLVE_FALSE", "storageTokenDocument", "emittedEventBulkIds", "ObliviousSet", "getWrappedStorageInstance", "asRxDatabase", "INTERNAL_STORE_SCHEMA", "ensureStorageTokenDocumentExists", "catch", "err", "push", "then", "doc", "data", "_proto", "prototype", "getReactivityFactory", "newRxError", "database", "$emit", "has", "id", "add", "next", "removeCollectionDoc", "schema", "getSingleDocument", "getPrimaryKeyOfInternalDocument", "_collectionNamePrimary", "INTERNAL_CONTEXT_COLLECTION", "writeDoc", "flatCloneDocWithMeta", "_deleted", "bulkWrite", "document", "previous", "addCollections", "collectionCreators", "jsonSchemas", "schemas", "bulkPutDocs", "useArgsByCollectionName", "Promise", "all", "Object", "entries", "map", "args", "collectionName", "rxJsonSchema", "createRxSchema", "collectionNameWithVersion", "collectionDocData", "key", "context", "schemaHash", "hash", "jsonSchema", "version", "connectedStorages", "_meta", "getDefaultRxDocumentMeta", "_rev", "getDefaultRevision", "_attachments", "useArgs", "assign", "hookData", "flatClone", "runPluginHooks", "conflictHandler", "putDocsResult", "ensureNoStartupErrors", "error", "status", "writeError", "docInDb", "ensureNotFalsy", "documentInDb", "collection", "previousSchemaHash", "previousSchema", "ret", "keys", "createRxCollection", "defineProperty", "get", "lockedRun", "fn", "wrapCall", "requestIdlePromise", "exportJSON", "_collections", "pluginMissing", "addState", "_name", "importJSON", "_exportedJSON", "backup", "_options", "leaderElector", "isLeader", "waitForLeadership", "migrationStates", "close", "promise", "resolve", "createPromiseWithResolvers", "resolveClosePromise", "result", "runAsyncPluginHooks", "complete", "sub", "unsubscribe", "col", "remove", "removeRxDatabase", "_createClass", "throwIfDatabaseNameUsed", "getDatabaseNameKey", "link", "reject", "res", "rej", "createRxDatabaseStorageInstance", "databaseInstanceToken", "databaseName", "createStorageInstance", "INTERNAL_STORAGE_NAME", "devMode", "overwritable", "isDevMode", "createRxDatabase", "ignoreDuplicate", "closeDuplicates", "localDocuments", "defaultHashSha256", "databaseNameKey", "databaseNameKeyUnclosedInstancesSet", "instancePromiseWithResolvers", "closeDuplicatesPromises", "Array", "from", "onInstanceClosed", "delete", "set", "unclosedInstancePromise", "instance", "randomToken", "storageInstance", "rxDatabase", "creator", "dbInternalsStorageInstance", "collectionDocs", "getAllCollectionDocuments", "collectionNames", "forEach", "removedCollectionNames", "removeCollectionStorages", "isRxDatabase", "obj", "dbCount", "isRxDatabaseFirstTimeInstantiated", "tokenDoc", "instanceToken"]
}
