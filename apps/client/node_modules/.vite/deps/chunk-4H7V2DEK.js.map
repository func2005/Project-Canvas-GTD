{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/query-planner.ts", "../../../../../node_modules/mingo/dist/esm/util.js", "../../../../../node_modules/mingo/dist/esm/core.js", "../../../../../node_modules/mingo/dist/esm/lazy.js", "../../../../../node_modules/mingo/dist/esm/operators/pipeline/limit.js", "../../../../../node_modules/mingo/dist/esm/operators/pipeline/project.js", "../../../../../node_modules/mingo/dist/esm/operators/pipeline/skip.js", "../../../../../node_modules/mingo/dist/esm/operators/pipeline/sort.js", "../../../../../node_modules/mingo/dist/esm/cursor.js", "../../../../../node_modules/mingo/dist/esm/query.js", "../../../../../node_modules/mingo/dist/esm/operators/pipeline/bucketAuto.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/date/_internal.js", "../../../../../node_modules/mingo/dist/esm/operators/pipeline/densify.js", "../../../../../node_modules/mingo/dist/esm/operators/window/_internal.js", "../../../../../node_modules/mingo/dist/esm/operators/_predicates.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/array/nin.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/bitwise/_internal.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/bitwise/bitAnd.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/bitwise/bitOr.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/bitwise/bitXor.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/boolean/index.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/boolean/and.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/boolean/not.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/boolean/or.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/index.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/cmp.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/eq.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/gt.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/gte.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/lt.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/lte.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/comparison/ne.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/date/dateFromString.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/_internal.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/acos.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/acosh.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/asin.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/asinh.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/atan.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/atanh.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/cos.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/cosh.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/degreesToRadians.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/radiansToDegrees.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/sin.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/sinh.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/trignometry/tan.js", "../../../../../node_modules/mingo/dist/esm/operators/expression/type/_internal.js", "../../../../../node_modules/mingo/dist/esm/operators/query/logical/and.js", "../../../../../node_modules/mingo/dist/esm/operators/query/logical/or.js", "../../../../../node_modules/mingo/dist/esm/operators/query/logical/nor.js", "../../../../../node_modules/mingo/dist/esm/operators/query/logical/not.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/eq.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/gt.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/gte.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/in.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/lt.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/lte.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/ne.js", "../../../../../node_modules/mingo/dist/esm/operators/query/comparison/nin.js", "../../../../../node_modules/mingo/dist/esm/operators/query/evaluation/expr.js", "../../../../../node_modules/mingo/dist/esm/operators/query/evaluation/jsonSchema.js", "../../../../../node_modules/mingo/dist/esm/operators/query/evaluation/mod.js", "../../../../../node_modules/mingo/dist/esm/operators/query/evaluation/regex.js", "../../../../../node_modules/mingo/dist/esm/operators/query/evaluation/where.js", "../../../../../node_modules/mingo/dist/esm/operators/query/array/all.js", "../../../../../node_modules/mingo/dist/esm/operators/query/array/elemMatch.js", "../../../../../node_modules/mingo/dist/esm/operators/query/array/size.js", "../../../../../node_modules/mingo/dist/esm/operators/query/element/exists.js", "../../../../../node_modules/mingo/dist/esm/operators/query/element/type.js", "../../../../../node_modules/rxdb/src/rx-query-mingo.ts", "../../../../../node_modules/rxdb/src/rx-query-helper.ts"],
  "sourcesContent": ["import { countUntilNotMatching } from './plugins/utils/index.ts';\nimport { newRxError } from './rx-error.ts';\nimport { getSchemaByObjectPath } from './rx-schema-helper.ts';\nimport type {\n    FilledMangoQuery,\n    MangoQuerySelector,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQueryPlan,\n    RxQueryPlanKey,\n    RxQueryPlanerOpts\n} from './types/index.d.ts';\n\nexport const INDEX_MAX = String.fromCharCode(65535);\n\n/**\n * Do not use -Infinity here because it would be\n * transformed to null on JSON.stringify() which can break things\n * when the query plan is send to the storage as json.\n * @link https://stackoverflow.com/a/16644751\n * Notice that for IndexedDB IDBKeyRange we have\n * to transform the value back to -Infinity\n * before we can use it in IDBKeyRange.bound.\n */\nexport const INDEX_MIN = Number.MIN_SAFE_INTEGER;\n\n/**\n * Returns the query plan which contains\n * information about how to run the query\n * and which indexes to use.\n *\n * This is used in some storage like Memory, dexie.js and IndexedDB.\n */\nexport function getQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): RxQueryPlan {\n    const selector = query.selector;\n    let indexes: string[][] = schema.indexes ? schema.indexes.slice(0) as any : [];\n    if (query.index) {\n        indexes = [query.index];\n    }\n\n    /**\n     * Most storages do not support descending indexes\n     * so having a 'desc' in the sorting, means we always have to re-sort the results.\n     */\n    const hasDescSorting = !!query.sort.find(sortField => Object.values(sortField)[0] === 'desc');\n\n    /**\n     * Some fields can be part of the selector while not being relevant for sorting\n     * because their selector operators specify that in all cases all matching docs\n     * would have the same value.\n     * For example the boolean field _deleted.\n     * TODO similar thing could be done for enums.\n     */\n    const sortIrrelevevantFields = new Set();\n    Object.keys(selector).forEach(fieldName => {\n        const schemaPart = getSchemaByObjectPath(schema, fieldName);\n        if (\n            schemaPart &&\n            schemaPart.type === 'boolean' &&\n            Object.prototype.hasOwnProperty.call((selector as any)[fieldName], '$eq')\n        ) {\n            sortIrrelevevantFields.add(fieldName);\n        }\n    });\n\n\n    const optimalSortIndex = query.sort.map(sortField => Object.keys(sortField)[0]);\n    const optimalSortIndexCompareString = optimalSortIndex\n        .filter(f => !sortIrrelevevantFields.has(f))\n        .join(',');\n\n    let currentBestQuality = -1;\n    let currentBestQueryPlan: RxQueryPlan | undefined;\n\n    /**\n     * Calculate one query plan for each index\n     * and then test which of the plans is best.\n     */\n    indexes.forEach((index) => {\n        let inclusiveEnd = true;\n        let inclusiveStart = true;\n        const opts: RxQueryPlanerOpts[] = index.map(indexField => {\n            const matcher = (selector as any)[indexField];\n            const operators = matcher ? Object.keys(matcher) : [];\n\n            let matcherOpts: RxQueryPlanerOpts = {} as any;\n            if (\n                !matcher ||\n                !operators.length\n            ) {\n                const startKey = inclusiveStart ? INDEX_MIN : INDEX_MAX;\n                matcherOpts = {\n                    startKey,\n                    endKey: inclusiveEnd ? INDEX_MAX : INDEX_MIN,\n                    inclusiveStart: true,\n                    inclusiveEnd: true\n                };\n            } else {\n                operators.forEach(operator => {\n                    if (LOGICAL_OPERATORS.has(operator)) {\n                        const operatorValue = matcher[operator];\n                        const partialOpts = getMatcherQueryOpts(operator, operatorValue);\n                        matcherOpts = Object.assign(matcherOpts, partialOpts);\n                    }\n                });\n            }\n\n            // fill missing attributes\n            if (typeof matcherOpts.startKey === 'undefined') {\n                matcherOpts.startKey = INDEX_MIN;\n            }\n            if (typeof matcherOpts.endKey === 'undefined') {\n                matcherOpts.endKey = INDEX_MAX;\n            }\n            if (typeof matcherOpts.inclusiveStart === 'undefined') {\n                matcherOpts.inclusiveStart = true;\n            }\n            if (typeof matcherOpts.inclusiveEnd === 'undefined') {\n                matcherOpts.inclusiveEnd = true;\n            }\n\n            if (inclusiveStart && !matcherOpts.inclusiveStart) {\n                inclusiveStart = false;\n            }\n            if (inclusiveEnd && !matcherOpts.inclusiveEnd) {\n                inclusiveEnd = false;\n            }\n\n            return matcherOpts;\n        });\n\n\n        const startKeys = opts.map(opt => opt.startKey);\n        const endKeys = opts.map(opt => opt.endKey);\n        const queryPlan: RxQueryPlan = {\n            index,\n            startKeys,\n            endKeys,\n            inclusiveEnd,\n            inclusiveStart,\n            sortSatisfiedByIndex: !hasDescSorting && optimalSortIndexCompareString === index.filter(f => !sortIrrelevevantFields.has(f)).join(','),\n            selectorSatisfiedByIndex: isSelectorSatisfiedByIndex(index, query.selector, startKeys, endKeys)\n        };\n        const quality = rateQueryPlan(\n            schema,\n            query,\n            queryPlan\n        );\n        if (\n            (\n                quality >= currentBestQuality\n            ) ||\n            query.index\n        ) {\n            currentBestQuality = quality;\n            currentBestQueryPlan = queryPlan;\n        }\n    });\n\n    /**\n     * In all cases and index must be found\n     */\n    if (!currentBestQueryPlan) {\n        throw newRxError('SNH', {\n            query\n        });\n    }\n\n    return currentBestQueryPlan;\n}\n\nexport const LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte', '$lt', '$lte']);\nexport const LOWER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$gt', '$gte']);\nexport const UPPER_BOUND_LOGICAL_OPERATORS = new Set(['$eq', '$lt', '$lte']);\n\n\nexport function isSelectorSatisfiedByIndex(\n    index: string[],\n    selector: MangoQuerySelector<any>,\n    startKeys: RxQueryPlanKey[],\n    endKeys: RxQueryPlanKey[]\n): boolean {\n\n\n    /**\n     * Not satisfied if one or more operators are non-logical\n     * operators that can never be satisfied by an index.\n     */\n    const selectorEntries = Object.entries(selector);\n    const hasNonMatchingOperator = selectorEntries\n        .find(([fieldName, operation]) => {\n            if (!index.includes(fieldName)) {\n                return true;\n            }\n            const hasNonLogicOperator = Object.entries(operation as any)\n                .find(([op, _value]) => !LOGICAL_OPERATORS.has(op));\n            return hasNonLogicOperator;\n        });\n\n    if (hasNonMatchingOperator) {\n        return false;\n    }\n\n    /**\n     * Not satisfied if contains $and or $or operations.\n     */\n    if (selector.$and || selector.$or) {\n        return false;\n    }\n\n\n\n    // ensure all lower bound in index\n    const satisfieldLowerBound: string[] = [];\n    const lowerOperatorFieldNames = new Set<string>();\n    for (const [fieldName, operation] of Object.entries(selector)) {\n        if (!index.includes(fieldName)) {\n            return false;\n        }\n\n        // If more then one logic op on the same field, we have to selector-match.\n        const lowerLogicOps = Object.keys(operation as any).filter(key => LOWER_BOUND_LOGICAL_OPERATORS.has(key));\n        if (lowerLogicOps.length > 1) {\n            return false;\n        }\n\n        const hasLowerLogicOp = lowerLogicOps[0];\n        if (hasLowerLogicOp) {\n            lowerOperatorFieldNames.add(fieldName);\n        }\n        if (hasLowerLogicOp !== '$eq') {\n            if (satisfieldLowerBound.length > 0) {\n                return false;\n            } else {\n                satisfieldLowerBound.push(hasLowerLogicOp);\n            }\n        }\n    }\n\n    // ensure all upper bound in index\n    const satisfieldUpperBound: string[] = [];\n    const upperOperatorFieldNames = new Set<string>();\n    for (const [fieldName, operation] of Object.entries(selector)) {\n        if (!index.includes(fieldName)) {\n            return false;\n        }\n\n        // If more then one logic op on the same field, we have to selector-match.\n        const upperLogicOps = Object.keys(operation as any).filter(key => UPPER_BOUND_LOGICAL_OPERATORS.has(key));\n        if (upperLogicOps.length > 1) {\n            return false;\n        }\n\n        const hasUperLogicOp = upperLogicOps[0];\n        if (hasUperLogicOp) {\n            upperOperatorFieldNames.add(fieldName);\n        }\n        if (hasUperLogicOp !== '$eq') {\n            if (satisfieldUpperBound.length > 0) {\n                return false;\n            } else {\n                satisfieldUpperBound.push(hasUperLogicOp);\n            }\n        }\n    }\n\n\n    /**\n     * If the index contains a non-relevant field between\n     * the relevant fields, then the index is not satisfying.\n     */\n    let i = 0;\n    for (const fieldName of index) {\n        for (const set of [\n            lowerOperatorFieldNames,\n            upperOperatorFieldNames\n        ]) {\n            if (\n                !set.has(fieldName) &&\n                set.size > 0\n            ) {\n                return false;\n            }\n            set.delete(fieldName);\n        }\n\n        const startKey = startKeys[i];\n        const endKey = endKeys[i];\n\n        if (\n            startKey !== endKey && (\n                lowerOperatorFieldNames.size > 0 &&\n                upperOperatorFieldNames.size > 0\n            )\n        ) {\n            return false;\n        }\n\n        i++;\n    }\n\n    return true;\n}\n\nexport function getMatcherQueryOpts(\n    operator: string,\n    operatorValue: any\n): Partial<RxQueryPlanerOpts> {\n    switch (operator) {\n        case '$eq':\n            return {\n                startKey: operatorValue,\n                endKey: operatorValue,\n                inclusiveEnd: true,\n                inclusiveStart: true\n            };\n        case '$lte':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: true\n            };\n        case '$gte':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: true\n            };\n        case '$lt':\n            return {\n                endKey: operatorValue,\n                inclusiveEnd: false\n            };\n        case '$gt':\n            return {\n                startKey: operatorValue,\n                inclusiveStart: false\n            };\n        default:\n            throw new Error('SNH');\n    }\n}\n\n\n/**\n * Returns a number that determines the quality of the query plan.\n * Higher number means better query plan.\n */\nexport function rateQueryPlan<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>,\n    queryPlan: RxQueryPlan\n): number {\n    let quality: number = 0;\n    const addQuality = (value: number) => {\n        if (value > 0) {\n            quality = quality + value;\n        }\n    };\n\n    const pointsPerMatchingKey = 10;\n\n    const nonMinKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MIN && keyValue !== INDEX_MAX);\n    addQuality(nonMinKeyCount * pointsPerMatchingKey);\n\n    const nonMaxKeyCount = countUntilNotMatching(queryPlan.startKeys, keyValue => keyValue !== INDEX_MAX && keyValue !== INDEX_MIN);\n    addQuality(nonMaxKeyCount * pointsPerMatchingKey);\n\n    const equalKeyCount = countUntilNotMatching(queryPlan.startKeys, (keyValue, idx) => {\n        if (keyValue === queryPlan.endKeys[idx]) {\n            return true;\n        } else {\n            return false;\n        }\n    });\n    addQuality(equalKeyCount * pointsPerMatchingKey * 1.5);\n\n    const pointsIfNoReSortMustBeDone = queryPlan.sortSatisfiedByIndex ? 5 : 0;\n    addQuality(pointsIfNoReSortMustBeDone);\n\n    return quality;\n}\n", "class MingoError extends Error {\n}\nconst MISSING = Symbol(\"missing\");\nconst CYCLE_FOUND_ERROR = Object.freeze(\n  new Error(\"mingo: cycle detected while processing object/array\")\n);\nconst DEFAULT_HASH_FUNCTION = (value) => {\n  const s = stringify(value);\n  let hash = 0;\n  let i = s.length;\n  while (i) hash = (hash << 5) - hash ^ s.charCodeAt(--i);\n  return hash >>> 0;\n};\nconst isPrimitive = (v) => typeof v !== \"object\" && typeof v !== \"function\" || v === null;\nconst isScalar = (v) => isPrimitive(v) || isDate(v) || isRegExp(v);\nconst SORT_ORDER = {\n  undefined: 1,\n  null: 2,\n  number: 3,\n  string: 4,\n  symbol: 5,\n  object: 6,\n  array: 7,\n  arraybuffer: 8,\n  boolean: 9,\n  date: 10,\n  regexp: 11,\n  function: 12\n};\nconst compare = (a, b) => {\n  if (a === MISSING) a = void 0;\n  if (b === MISSING) b = void 0;\n  const [u, v] = [a, b].map((n) => SORT_ORDER[typeOf(n)] || 0);\n  if (u !== v) return u - v;\n  if (isEqual(a, b)) return 0;\n  if (a < b) return -1;\n  if (a > b) return 1;\n  return 0;\n};\nclass ValueMap extends Map {\n  // The hash function\n  #hashFn = DEFAULT_HASH_FUNCTION;\n  // maps the hashcode to key set\n  #keyMap = /* @__PURE__ */ new Map();\n  // returns a tuple of [<masterKey>, <hash>]. Expects an object key.\n  #unpack = (key) => {\n    const hash = this.#hashFn(key);\n    return [(this.#keyMap.get(hash) || []).find((k) => isEqual(k, key)), hash];\n  };\n  constructor() {\n    super();\n  }\n  /**\n   * Returns a new {@link ValueMap} object.\n   * @param fn An optional custom hash function\n   */\n  static init(fn) {\n    const m = new ValueMap();\n    if (fn) m.#hashFn = fn;\n    return m;\n  }\n  clear() {\n    super.clear();\n    this.#keyMap.clear();\n  }\n  /**\n   * @returns true if an element in the Map existed and has been removed, or false if the element does not exist.\n   */\n  delete(key) {\n    if (isPrimitive(key)) return super.delete(key);\n    const [masterKey, hash] = this.#unpack(key);\n    if (!super.delete(masterKey)) return false;\n    this.#keyMap.set(\n      hash,\n      this.#keyMap.get(hash).filter((k) => !isEqual(k, masterKey))\n    );\n    return true;\n  }\n  /**\n   * Returns a specified element from the Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map.\n   * @returns Returns the element associated with the specified key. If no element is associated with the specified key, undefined is returned.\n   */\n  get(key) {\n    if (isPrimitive(key)) return super.get(key);\n    const [masterKey, _] = this.#unpack(key);\n    return super.get(masterKey);\n  }\n  /**\n   * @returns boolean indicating whether an element with the specified key exists or not.\n   */\n  has(key) {\n    if (isPrimitive(key)) return super.has(key);\n    const [masterKey, _] = this.#unpack(key);\n    return super.has(masterKey);\n  }\n  /**\n   * Adds a new element with a specified key and value to the Map. If an element with the same key already exists, the element will be updated.\n   */\n  set(key, value) {\n    if (isPrimitive(key)) return super.set(key, value);\n    const [masterKey, hash] = this.#unpack(key);\n    if (super.has(masterKey)) {\n      super.set(masterKey, value);\n    } else {\n      super.set(key, value);\n      const keys = this.#keyMap.get(hash) || [];\n      keys.push(key);\n      this.#keyMap.set(hash, keys);\n    }\n    return this;\n  }\n  /**\n   * @returns the number of elements in the Map.\n   */\n  get size() {\n    return super.size;\n  }\n}\nfunction assert(condition, message) {\n  if (!condition) throw new MingoError(message);\n}\nconst STRING_REP = Object.keys(SORT_ORDER).reduce(\n  (memo, k) => {\n    memo[\"[object \" + k[0].toUpperCase() + k.substring(1) + \"]\"] = k;\n    return memo;\n  },\n  {}\n);\nfunction typeOf(v) {\n  const s = Object.prototype.toString.call(v);\n  return s === \"[object Object]\" ? v?.constructor?.name?.toLowerCase() || \"object\" : STRING_REP[s] || s.substring(8, s.length - 1).toLowerCase();\n}\nconst isBoolean = (v) => typeof v === \"boolean\";\nconst isString = (v) => typeof v === \"string\";\nconst isSymbol = (v) => typeof v === \"symbol\";\nconst isNumber = (v) => !isNaN(v) && typeof v === \"number\";\nconst isNotNaN = (v) => !(isNaN(v) && typeof v === \"number\");\nconst isArray = Array.isArray;\nfunction isObject(v) {\n  if (!v) return false;\n  const p = Object.getPrototypeOf(v);\n  return (p === Object.prototype || p === null) && typeOf(v) === \"object\";\n}\nconst isObjectLike = (v) => !isPrimitive(v);\nconst isDate = (v) => v instanceof Date;\nconst isRegExp = (v) => v instanceof RegExp;\nconst isFunction = (v) => typeof v === \"function\";\nconst isNil = (v) => v === null || v === void 0;\nconst truthy = (arg, strict = true) => !!arg || strict && arg === \"\";\nconst isEmpty = (x) => isNil(x) || isString(x) && !x || isArray(x) && x.length === 0 || isObject(x) && Object.keys(x).length === 0;\nconst ensureArray = (x) => isArray(x) ? x : [x];\nconst has = (obj, prop) => !!obj && Object.prototype.hasOwnProperty.call(obj, prop);\nconst isTypedArray = (v) => typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView(v);\nconst cloneDeep = (v, refs) => {\n  if (isNil(v) || isBoolean(v) || isNumber(v) || isString(v)) return v;\n  if (isDate(v)) return new Date(v);\n  if (isRegExp(v)) return new RegExp(v);\n  if (isTypedArray(v)) {\n    const ctor = v.constructor;\n    return new ctor(v);\n  }\n  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();\n  if (refs.has(v)) throw CYCLE_FOUND_ERROR;\n  refs.add(v);\n  try {\n    if (isArray(v)) {\n      const arr = new Array(v.length);\n      for (let i = 0; i < v.length; i++) arr[i] = cloneDeep(v[i], refs);\n      return arr;\n    }\n    if (isObject(v)) {\n      const obj = {};\n      for (const k of Object.keys(v)) obj[k] = cloneDeep(v[k], refs);\n      return obj;\n    }\n  } finally {\n    refs.delete(v);\n  }\n  return v;\n};\nconst isMissing = (v) => v === MISSING;\nfunction merge(target, input) {\n  if (isMissing(target) || isNil(target)) return input;\n  if (isMissing(input) || isNil(input)) return target;\n  if (isPrimitive(target) || isPrimitive(input)) return input;\n  if (isArray(target) && isArray(input)) {\n    assert(\n      target.length === input.length,\n      \"arrays must be of equal length to merge.\"\n    );\n  }\n  for (const k of Object.keys(input)) {\n    target[k] = merge(target[k], input[k]);\n  }\n  return target;\n}\nfunction intersection(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const vmaps = [ValueMap.init(hashFunction), ValueMap.init(hashFunction)];\n  if (input.length === 0) return [];\n  if (input.some((arr) => arr.length === 0)) return [];\n  if (input.length === 1) return [...input];\n  input[input.length - 1].forEach((v) => vmaps[0].set(v, true));\n  for (let i = input.length - 2; i > -1; i--) {\n    input[i].forEach((v) => {\n      if (vmaps[0].has(v)) vmaps[1].set(v, true);\n    });\n    if (vmaps[1].size === 0) return [];\n    vmaps.reverse();\n    vmaps[1].clear();\n  }\n  return Array.from(vmaps[0].keys());\n}\nfunction flatten(xs, depth = 1) {\n  const arr = new Array();\n  function flatten2(ys, n) {\n    for (let i = 0, len = ys.length; i < len; i++) {\n      if (isArray(ys[i]) && (n > 0 || n < 0)) {\n        flatten2(ys[i], Math.max(-1, n - 1));\n      } else {\n        arr.push(ys[i]);\n      }\n    }\n  }\n  flatten2(xs, depth);\n  return arr;\n}\nfunction getMembersOf(o) {\n  const props = {};\n  while (o) {\n    for (const k of Object.getOwnPropertyNames(o))\n      if (!(k in props)) props[k] = o[k];\n    o = Object.getPrototypeOf(o);\n  }\n  return props;\n}\nfunction hasCustomString(o) {\n  while (o) {\n    if (Object.getOwnPropertyNames(o).includes(\"toString\"))\n      return o[\"toString\"] !== Object.prototype.toString;\n    o = Object.getPrototypeOf(o);\n  }\n  return false;\n}\nfunction isEqual(a, b) {\n  if (a === b || Object.is(a, b)) return true;\n  if (a === null || b === null) return false;\n  if (typeof a !== typeof b) return false;\n  if (typeof a !== \"object\") return false;\n  if (a.constructor !== b.constructor) return false;\n  if (a instanceof Date) return +a === +b;\n  if (a instanceof RegExp) return a.toString() === b.toString();\n  const ctor = a.constructor;\n  if (ctor === Array || ctor === Object) {\n    const aKeys = Object.keys(a).sort();\n    const bKeys = Object.keys(b).sort();\n    if (aKeys.length !== bKeys.length) return false;\n    for (let i = 0, k = aKeys[i]; i < aKeys.length; k = aKeys[++i]) {\n      if (k !== bKeys[i] || !isEqual(a[k], b[k])) return false;\n    }\n    return true;\n  }\n  return hasCustomString(a) && a.toString() === b.toString();\n}\nfunction unique(input, hashFunction = DEFAULT_HASH_FUNCTION) {\n  const m = ValueMap.init(hashFunction);\n  input.forEach((v) => m.set(v, true));\n  return Array.from(m.keys());\n}\nconst stringify = (v, refs) => {\n  if (v === null) return \"null\";\n  if (v === void 0) return \"undefined\";\n  if (isString(v) || isNumber(v) || isBoolean(v)) return JSON.stringify(v);\n  if (isDate(v)) return v.toISOString();\n  if (isRegExp(v) || isSymbol(v) || isFunction(v))\n    return v.toString();\n  if (!(refs instanceof Set)) refs = /* @__PURE__ */ new Set();\n  if (refs.has(v)) throw CYCLE_FOUND_ERROR;\n  try {\n    refs.add(v);\n    if (isArray(v)) return \"[\" + v.map((s2) => stringify(s2, refs)).join(\",\") + \"]\";\n    if (isObject(v)) {\n      const keys = Object.keys(v).sort();\n      return \"{\" + keys.map((k) => `${k}:${stringify(v[k], refs)}`).join() + \"}\";\n    }\n    const s = hasCustomString(v) ? v.toString() : stringify(getMembersOf(v), refs);\n    return typeOf(v) + \"(\" + s + \")\";\n  } finally {\n    refs.delete(v);\n  }\n};\nfunction hashCode(value, hashFunction) {\n  if (isNil(value)) return null;\n  hashFunction = hashFunction || DEFAULT_HASH_FUNCTION;\n  return hashFunction(value);\n}\nfunction groupBy(collection, keyFn, hashFunction = DEFAULT_HASH_FUNCTION) {\n  if (collection.length < 1) return /* @__PURE__ */ new Map();\n  const lookup = /* @__PURE__ */ new Map();\n  const result = /* @__PURE__ */ new Map();\n  for (let i = 0; i < collection.length; i++) {\n    const obj = collection[i];\n    const key = keyFn(obj, i);\n    const hash = hashCode(key, hashFunction);\n    if (hash === null) {\n      if (result.has(null)) {\n        result.get(null).push(obj);\n      } else {\n        result.set(null, [obj]);\n      }\n    } else {\n      const existingKey = lookup.has(hash) ? lookup.get(hash).find((k) => isEqual(k, key)) : null;\n      if (isNil(existingKey)) {\n        result.set(key, [obj]);\n        if (lookup.has(hash)) {\n          lookup.get(hash).push(key);\n        } else {\n          lookup.set(hash, [key]);\n        }\n      } else {\n        result.get(existingKey).push(obj);\n      }\n    }\n  }\n  return result;\n}\nconst MAX_ARRAY_PUSH = 5e4;\nfunction into(target, ...rest) {\n  if (isArray(target)) {\n    for (const arr of rest) {\n      let i = Math.ceil(arr.length / MAX_ARRAY_PUSH);\n      let begin = 0;\n      while (i-- > 0) {\n        Array.prototype.push.apply(\n          target,\n          arr.slice(begin, begin + MAX_ARRAY_PUSH)\n        );\n        begin += MAX_ARRAY_PUSH;\n      }\n    }\n    return target;\n  } else {\n    return rest.filter(isObjectLike).reduce((acc, item) => {\n      Object.assign(acc, item);\n      return acc;\n    }, target);\n  }\n}\nfunction getValue(obj, key) {\n  return isObjectLike(obj) ? obj[key] : void 0;\n}\nfunction unwrap(arr, depth) {\n  if (depth < 1) return arr;\n  while (depth-- && arr.length === 1) arr = arr[0];\n  return arr;\n}\nfunction resolve(obj, selector, options) {\n  let depth = 0;\n  function resolve2(o, path) {\n    let value = o;\n    for (let i = 0; i < path.length; i++) {\n      const field = path[i];\n      const isText = /^\\d+$/.exec(field) === null;\n      if (isText && isArray(value)) {\n        if (i === 0 && depth > 0) break;\n        depth += 1;\n        const subpath = path.slice(i);\n        value = value.reduce((acc, item) => {\n          const v = resolve2(item, subpath);\n          if (v !== void 0) acc.push(v);\n          return acc;\n        }, []);\n        break;\n      } else {\n        value = getValue(value, field);\n      }\n      if (value === void 0) break;\n    }\n    return value;\n  }\n  const res = isScalar(obj) ? obj : resolve2(obj, selector.split(\".\"));\n  return isArray(res) && options?.unwrapArray ? unwrap(res, depth) : res;\n}\nfunction resolveGraph(obj, selector, options) {\n  const sep = selector.indexOf(\".\");\n  const key = sep == -1 ? selector : selector.substring(0, sep);\n  const next = selector.substring(sep + 1);\n  const hasNext = sep != -1;\n  if (isArray(obj)) {\n    const isIndex = /^\\d+$/.test(key);\n    const arr = isIndex && options?.preserveIndex ? [...obj] : [];\n    if (isIndex) {\n      const index = parseInt(key);\n      let value2 = getValue(obj, index);\n      if (hasNext) {\n        value2 = resolveGraph(value2, next, options);\n      }\n      if (options?.preserveIndex) {\n        arr[index] = value2;\n      } else {\n        arr.push(value2);\n      }\n    } else {\n      for (const item of obj) {\n        const value2 = resolveGraph(item, selector, options);\n        if (options?.preserveMissing) {\n          arr.push(value2 == void 0 ? MISSING : value2);\n        } else if (value2 != void 0 || options?.preserveIndex) {\n          arr.push(value2);\n        }\n      }\n    }\n    return arr;\n  }\n  const res = options?.preserveKeys ? { ...obj } : {};\n  let value = getValue(obj, key);\n  if (hasNext) {\n    value = resolveGraph(value, next, options);\n  }\n  if (value === void 0) return void 0;\n  res[key] = value;\n  return res;\n}\nfunction filterMissing(obj) {\n  if (isArray(obj)) {\n    for (let i = obj.length - 1; i >= 0; i--) {\n      if (obj[i] === MISSING) {\n        obj.splice(i, 1);\n      } else {\n        filterMissing(obj[i]);\n      }\n    }\n  } else if (isObject(obj)) {\n    for (const k in obj) {\n      if (has(obj, k)) {\n        filterMissing(obj[k]);\n      }\n    }\n  }\n}\nconst NUMBER_RE = /^\\d+$/;\nfunction walk(obj, selector, fn, options) {\n  const names = selector.split(\".\");\n  const key = names[0];\n  const next = names.slice(1).join(\".\");\n  if (names.length === 1) {\n    if (isObject(obj) || isArray(obj) && NUMBER_RE.test(key)) {\n      fn(obj, key);\n    }\n  } else {\n    if (options?.buildGraph && isNil(obj[key])) {\n      obj[key] = {};\n    }\n    const item = obj[key];\n    if (!item) return;\n    const isNextArrayIndex = !!(names.length > 1 && NUMBER_RE.test(names[1]));\n    if (isArray(item) && options?.descendArray && !isNextArrayIndex) {\n      item.forEach((e) => walk(e, next, fn, options));\n    } else {\n      walk(item, next, fn, options);\n    }\n  }\n}\nfunction setValue(obj, selector, value) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      item[key] = isFunction(value) ? value(item[key]) : value;\n    },\n    { buildGraph: true }\n  );\n}\nfunction removeValue(obj, selector, options) {\n  walk(\n    obj,\n    selector,\n    (item, key) => {\n      if (isArray(item)) {\n        if (/^\\d+$/.test(key)) {\n          item.splice(parseInt(key), 1);\n        } else if (options && options.descendArray) {\n          for (const elem of item) {\n            if (isObject(elem)) {\n              delete elem[key];\n            }\n          }\n        }\n      } else if (isObject(item)) {\n        delete item[key];\n      }\n    },\n    options\n  );\n}\nconst OPERATOR_NAME_PATTERN = /^\\$[a-zA-Z0-9_]+$/;\nfunction isOperator(name) {\n  return OPERATOR_NAME_PATTERN.test(name);\n}\nfunction normalize(expr) {\n  if (isScalar(expr)) {\n    return isRegExp(expr) ? { $regex: expr } : { $eq: expr };\n  }\n  if (isObjectLike(expr)) {\n    if (!Object.keys(expr).some(isOperator)) return { $eq: expr };\n    if (has(expr, \"$regex\")) {\n      const newExpr = { ...expr };\n      newExpr[\"$regex\"] = new RegExp(\n        expr[\"$regex\"],\n        expr[\"$options\"]\n      );\n      delete newExpr[\"$options\"];\n      return newExpr;\n    }\n  }\n  return expr;\n}\nfunction findInsertIndex(sorted, item, comparator = compare) {\n  let lo = 0;\n  let hi = sorted.length - 1;\n  while (lo <= hi) {\n    const mid = Math.round(lo + (hi - lo) / 2);\n    if (comparator(item, sorted[mid]) < 0) {\n      hi = mid - 1;\n    } else if (comparator(item, sorted[mid]) > 0) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return lo;\n}\nexport {\n  MingoError,\n  ValueMap,\n  assert,\n  cloneDeep,\n  compare,\n  ensureArray,\n  filterMissing,\n  findInsertIndex,\n  flatten,\n  groupBy,\n  has,\n  hashCode,\n  intersection,\n  into,\n  isArray,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isFunction,\n  isNil,\n  isNotNaN,\n  isNumber,\n  isObject,\n  isObjectLike,\n  isOperator,\n  isRegExp,\n  isString,\n  isSymbol,\n  merge,\n  normalize,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue,\n  stringify,\n  truthy,\n  typeOf,\n  unique,\n  walk\n};\n", "import {\n  assert,\n  has,\n  isArray,\n  isFunction,\n  isNil,\n  isObject,\n  isOperator,\n  isString,\n  resolve\n} from \"./util\";\nvar ProcessingMode = /* @__PURE__ */ ((ProcessingMode2) => {\n  ProcessingMode2[ProcessingMode2[\"CLONE_OFF\"] = 0] = \"CLONE_OFF\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_INPUT\"] = 1] = \"CLONE_INPUT\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_OUTPUT\"] = 2] = \"CLONE_OUTPUT\";\n  ProcessingMode2[ProcessingMode2[\"CLONE_ALL\"] = 3] = \"CLONE_ALL\";\n  return ProcessingMode2;\n})(ProcessingMode || {});\nclass ComputeOptions {\n  #options;\n  /** Reference to the root object when processing subgraphs of the object. */\n  #root;\n  #local;\n  constructor(options, root, local) {\n    this.#options = options;\n    this.update(root, local);\n  }\n  /**\n   * Initialize new ComputeOptions.\n   * @returns {ComputeOptions}\n   */\n  static init(options, root, local) {\n    return !(options instanceof ComputeOptions) ? new ComputeOptions(options, root, local) : new ComputeOptions(options.#options, options.root ?? root, {\n      ...options.#local,\n      ...local,\n      variables: Object.assign(\n        {},\n        options.#local?.variables,\n        local?.variables\n      )\n    });\n  }\n  /**\n   * Updates the internal state.\n   *\n   * @param root The new root context for this object.\n   * @param local The new local state to merge into current if it exists.\n   * @returns\n   */\n  update(root, local) {\n    this.#root = root;\n    const variables = Object.assign(\n      {},\n      this.#local?.variables,\n      local?.variables\n    );\n    if (Object.keys(variables).length) {\n      this.#local = { ...local, variables };\n    } else {\n      this.#local = local ?? {};\n    }\n    return this;\n  }\n  getOptions() {\n    return Object.freeze({\n      ...this.#options,\n      context: Context.from(this.#options.context)\n    });\n  }\n  get root() {\n    return this.#root;\n  }\n  get local() {\n    return this.#local;\n  }\n  get idKey() {\n    return this.#options.idKey;\n  }\n  get collation() {\n    return this.#options?.collation;\n  }\n  get processingMode() {\n    return this.#options?.processingMode || 0 /* CLONE_OFF */;\n  }\n  get useStrictMode() {\n    return this.#options?.useStrictMode;\n  }\n  get scriptEnabled() {\n    return this.#options?.scriptEnabled;\n  }\n  get useGlobalContext() {\n    return this.#options?.useGlobalContext;\n  }\n  get hashFunction() {\n    return this.#options?.hashFunction;\n  }\n  get collectionResolver() {\n    return this.#options?.collectionResolver;\n  }\n  get jsonSchemaValidator() {\n    return this.#options?.jsonSchemaValidator;\n  }\n  get variables() {\n    return this.#options?.variables;\n  }\n  get context() {\n    return this.#options?.context;\n  }\n}\nfunction initOptions(options) {\n  return options instanceof ComputeOptions ? options.getOptions() : Object.freeze({\n    idKey: \"_id\",\n    scriptEnabled: true,\n    useStrictMode: true,\n    useGlobalContext: true,\n    processingMode: 0 /* CLONE_OFF */,\n    ...options,\n    context: options?.context ? Context.from(options?.context) : Context.init()\n  });\n}\nvar OperatorType = /* @__PURE__ */ ((OperatorType2) => {\n  OperatorType2[\"ACCUMULATOR\"] = \"accumulator\";\n  OperatorType2[\"EXPRESSION\"] = \"expression\";\n  OperatorType2[\"PIPELINE\"] = \"pipeline\";\n  OperatorType2[\"PROJECTION\"] = \"projection\";\n  OperatorType2[\"QUERY\"] = \"query\";\n  OperatorType2[\"WINDOW\"] = \"window\";\n  return OperatorType2;\n})(OperatorType || {});\nclass Context {\n  #operators = /* @__PURE__ */ new Map();\n  constructor() {\n  }\n  static init() {\n    return new Context();\n  }\n  static from(ctx) {\n    const instance = Context.init();\n    if (isNil(ctx)) return instance;\n    ctx.#operators.forEach((v, k) => instance.addOperators(k, v));\n    return instance;\n  }\n  addOperators(type, operators) {\n    if (!this.#operators.has(type)) this.#operators.set(type, {});\n    for (const [name, fn] of Object.entries(operators)) {\n      if (!this.getOperator(type, name)) {\n        this.#operators.get(type)[name] = fn;\n      }\n    }\n    return this;\n  }\n  getOperator(type, name) {\n    const ops = this.#operators.get(type) ?? {};\n    return ops[name] ?? null;\n  }\n  addAccumulatorOps(ops) {\n    return this.addOperators(\"accumulator\", ops);\n  }\n  addExpressionOps(ops) {\n    return this.addOperators(\"expression\", ops);\n  }\n  addQueryOps(ops) {\n    return this.addOperators(\"query\", ops);\n  }\n  addPipelineOps(ops) {\n    return this.addOperators(\"pipeline\", ops);\n  }\n  addProjectionOps(ops) {\n    return this.addOperators(\"projection\", ops);\n  }\n  addWindowOps(ops) {\n    return this.addOperators(\"window\", ops);\n  }\n}\nconst GLOBAL_CONTEXT = Context.init();\nfunction useOperators(type, operators) {\n  for (const [name, fn] of Object.entries(operators)) {\n    assert(\n      isFunction(fn) && isOperator(name),\n      `'${name}' is not a valid operator`\n    );\n    const currentFn = getOperator(type, name, null);\n    assert(\n      !currentFn || fn === currentFn,\n      `${name} already exists for '${type}' operators. Cannot change operator function once registered.`\n    );\n  }\n  switch (type) {\n    case \"accumulator\":\n      GLOBAL_CONTEXT.addAccumulatorOps(operators);\n      break;\n    case \"expression\":\n      GLOBAL_CONTEXT.addExpressionOps(operators);\n      break;\n    case \"pipeline\":\n      GLOBAL_CONTEXT.addPipelineOps(operators);\n      break;\n    case \"projection\":\n      GLOBAL_CONTEXT.addProjectionOps(operators);\n      break;\n    case \"query\":\n      GLOBAL_CONTEXT.addQueryOps(operators);\n      break;\n    case \"window\":\n      GLOBAL_CONTEXT.addWindowOps(operators);\n      break;\n  }\n}\nfunction getOperator(type, name, options) {\n  const { context: ctx, useGlobalContext: fallback } = options || {};\n  const fn = ctx ? ctx.getOperator(type, name) : null;\n  return !fn && fallback ? GLOBAL_CONTEXT.getOperator(type, name) : fn;\n}\nfunction computeValue(obj, expr, operator, options) {\n  const copts = ComputeOptions.init(options, obj);\n  return !!operator && isOperator(operator) ? computeOperator(obj, expr, operator, copts) : computeExpression(obj, expr, copts);\n}\nconst SYSTEM_VARS = [\"$$ROOT\", \"$$CURRENT\", \"$$REMOVE\", \"$$NOW\"];\nfunction computeExpression(obj, expr, options) {\n  if (isString(expr) && expr.length > 0 && expr[0] === \"$\") {\n    if (REDACT_ACTIONS.includes(expr)) return expr;\n    let ctx = options.root;\n    const arr = expr.split(\".\");\n    if (SYSTEM_VARS.includes(arr[0])) {\n      switch (arr[0]) {\n        case \"$$ROOT\":\n          break;\n        case \"$$CURRENT\":\n          ctx = obj;\n          break;\n        case \"$$REMOVE\":\n          ctx = void 0;\n          break;\n        case \"$$NOW\":\n          ctx = /* @__PURE__ */ new Date();\n          break;\n      }\n      expr = expr.slice(arr[0].length + 1);\n    } else if (arr[0].slice(0, 2) === \"$$\") {\n      ctx = Object.assign(\n        {},\n        // global vars\n        options.variables,\n        // current item is added before local variables because the binding may be changed.\n        { this: obj },\n        // local vars\n        options?.local?.variables\n      );\n      const name = arr[0].slice(2);\n      assert(has(ctx, name), `Use of undefined variable: ${name}`);\n      expr = expr.slice(2);\n    } else {\n      expr = expr.slice(1);\n    }\n    return expr === \"\" ? ctx : resolve(ctx, expr);\n  }\n  if (isArray(expr)) {\n    return expr.map((item) => computeExpression(obj, item, options));\n  }\n  if (isObject(expr)) {\n    const result = {};\n    const elems = Object.entries(expr);\n    for (const [key, val] of elems) {\n      if (isOperator(key)) {\n        assert(elems.length == 1, \"expression must have single operator.\");\n        return computeOperator(obj, val, key, options);\n      }\n      result[key] = computeExpression(obj, val, options);\n    }\n    return result;\n  }\n  return expr;\n}\nfunction computeOperator(obj, expr, operator, options) {\n  const callExpression = getOperator(\n    \"expression\",\n    operator,\n    options\n  );\n  if (callExpression) return callExpression(obj, expr, options);\n  const callAccumulator = getOperator(\n    \"accumulator\",\n    operator,\n    options\n  );\n  assert(!!callAccumulator, `accumulator '${operator}' is not registered.`);\n  if (!isArray(obj)) {\n    obj = computeExpression(obj, expr, options);\n    expr = null;\n  }\n  assert(isArray(obj), `arguments must resolve to array for ${operator}.`);\n  return callAccumulator(obj, expr, options);\n}\nconst REDACT_ACTIONS = [\"$$KEEP\", \"$$PRUNE\", \"$$DESCEND\"];\nfunction redact(obj, expr, options) {\n  const action = computeValue(obj, expr, null, options);\n  switch (action) {\n    case \"$$KEEP\":\n      return obj;\n    case \"$$PRUNE\":\n      return void 0;\n    case \"$$DESCEND\": {\n      if (!has(expr, \"$cond\")) return obj;\n      const output = {};\n      for (const [key, value] of Object.entries(obj)) {\n        if (isArray(value)) {\n          const res = new Array();\n          for (let elem of value) {\n            if (isObject(elem)) {\n              elem = redact(elem, expr, options.update(elem));\n            }\n            if (!isNil(elem)) res.push(elem);\n          }\n          output[key] = res;\n        } else if (isObject(value)) {\n          const res = redact(\n            value,\n            expr,\n            options.update(value)\n          );\n          if (!isNil(res)) output[key] = res;\n        } else {\n          output[key] = value;\n        }\n      }\n      return output;\n    }\n    default:\n      return action;\n  }\n}\nexport {\n  ComputeOptions,\n  Context,\n  OperatorType,\n  ProcessingMode,\n  computeValue,\n  getOperator,\n  initOptions,\n  redact,\n  useOperators\n};\n", "import { isArray, MingoError } from \"./util\";\nfunction Lazy(source) {\n  return source instanceof Iterator ? source : new Iterator(source);\n}\nfunction concat(...iterators) {\n  let index = 0;\n  return Lazy(() => {\n    while (index < iterators.length) {\n      const o = iterators[index].next();\n      if (!o.done) return o;\n      index++;\n    }\n    return { done: true };\n  });\n}\nfunction isGenerator(o) {\n  return !!o && typeof o === \"object\" && o?.next instanceof Function;\n}\nfunction dropItem(array, i) {\n  const rest = array.slice(i + 1);\n  array.splice(i);\n  Array.prototype.push.apply(array, rest);\n}\nconst DONE = new Error();\nvar Action = /* @__PURE__ */ ((Action2) => {\n  Action2[Action2[\"MAP\"] = 0] = \"MAP\";\n  Action2[Action2[\"FILTER\"] = 1] = \"FILTER\";\n  Action2[Action2[\"TAKE\"] = 2] = \"TAKE\";\n  Action2[Action2[\"DROP\"] = 3] = \"DROP\";\n  return Action2;\n})(Action || {});\nfunction createCallback(nextFn, iteratees, buffer) {\n  let done = false;\n  let index = -1;\n  let bufferIndex = 0;\n  return function(storeResult) {\n    try {\n      outer: while (!done) {\n        let o = nextFn();\n        index++;\n        let i = -1;\n        const size = iteratees.length;\n        let innerDone = false;\n        while (++i < size) {\n          const r = iteratees[i];\n          switch (r.action) {\n            case 0 /* MAP */:\n              o = r.func(o, index);\n              break;\n            case 1 /* FILTER */:\n              if (!r.func(o, index)) continue outer;\n              break;\n            case 2 /* TAKE */:\n              --r.count;\n              if (!r.count) innerDone = true;\n              break;\n            case 3 /* DROP */:\n              --r.count;\n              if (!r.count) dropItem(iteratees, i);\n              continue outer;\n            default:\n              break outer;\n          }\n        }\n        done = innerDone;\n        if (storeResult) {\n          buffer[bufferIndex++] = o;\n        } else {\n          return { value: o, done: false };\n        }\n      }\n    } catch (e) {\n      if (e !== DONE) throw e;\n    }\n    done = true;\n    return { done };\n  };\n}\nclass Iterator {\n  /**\n   * @param {*} source An iterable object or function.\n   *    Array - return one element per cycle\n   *    Object{next:Function} - call next() for the next value (this also handles generator functions)\n   *    Function - call to return the next value\n   * @param {Function} fn An optional transformation function\n   */\n  constructor(source) {\n    this.#iteratees = [];\n    this.#yieldedValues = [];\n    this.isDone = false;\n    let nextVal;\n    if (source instanceof Function) {\n      source = { next: source };\n    }\n    if (isGenerator(source)) {\n      const src = source;\n      nextVal = () => {\n        const o = src.next();\n        if (o.done) throw DONE;\n        return o.value;\n      };\n    } else if (isArray(source)) {\n      const data = source;\n      const size = data.length;\n      let index = 0;\n      nextVal = () => {\n        if (index < size) return data[index++];\n        throw DONE;\n      };\n    } else if (!(source instanceof Function)) {\n      throw new MingoError(\n        `Lazy must be initialized with an array, generator, or function.`\n      );\n    }\n    this.#getNext = createCallback(\n      nextVal,\n      this.#iteratees,\n      this.#yieldedValues\n    );\n  }\n  #iteratees;\n  #yieldedValues;\n  #getNext;\n  /**\n   * Add an iteratee to this lazy sequence\n   */\n  push(action, value) {\n    if (typeof value === \"function\") {\n      this.#iteratees.push({ action, func: value });\n    } else if (typeof value === \"number\") {\n      this.#iteratees.push({ action, count: value });\n    }\n    return this;\n  }\n  next() {\n    return this.#getNext();\n  }\n  // Iteratees methods\n  /**\n   * Transform each item in the sequence to a new value\n   * @param {Function} f\n   */\n  map(f) {\n    return this.push(0 /* MAP */, f);\n  }\n  /**\n   * Select only items matching the given predicate\n   * @param {Function} pred\n   */\n  filter(predicate) {\n    return this.push(1 /* FILTER */, predicate);\n  }\n  /**\n   * Take given numbe for values from sequence\n   * @param {Number} n A number greater than 0\n   */\n  take(n) {\n    return n > 0 ? this.push(2 /* TAKE */, n) : this;\n  }\n  /**\n   * Drop a number of values from the sequence\n   * @param {Number} n Number of items to drop greater than 0\n   */\n  drop(n) {\n    return n > 0 ? this.push(3 /* DROP */, n) : this;\n  }\n  // Transformations\n  /**\n   * Returns a new lazy object with results of the transformation\n   * The entire sequence is realized.\n   *\n   * @param {Callback<Source, Any[]>} fn Tranform function of type (Array) => (Any)\n   */\n  transform(fn) {\n    const self = this;\n    let iter;\n    return Lazy(() => {\n      if (!iter) {\n        iter = Lazy(fn(self.value()));\n      }\n      return iter.next();\n    });\n  }\n  // Terminal methods\n  /**\n   * Returns the fully realized values of the iterators.\n   * The return value will be an array unless `lazy.first()` was used.\n   * The realized values are cached for subsequent calls.\n   */\n  value() {\n    if (!this.isDone) {\n      this.isDone = this.#getNext(true).done;\n    }\n    return this.#yieldedValues;\n  }\n  /**\n   * Execute the funcion for each value. Will stop when an execution returns false.\n   * @param {Function} f\n   * @returns {Boolean} false iff `f` return false for AnyVal execution, otherwise true\n   */\n  each(f) {\n    for (; ; ) {\n      const o = this.next();\n      if (o.done) break;\n      if (f(o.value) === false) return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the reduction of sequence according the reducing function\n   *\n   * @param {*} f a reducing function\n   * @param {*} initialValue\n   */\n  reduce(f, initialValue) {\n    let o = this.next();\n    if (initialValue === void 0 && !o.done) {\n      initialValue = o.value;\n      o = this.next();\n    }\n    while (!o.done) {\n      initialValue = f(initialValue, o.value);\n      o = this.next();\n    }\n    return initialValue;\n  }\n  /**\n   * Returns the number of matched items in the sequence\n   */\n  size() {\n    return this.reduce(\n      (acc, _) => ++acc,\n      0\n    );\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n}\nexport {\n  Iterator,\n  Lazy,\n  concat\n};\n", "const $limit = (collection, expr, _options) => collection.take(expr);\nexport {\n  $limit\n};\n", "import {\n  ComputeOptions,\n  computeValue,\n  getOperator\n} from \"../../core\";\nimport {\n  assert,\n  ensureArray,\n  filterMissing,\n  has,\n  isArray,\n  isBoolean,\n  isEmpty,\n  isNumber,\n  isObject,\n  isOperator,\n  isString,\n  merge,\n  removeValue,\n  resolve,\n  resolveGraph,\n  setValue\n} from \"../../util\";\nconst $project = (collection, expr, options) => {\n  if (isEmpty(expr)) return collection;\n  validateExpression(expr, options);\n  return collection.map(createHandler(expr, ComputeOptions.init(options)));\n};\nfunction createHandler(expr, options, isRoot = true) {\n  const idKey = options.idKey;\n  const expressionKeys = Object.keys(expr);\n  const excludedKeys = new Array();\n  const includedKeys = new Array();\n  const handlers = {};\n  for (const key of expressionKeys) {\n    const subExpr = expr[key];\n    if (isNumber(subExpr) || isBoolean(subExpr)) {\n      if (subExpr) {\n        includedKeys.push(key);\n      } else {\n        excludedKeys.push(key);\n      }\n    } else if (isArray(subExpr)) {\n      handlers[key] = (o) => subExpr.map((v) => computeValue(o, v, null, options.update(o)) ?? null);\n    } else if (isObject(subExpr)) {\n      const subExprKeys = Object.keys(subExpr);\n      const operator = subExprKeys.length == 1 ? subExprKeys[0] : \"\";\n      const projectFn = getOperator(\n        \"projection\",\n        operator,\n        options\n      );\n      if (projectFn) {\n        const foundSlice = operator === \"$slice\";\n        if (foundSlice && !ensureArray(subExpr[operator]).every(isNumber)) {\n          handlers[key] = (o) => computeValue(o, subExpr, key, options.update(o));\n        } else {\n          handlers[key] = (o) => projectFn(o, subExpr[operator], key, options.update(o));\n        }\n      } else if (isOperator(operator)) {\n        handlers[key] = (o) => computeValue(o, subExpr[operator], operator, options);\n      } else {\n        validateExpression(subExpr, options);\n        handlers[key] = (o) => {\n          if (!has(o, key)) return computeValue(o, subExpr, null, options);\n          if (isRoot) options.update(o);\n          const target = resolve(o, key);\n          const fn = createHandler(subExpr, options, false);\n          if (isArray(target)) return target.map(fn);\n          if (isObject(target)) return fn(target);\n          return fn(o);\n        };\n      }\n    } else {\n      handlers[key] = isString(subExpr) && subExpr[0] === \"$\" ? (o) => computeValue(o, subExpr, key, options) : (_) => subExpr;\n    }\n  }\n  const handlerKeys = Object.keys(handlers);\n  const idKeyExcluded = excludedKeys.includes(idKey);\n  const idKeyOnlyExcluded = isRoot && idKeyExcluded && excludedKeys.length === 1 && !includedKeys.length && !handlerKeys.length;\n  if (idKeyOnlyExcluded) {\n    return (o) => {\n      const newObj = { ...o };\n      delete newObj[idKey];\n      return newObj;\n    };\n  }\n  const idKeyImplicit = isRoot && !idKeyExcluded && !includedKeys.includes(idKey);\n  const opts = {\n    preserveMissing: true\n  };\n  return (o) => {\n    const newObj = {};\n    if (excludedKeys.length && !includedKeys.length) {\n      merge(newObj, o);\n      for (const k of excludedKeys) {\n        removeValue(newObj, k, { descendArray: true });\n      }\n    }\n    for (const k of includedKeys) {\n      const pathObj = resolveGraph(o, k, opts) ?? {};\n      merge(newObj, pathObj);\n    }\n    if (includedKeys.length) filterMissing(newObj);\n    for (const k of handlerKeys) {\n      const value = handlers[k](o);\n      if (value === void 0) {\n        removeValue(newObj, k, { descendArray: true });\n      } else {\n        setValue(newObj, k, value);\n      }\n    }\n    if (idKeyImplicit && has(o, idKey)) {\n      newObj[idKey] = resolve(o, idKey);\n    }\n    return newObj;\n  };\n}\nfunction validateExpression(expr, options) {\n  let exclusions = false;\n  let inclusions = false;\n  for (const [k, v] of Object.entries(expr)) {\n    assert(!k.startsWith(\"$\"), \"Field names may not start with '$'.\");\n    assert(\n      !k.endsWith(\".$\"),\n      \"Positional projection operator '$' is not supported.\"\n    );\n    if (k === options?.idKey) continue;\n    if (v === 0 || v === false) {\n      exclusions = true;\n    } else if (v === 1 || v === true) {\n      inclusions = true;\n    }\n    assert(\n      !(exclusions && inclusions),\n      \"Projection cannot have a mix of inclusion and exclusion.\"\n    );\n  }\n}\nexport {\n  $project\n};\n", "const $skip = (collection, expr, _options) => {\n  return collection.drop(expr);\n};\nexport {\n  $skip\n};\n", "import {\n  assert,\n  compare,\n  groupBy,\n  isEmpty,\n  isObject,\n  isString,\n  resolve\n} from \"../../util\";\nconst $sort = (collection, sortKeys, options) => {\n  if (isEmpty(sortKeys) || !isObject(sortKeys)) return collection;\n  let cmp = compare;\n  const collationSpec = options.collation;\n  if (isObject(collationSpec) && isString(collationSpec.locale)) {\n    cmp = collationComparator(collationSpec);\n  }\n  return collection.transform((coll) => {\n    const modifiers = Object.keys(sortKeys);\n    for (const key of modifiers.reverse()) {\n      const groups = groupBy(\n        coll,\n        (obj) => resolve(obj, key),\n        options.hashFunction\n      );\n      const sortedKeys = Array.from(groups.keys()).sort(cmp);\n      if (sortKeys[key] === -1) sortedKeys.reverse();\n      let i = 0;\n      for (const k of sortedKeys) for (const v of groups.get(k)) coll[i++] = v;\n      assert(i == coll.length, \"bug: counter must match collection size.\");\n    }\n    return coll;\n  });\n};\nconst COLLATION_STRENGTH = {\n  // Only strings that differ in base letters compare as unequal. Examples: a  b, a = , a = A.\n  1: \"base\",\n  //  Only strings that differ in base letters or accents and other diacritic marks compare as unequal.\n  // Examples: a  b, a  , a = A.\n  2: \"accent\",\n  // Strings that differ in base letters, accents and other diacritic marks, or case compare as unequal.\n  // Other differences may also be taken into consideration. Examples: a  b, a  , a  A\n  3: \"variant\"\n  // case - Only strings that differ in base letters or case compare as unequal. Examples: a  b, a = , a  A.\n};\nfunction collationComparator(spec) {\n  const localeOpt = {\n    sensitivity: COLLATION_STRENGTH[spec.strength || 3],\n    caseFirst: spec.caseFirst === \"off\" ? \"false\" : spec.caseFirst || \"false\",\n    numeric: spec.numericOrdering || false,\n    ignorePunctuation: spec.alternate === \"shifted\"\n  };\n  if ((spec.caseLevel || false) === true) {\n    if (localeOpt.sensitivity === \"base\") localeOpt.sensitivity = \"case\";\n    if (localeOpt.sensitivity === \"accent\") localeOpt.sensitivity = \"variant\";\n  }\n  const collator = new Intl.Collator(spec.locale, localeOpt);\n  return (a, b) => {\n    if (!isString(a) || !isString(b)) return compare(a, b);\n    const i = collator.compare(a, b);\n    if (i < 0) return -1;\n    if (i > 0) return 1;\n    return 0;\n  };\n}\nexport {\n  $sort\n};\n", "import {\n  ProcessingMode\n} from \"./core\";\nimport { concat, Lazy } from \"./lazy\";\nimport { $limit } from \"./operators/pipeline/limit\";\nimport { $project } from \"./operators/pipeline/project\";\nimport { $skip } from \"./operators/pipeline/skip\";\nimport { $sort } from \"./operators/pipeline/sort\";\nimport { cloneDeep, has } from \"./util\";\nconst OPERATORS = { $sort, $skip, $limit };\nclass Cursor {\n  #source;\n  #predicate;\n  #projection;\n  #options;\n  #operators = {};\n  #result = null;\n  #buffer = [];\n  constructor(source, predicate, projection, options) {\n    this.#source = source;\n    this.#predicate = predicate;\n    this.#projection = projection;\n    this.#options = options;\n  }\n  /** Returns the iterator from running the query */\n  fetch() {\n    if (this.#result) return this.#result;\n    this.#result = Lazy(this.#source).filter(this.#predicate);\n    const mode = this.#options.processingMode;\n    if (mode & ProcessingMode.CLONE_INPUT) this.#result.map(cloneDeep);\n    for (const op of [\"$sort\", \"$skip\", \"$limit\"]) {\n      if (has(this.#operators, op)) {\n        this.#result = OPERATORS[op](\n          this.#result,\n          this.#operators[op],\n          this.#options\n        );\n      }\n    }\n    if (Object.keys(this.#projection).length) {\n      this.#result = $project(this.#result, this.#projection, this.#options);\n    }\n    if (mode & ProcessingMode.CLONE_OUTPUT) this.#result.map(cloneDeep);\n    return this.#result;\n  }\n  /** Returns an iterator with the buffered data included */\n  fetchAll() {\n    const buffered = Lazy([...this.#buffer]);\n    this.#buffer = [];\n    return concat(buffered, this.fetch());\n  }\n  /**\n   * Return remaining objects in the cursor as an array. This method exhausts the cursor\n   * @returns {Array}\n   */\n  all() {\n    return this.fetchAll().value();\n  }\n  /**\n   * Returns the number of objects return in the cursor. This method exhausts the cursor\n   * @returns {Number}\n   */\n  count() {\n    return this.all().length;\n  }\n  /**\n   * Returns a cursor that begins returning results only after passing or skipping a number of documents.\n   * @param {Number} n the number of results to skip.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  skip(n) {\n    this.#operators[\"$skip\"] = n;\n    return this;\n  }\n  /**\n   * Constrains the size of a cursor's result set.\n   * @param {Number} n the number of results to limit to.\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  limit(n) {\n    this.#operators[\"$limit\"] = n;\n    return this;\n  }\n  /**\n   * Returns results ordered according to a sort specification.\n   * @param {AnyObject} modifier an object of key and values specifying the sort order. 1 for ascending and -1 for descending\n   * @return {Cursor} Returns the cursor, so you can chain this call.\n   */\n  sort(modifier) {\n    this.#operators[\"$sort\"] = modifier;\n    return this;\n  }\n  /**\n   * Specifies the collation for the cursor returned by the `mingo.Query.find`\n   * @param {*} spec\n   */\n  collation(spec) {\n    this.#options = { ...this.#options, collation: spec };\n    return this;\n  }\n  /**\n   * Returns the next document in a cursor.\n   * @returns {AnyObject | Boolean}\n   */\n  next() {\n    if (this.#buffer.length > 0) {\n      return this.#buffer.pop();\n    }\n    const o = this.fetch().next();\n    if (o.done) return;\n    return o.value;\n  }\n  /**\n   * Returns true if the cursor has documents and can be iterated.\n   * @returns {boolean}\n   */\n  hasNext() {\n    if (this.#buffer.length > 0) return true;\n    const o = this.fetch().next();\n    if (o.done) return false;\n    this.#buffer.push(o.value);\n    return true;\n  }\n  /**\n   * Applies a function to each document in a cursor and collects the return values in an array.\n   * @param fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.all().map(fn);\n  }\n  /**\n   * Applies a JavaScript function for every document in a cursor.\n   * @param fn\n   */\n  forEach(fn) {\n    this.all().forEach(fn);\n  }\n  [Symbol.iterator]() {\n    return this.fetchAll();\n  }\n}\nexport {\n  Cursor\n};\n", "import { getOperator, initOptions } from \"./core\";\nimport { Cursor } from \"./cursor\";\nimport { assert, cloneDeep, isObject, isOperator, normalize } from \"./util\";\nconst TOP_LEVEL_OPS = new Set(\n  Array.from([\"$and\", \"$or\", \"$nor\", \"$expr\", \"$jsonSchema\"])\n);\nclass Query {\n  #compiled;\n  #options;\n  #condition;\n  constructor(condition, options) {\n    this.#condition = cloneDeep(condition);\n    this.#options = initOptions(options);\n    this.#compiled = [];\n    this.compile();\n  }\n  compile() {\n    assert(\n      isObject(this.#condition),\n      `query criteria must be an object: ${JSON.stringify(this.#condition)}`\n    );\n    const whereOperator = {};\n    for (const [field, expr] of Object.entries(this.#condition)) {\n      if (\"$where\" === field) {\n        assert(\n          this.#options.scriptEnabled,\n          \"$where operator requires 'scriptEnabled' option to be true.\"\n        );\n        Object.assign(whereOperator, { field, expr });\n      } else if (TOP_LEVEL_OPS.has(field)) {\n        this.processOperator(field, field, expr);\n      } else {\n        assert(!isOperator(field), `unknown top level operator: ${field}`);\n        for (const [operator, val] of Object.entries(\n          normalize(expr)\n        )) {\n          this.processOperator(field, operator, val);\n        }\n      }\n      if (whereOperator.field) {\n        this.processOperator(\n          whereOperator.field,\n          whereOperator.field,\n          whereOperator.expr\n        );\n      }\n    }\n  }\n  processOperator(field, operator, value) {\n    const call = getOperator(\"query\", operator, this.#options);\n    assert(!!call, `unknown query operator ${operator}`);\n    this.#compiled.push(call(field, value, this.#options));\n  }\n  /**\n   * Checks if the object passes the query criteria. Returns true if so, false otherwise.\n   *\n   * @param obj The object to test\n   * @returns {boolean}\n   */\n  test(obj) {\n    return this.#compiled.every((p) => p(obj));\n  }\n  /**\n   * Returns a cursor to select matching documents from the input source.\n   *\n   * @param source A source providing a sequence of documents\n   * @param projection An optional projection criteria\n   * @returns {Cursor} A Cursor for iterating over the results\n   */\n  find(collection, projection) {\n    return new Cursor(\n      collection,\n      (o) => this.test(o),\n      projection || {},\n      this.#options\n    );\n  }\n  /**\n   * Remove matched documents from the collection returning the remainder\n   *\n   * @param collection An array of documents\n   * @returns {Array} A new array with matching elements removed\n   */\n  remove(collection) {\n    return collection.reduce((acc, obj) => {\n      if (!this.test(obj)) acc.push(obj);\n      return acc;\n    }, []);\n  }\n}\nexport {\n  Query\n};\n", "import { computeValue } from \"../../core\";\nimport { Lazy } from \"../../lazy\";\nimport {\n  assert,\n  compare,\n  findInsertIndex,\n  isArray,\n  isEqual,\n  isNil,\n  isNumber\n} from \"../../util\";\nconst $bucketAuto = (collection, expr, options) => {\n  const {\n    buckets: bucketCount,\n    groupBy: groupByExpr,\n    output: optOutputExpr,\n    // Available only if the all groupBy values are numeric and none of them are NaN.\n    granularity\n  } = expr;\n  const outputExpr = optOutputExpr ?? { count: { $sum: 1 } };\n  assert(\n    bucketCount > 0,\n    `$bucketAuto: 'buckets' field must be greater than 0, but found: ${bucketCount}`\n  );\n  if (granularity) {\n    assert(\n      /^(POWERSOF2|1-2-5|E(6|12|24|48|96|192)|R(5|10|20|40|80))$/.test(\n        granularity\n      ),\n      `$bucketAuto: invalid granularity '${granularity}'.`\n    );\n  }\n  const keyMap = /* @__PURE__ */ new Map();\n  const setKey = !granularity ? (o, k) => keyMap.set(o, k) : (_, _2) => {\n  };\n  const sorted = collection.map((o) => {\n    const k = computeValue(o, groupByExpr, null, options) ?? null;\n    assert(\n      !granularity || isNumber(k),\n      \"$bucketAuto: groupBy values must be numeric when granularity is specified.\"\n    );\n    setKey(o, k ?? null);\n    return [k ?? null, o];\n  }).value();\n  sorted.sort((x, y) => {\n    if (isNil(x[0])) return -1;\n    if (isNil(y[0])) return 1;\n    return compare(x[0], y[0]);\n  });\n  let getNext;\n  if (!granularity) {\n    getNext = granularityDefault(sorted, bucketCount, keyMap);\n  } else if (granularity == \"POWERSOF2\") {\n    getNext = granularityPowerOfTwo(\n      sorted,\n      bucketCount\n    );\n  } else {\n    getNext = granularityPreferredSeries(\n      sorted,\n      bucketCount,\n      granularity\n    );\n  }\n  let terminate = false;\n  return Lazy(() => {\n    if (terminate) return { done: true };\n    const { min, max, bucket, done } = getNext();\n    terminate = done;\n    const outFields = computeValue(\n      bucket,\n      outputExpr,\n      null,\n      options\n    );\n    for (const [k, v] of Object.entries(outFields)) {\n      if (isArray(v)) outFields[k] = v.filter((v2) => v2 !== void 0);\n    }\n    return {\n      done: false,\n      value: {\n        ...outFields,\n        _id: { min, max }\n      }\n    };\n  });\n};\nfunction granularityDefault(sorted, bucketCount, keyMap) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  let index = 0;\n  let nBuckets = 0;\n  return () => {\n    const isLastBucket = ++nBuckets == bucketCount;\n    const bucket = new Array();\n    while (index < size && (isLastBucket || bucket.length < approxBucketSize || index > 0 && isEqual(sorted[index - 1][0], sorted[index][0]))) {\n      bucket.push(sorted[index++][1]);\n    }\n    const min = keyMap.get(bucket[0]);\n    let max;\n    if (index < size) {\n      max = sorted[index][0];\n    } else {\n      max = keyMap.get(bucket[bucket.length - 1]);\n    }\n    assert(\n      isNil(max) || isNil(min) || min <= max,\n      `error: $bucketAuto boundary must be in order.`\n    );\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nfunction granularityPowerOfTwo(sorted, bucketCount) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  const roundUp2 = (n) => n === 0 ? 0 : 2 ** (Math.floor(Math.log2(n)) + 1);\n  let index = 0;\n  let min = 0;\n  let max = 0;\n  return () => {\n    const bucket = new Array();\n    const boundValue = roundUp2(max);\n    min = index > 0 ? max : 0;\n    while (bucket.length < approxBucketSize && index < size && (max === 0 || sorted[index][0] < boundValue)) {\n      bucket.push(sorted[index++][1]);\n    }\n    max = max == 0 ? roundUp2(sorted[index - 1][0]) : boundValue;\n    while (index < size && sorted[index][0] < max) {\n      bucket.push(sorted[index++][1]);\n    }\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nconst PREFERRED_NUMBERS = Object.freeze({\n  // \"Least rounded\" Renard number series, taken from Wikipedia page on preferred\n  // numbers: https://en.wikipedia.org/wiki/Preferred_number#Renard_numbers\n  R5: [10, 16, 25, 40, 63],\n  R10: [100, 125, 160, 200, 250, 315, 400, 500, 630, 800],\n  R20: [\n    100,\n    112,\n    125,\n    140,\n    160,\n    180,\n    200,\n    224,\n    250,\n    280,\n    315,\n    355,\n    400,\n    450,\n    500,\n    560,\n    630,\n    710,\n    800,\n    900\n  ],\n  R40: [\n    100,\n    106,\n    112,\n    118,\n    125,\n    132,\n    140,\n    150,\n    160,\n    170,\n    180,\n    190,\n    200,\n    212,\n    224,\n    236,\n    250,\n    265,\n    280,\n    300,\n    315,\n    355,\n    375,\n    400,\n    425,\n    450,\n    475,\n    500,\n    530,\n    560,\n    600,\n    630,\n    670,\n    710,\n    750,\n    800,\n    850,\n    900,\n    950\n  ],\n  R80: [\n    103,\n    109,\n    115,\n    122,\n    128,\n    136,\n    145,\n    155,\n    165,\n    175,\n    185,\n    195,\n    206,\n    218,\n    230,\n    243,\n    258,\n    272,\n    290,\n    307,\n    325,\n    345,\n    365,\n    387,\n    412,\n    437,\n    462,\n    487,\n    515,\n    545,\n    575,\n    615,\n    650,\n    690,\n    730,\n    775,\n    825,\n    875,\n    925,\n    975\n  ],\n  // https://en.wikipedia.org/wiki/Preferred_number#1-2-5_series\n  \"1-2-5\": [10, 20, 50],\n  // E series, taken from Wikipedia page on preferred numbers:\n  // https://en.wikipedia.org/wiki/Preferred_number#E_series\n  E6: [10, 15, 22, 33, 47, 68],\n  E12: [10, 12, 15, 18, 22, 27, 33, 39, 47, 56, 68, 82],\n  E24: [\n    10,\n    11,\n    12,\n    13,\n    15,\n    16,\n    18,\n    20,\n    22,\n    24,\n    27,\n    30,\n    33,\n    36,\n    39,\n    43,\n    47,\n    51,\n    56,\n    62,\n    68,\n    75,\n    82,\n    91\n  ],\n  E48: [\n    100,\n    105,\n    110,\n    115,\n    121,\n    127,\n    133,\n    140,\n    147,\n    154,\n    162,\n    169,\n    178,\n    187,\n    196,\n    205,\n    215,\n    226,\n    237,\n    249,\n    261,\n    274,\n    287,\n    301,\n    316,\n    332,\n    348,\n    365,\n    383,\n    402,\n    422,\n    442,\n    464,\n    487,\n    511,\n    536,\n    562,\n    590,\n    619,\n    649,\n    681,\n    715,\n    750,\n    787,\n    825,\n    866,\n    909,\n    953\n  ],\n  E96: [\n    100,\n    102,\n    105,\n    107,\n    110,\n    113,\n    115,\n    118,\n    121,\n    124,\n    127,\n    130,\n    133,\n    137,\n    140,\n    143,\n    147,\n    150,\n    154,\n    158,\n    162,\n    165,\n    169,\n    174,\n    178,\n    182,\n    187,\n    191,\n    196,\n    200,\n    205,\n    210,\n    215,\n    221,\n    226,\n    232,\n    237,\n    243,\n    249,\n    255,\n    261,\n    267,\n    274,\n    280,\n    287,\n    294,\n    301,\n    309,\n    316,\n    324,\n    332,\n    340,\n    348,\n    357,\n    365,\n    374,\n    383,\n    392,\n    402,\n    412,\n    422,\n    432,\n    442,\n    453,\n    464,\n    475,\n    487,\n    499,\n    511,\n    523,\n    536,\n    549,\n    562,\n    576,\n    590,\n    604,\n    619,\n    634,\n    649,\n    665,\n    681,\n    698,\n    715,\n    732,\n    750,\n    768,\n    787,\n    806,\n    825,\n    845,\n    866,\n    887,\n    909,\n    931,\n    953,\n    976\n  ],\n  E192: [\n    100,\n    101,\n    102,\n    104,\n    105,\n    106,\n    107,\n    109,\n    110,\n    111,\n    113,\n    114,\n    115,\n    117,\n    118,\n    120,\n    121,\n    123,\n    124,\n    126,\n    127,\n    129,\n    130,\n    132,\n    133,\n    135,\n    137,\n    138,\n    140,\n    142,\n    143,\n    145,\n    147,\n    149,\n    150,\n    152,\n    154,\n    156,\n    158,\n    160,\n    162,\n    164,\n    165,\n    167,\n    169,\n    172,\n    174,\n    176,\n    178,\n    180,\n    182,\n    184,\n    187,\n    189,\n    191,\n    193,\n    196,\n    198,\n    200,\n    203,\n    205,\n    208,\n    210,\n    213,\n    215,\n    218,\n    221,\n    223,\n    226,\n    229,\n    232,\n    234,\n    237,\n    240,\n    243,\n    246,\n    249,\n    252,\n    255,\n    258,\n    261,\n    264,\n    267,\n    271,\n    274,\n    277,\n    280,\n    284,\n    287,\n    291,\n    294,\n    298,\n    301,\n    305,\n    309,\n    312,\n    316,\n    320,\n    324,\n    328,\n    332,\n    336,\n    340,\n    344,\n    348,\n    352,\n    357,\n    361,\n    365,\n    370,\n    374,\n    379,\n    383,\n    388,\n    392,\n    397,\n    402,\n    407,\n    412,\n    417,\n    422,\n    427,\n    432,\n    437,\n    442,\n    448,\n    453,\n    459,\n    464,\n    470,\n    475,\n    481,\n    487,\n    493,\n    499,\n    505,\n    511,\n    517,\n    523,\n    530,\n    536,\n    542,\n    549,\n    556,\n    562,\n    569,\n    576,\n    583,\n    590,\n    597,\n    604,\n    612,\n    619,\n    626,\n    634,\n    642,\n    649,\n    657,\n    665,\n    673,\n    681,\n    690,\n    698,\n    706,\n    715,\n    723,\n    732,\n    741,\n    750,\n    759,\n    768,\n    777,\n    787,\n    796,\n    806,\n    816,\n    825,\n    835,\n    845,\n    856,\n    866,\n    876,\n    887,\n    898,\n    909,\n    920,\n    931,\n    942,\n    953,\n    965,\n    976,\n    988\n  ]\n});\nconst roundUp = (n, granularity) => {\n  if (n == 0) return 0;\n  const series = PREFERRED_NUMBERS[granularity];\n  const first = series[0];\n  const last = series[series.length - 1];\n  let multiplier = 1;\n  while (n >= last * multiplier) {\n    multiplier *= 10;\n  }\n  let previousMin = 0;\n  while (n < first * multiplier) {\n    previousMin = first * multiplier;\n    multiplier /= 10;\n    if (n >= last * multiplier) {\n      return previousMin;\n    }\n  }\n  assert(\n    n >= first * multiplier && n < last * multiplier,\n    \"$bucketAuto: number out of range of series.\"\n  );\n  const i = findInsertIndex(series, n, (a, b) => {\n    b *= multiplier;\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  });\n  const seriesNumber = series[i] * multiplier;\n  return n == seriesNumber ? series[i + 1] * multiplier : seriesNumber;\n};\nfunction granularityPreferredSeries(sorted, bucketCount, granularity) {\n  const size = sorted.length;\n  const approxBucketSize = Math.max(1, Math.round(sorted.length / bucketCount));\n  let index = 0;\n  let nBuckets = 0;\n  let min = 0;\n  let max = 0;\n  return () => {\n    const isLastBucket = ++nBuckets == bucketCount;\n    const bucket = new Array();\n    min = index > 0 ? max : 0;\n    while (index < size && (isLastBucket || bucket.length < approxBucketSize)) {\n      bucket.push(sorted[index++][1]);\n    }\n    max = roundUp(sorted[index - 1][0], granularity);\n    const nItems = bucket.length;\n    while (index < size && (isLastBucket || sorted[index][0] < max)) {\n      bucket.push(sorted[index++][1]);\n    }\n    if (nItems != bucket.length) {\n      max = roundUp(sorted[index - 1][0], granularity);\n    }\n    assert(min < max, `$bucketAuto: ${min} < ${max}.`);\n    return {\n      min,\n      max,\n      bucket,\n      done: index >= size\n    };\n  };\n}\nexport {\n  $bucketAuto\n};\n", "import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber, MingoError } from \"../../../util\";\nconst LEAP_YEAR_REF_POINT = -1e9;\nconst DAYS_PER_WEEK = 7;\nconst isLeapYear = (y) => (y & 3) == 0 && (y % 100 != 0 || y % 400 == 0);\nconst DAYS_IN_YEAR = [\n  365,\n  366\n  /*leap*/\n];\nconst daysInYear = (year) => DAYS_IN_YEAR[+isLeapYear(year)];\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst daysInMonth = (d) => DAYS_IN_MONTH[d.getUTCMonth()] + Number(\n  d.getUTCMonth() === 1 && isLeapYear(d.getUTCFullYear())\n);\nconst YEAR_DAYS_OFFSET = [\n  [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],\n  [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]\n  /*leap*/\n];\nconst dayOfYear = (d) => YEAR_DAYS_OFFSET[+isLeapYear(d.getUTCFullYear())][d.getUTCMonth()] + d.getUTCDate();\nconst isoWeekday = (date, startOfWeek = \"sun\") => {\n  const dow = date.getUTCDay() || 7;\n  return (dow - ISO_WEEKDAY_MAP[startOfWeek] + DAYS_PER_WEEK) % DAYS_PER_WEEK;\n};\nconst p = (y) => (y + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400)) % 7;\nconst weeks = (y) => 52 + Number(p(y) == 4 || p(y - 1) == 3);\nfunction isoWeek(d) {\n  const dow = d.getUTCDay() || 7;\n  const w = Math.floor((10 + dayOfYear(d) - dow) / 7);\n  if (w < 1) return weeks(d.getUTCFullYear() - 1);\n  if (w > weeks(d.getUTCFullYear())) return 1;\n  return w;\n}\nfunction isoWeekYear(d) {\n  return d.getUTCFullYear() - Number(d.getUTCMonth() === 0 && d.getUTCDate() == 1 && d.getUTCDay() < 1);\n}\nconst MINUTES_PER_HOUR = 60;\nconst MILLIS_PER_DAY = 1e3 * 60 * 60 * 24;\nconst TIMEUNIT_IN_MILLIS = {\n  week: MILLIS_PER_DAY * DAYS_PER_WEEK,\n  day: MILLIS_PER_DAY,\n  hour: 1e3 * 60 * 60,\n  minute: 1e3 * 60,\n  second: 1e3,\n  millisecond: 1\n};\nconst DAYS_OF_WEEK = [\n  \"monday\",\n  \"mon\",\n  \"tuesday\",\n  \"tue\",\n  \"wednesday\",\n  \"wed\",\n  \"thursday\",\n  \"thu\",\n  \"friday\",\n  \"fri\",\n  \"saturday\",\n  \"sat\",\n  \"sunday\",\n  \"sun\"\n];\nconst DAYS_OF_WEEK_SET = new Set(DAYS_OF_WEEK);\nconst ISO_WEEKDAY_MAP = Object.freeze({\n  mon: 1,\n  tue: 2,\n  wed: 3,\n  thu: 4,\n  fri: 5,\n  sat: 6,\n  sun: 7\n});\nconst DATE_FORMAT = \"%Y-%m-%dT%H:%M:%S.%LZ\";\nconst DATE_PART_INTERVAL = [\n  [\"year\", 0, 9999],\n  [\"month\", 1, 12],\n  [\"day\", 1, 31],\n  [\"hour\", 0, 23],\n  [\"minute\", 0, 59],\n  [\"second\", 0, 59],\n  [\"millisecond\", 0, 999]\n];\nconst DATE_SYM_TABLE = Object.freeze({\n  \"%Y\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%G\": { name: \"year\", padding: 4, re: /([0-9]{4})/ },\n  \"%m\": { name: \"month\", padding: 2, re: /(0[1-9]|1[012])/ },\n  \"%d\": { name: \"day\", padding: 2, re: /(0[1-9]|[12][0-9]|3[01])/ },\n  \"%H\": { name: \"hour\", padding: 2, re: /([01][0-9]|2[0-3])/ },\n  \"%M\": { name: \"minute\", padding: 2, re: /([0-5][0-9])/ },\n  \"%S\": { name: \"second\", padding: 2, re: /([0-5][0-9]|60)/ },\n  \"%L\": { name: \"millisecond\", padding: 3, re: /([0-9]{3})/ },\n  \"%u\": { name: \"weekday\", padding: 1, re: /([1-7])/ },\n  \"%U\": { name: \"week\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%V\": { name: \"isoWeek\", padding: 2, re: /([1-4][0-9]?|5[0-3]?)/ },\n  \"%z\": {\n    name: \"timezone\",\n    padding: 2,\n    re: /(([+-][01][0-9]|2[0-3]):?([0-5][0-9])?)/\n  },\n  \"%Z\": { name: \"minuteOffset\", padding: 3, re: /([+-][0-9]{3})/ }\n  // \"%%\": \"%\",\n});\nconst TIMEZONE_RE = /^[a-zA-Z_]+\\/[a-zA-Z_]+$/;\nfunction parseTimezone(tzstr) {\n  if (isNil(tzstr)) return 0;\n  if (TIMEZONE_RE.test(tzstr)) {\n    const date = /* @__PURE__ */ new Date();\n    const utcDate = new Date(date.toLocaleString(\"en-US\", { timeZone: \"UTC\" }));\n    const tzDate = new Date(date.toLocaleString(\"en-US\", { timeZone: tzstr }));\n    return (tzDate.getTime() - utcDate.getTime()) / 6e4;\n  }\n  const m = DATE_SYM_TABLE[\"%z\"].re.exec(tzstr);\n  if (!m) {\n    throw new MingoError(`Timezone '${tzstr}' is invalid or not supported`);\n  }\n  const hr = parseInt(m[2]) || 0;\n  const min = parseInt(m[3]) || 0;\n  return (Math.abs(hr * MINUTES_PER_HOUR) + min) * (hr < 0 ? -1 : 1);\n}\nfunction formatTimezone(minuteOffset) {\n  return (minuteOffset < 0 ? \"-\" : \"+\") + padDigits(Math.abs(Math.floor(minuteOffset / MINUTES_PER_HOUR)), 2) + padDigits(Math.abs(minuteOffset) % MINUTES_PER_HOUR, 2);\n}\nfunction adjustDate(d, minuteOffset) {\n  d.setUTCMinutes(d.getUTCMinutes() + minuteOffset);\n}\nfunction computeDate(obj, expr, options) {\n  if (isDate(obj)) return obj;\n  const d = computeValue(obj, expr, null, options);\n  if (isDate(d)) return new Date(d);\n  if (isNumber(d)) return new Date(d * 1e3);\n  if (d.date) {\n    const date = isDate(d.date) ? new Date(d.date) : new Date(d.date * 1e3);\n    if (d.timezone) {\n      adjustDate(date, parseTimezone(d.timezone));\n    }\n    return date;\n  }\n  throw Error(`cannot convert ${JSON.stringify(expr)} to date`);\n}\nfunction padDigits(n, digits) {\n  return new Array(Math.max(digits - String(n).length + 1, 0)).join(\"0\") + n.toString();\n}\nconst leapYearsSinceReferencePoint = (year) => {\n  const yearsSinceReferencePoint = year - LEAP_YEAR_REF_POINT;\n  return Math.trunc(yearsSinceReferencePoint / 4) - Math.trunc(yearsSinceReferencePoint / 100) + Math.trunc(yearsSinceReferencePoint / 400);\n};\nfunction daysBetweenYears(startYear, endYear) {\n  return Math.trunc(\n    leapYearsSinceReferencePoint(endYear - 1) - leapYearsSinceReferencePoint(startYear - 1) + (endYear - startYear) * DAYS_IN_YEAR[0]\n  );\n}\nconst dateDiffYear = (start, end) => end.getUTCFullYear() - start.getUTCFullYear();\nconst dateDiffMonth = (start, end) => end.getUTCMonth() - start.getUTCMonth() + dateDiffYear(start, end) * 12;\nconst dateDiffQuarter = (start, end) => {\n  const a = Math.trunc(start.getUTCMonth() / 3);\n  const b = Math.trunc(end.getUTCMonth() / 3);\n  return b - a + dateDiffYear(start, end) * 4;\n};\nconst dateDiffDay = (start, end) => dayOfYear(end) - dayOfYear(start) + daysBetweenYears(start.getUTCFullYear(), end.getUTCFullYear());\nconst dateDiffWeek = (start, end, startOfWeek) => {\n  const wk = (startOfWeek || \"sun\").substring(0, 3);\n  return Math.trunc(\n    (dateDiffDay(start, end) + isoWeekday(start, wk) - isoWeekday(end, wk)) / DAYS_PER_WEEK\n  );\n};\nconst dateDiffHour = (start, end) => end.getUTCHours() - start.getUTCHours() + dateDiffDay(start, end) * 24;\nconst addMonth = (d, amount) => {\n  const m = d.getUTCMonth() + amount;\n  const yearOffset = Math.floor(m / 12);\n  if (m < 0) {\n    const month = m % 12 + 12;\n    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, month, d.getUTCDate());\n  } else {\n    d.setUTCFullYear(d.getUTCFullYear() + yearOffset, m % 12, d.getUTCDate());\n  }\n};\nconst dateAdd = (date, unit, amount, _timezone) => {\n  const d = new Date(date);\n  switch (unit) {\n    case \"year\":\n      d.setUTCFullYear(d.getUTCFullYear() + amount);\n      break;\n    case \"quarter\":\n      addMonth(d, 3 * amount);\n      break;\n    case \"month\":\n      addMonth(d, amount);\n      break;\n    default:\n      d.setTime(d.getTime() + TIMEUNIT_IN_MILLIS[unit] * amount);\n  }\n  return d;\n};\nexport {\n  DATE_FORMAT,\n  DATE_PART_INTERVAL,\n  DATE_SYM_TABLE,\n  DAYS_OF_WEEK,\n  DAYS_OF_WEEK_SET,\n  DAYS_PER_WEEK,\n  LEAP_YEAR_REF_POINT,\n  MILLIS_PER_DAY,\n  MINUTES_PER_HOUR,\n  TIMEUNIT_IN_MILLIS,\n  adjustDate,\n  computeDate,\n  dateAdd,\n  dateDiffDay,\n  dateDiffHour,\n  dateDiffMonth,\n  dateDiffQuarter,\n  dateDiffWeek,\n  dateDiffYear,\n  dayOfYear,\n  daysBetweenYears,\n  daysInMonth,\n  daysInYear,\n  formatTimezone,\n  isLeapYear,\n  isoWeek,\n  isoWeekYear,\n  isoWeekday,\n  padDigits,\n  parseTimezone\n};\n", "import { ComputeOptions } from \"../../core\";\nimport { concat, Lazy } from \"../../lazy\";\nimport { TIME_UNITS } from \"../../types\";\nimport {\n  assert,\n  isArray,\n  isDate,\n  isNil,\n  isNumber,\n  isObject,\n  isString,\n  resolve,\n  ValueMap\n} from \"../../util\";\nimport { $dateAdd } from \"../expression/date/dateAdd\";\nimport { $sort } from \"./sort\";\nconst EMPTY_OBJECT = Object.freeze({});\nconst $densify = (collection, expr, options) => {\n  const { step, bounds, unit } = expr.range;\n  if (unit) {\n    assert(TIME_UNITS.includes(unit), \"\");\n    assert(\n      Number.isInteger(step) && step > 0,\n      \"The step parameter in a range statement must be a whole number when densifying a date range.\"\n    );\n  } else {\n    assert(\n      isNumber(step) && step > 0,\n      \"The step parameter in a range statement must be a strictly positive numeric value.\"\n    );\n  }\n  if (isArray(bounds)) {\n    assert(\n      !!bounds && bounds.length === 2,\n      \"A bounding array in a range statement must have exactly two elements.\"\n    );\n    assert(\n      (bounds.every(isNumber) || bounds.every(isDate)) && bounds[0] < bounds[1],\n      \"A bounding array must be an ascending array of either two dates or two numbers.\"\n    );\n    assert(\n      unit && !bounds.some(isNumber),\n      \"Numeric bounds may not have unit parameter.\"\n    );\n  }\n  if (expr.partitionByFields) {\n    assert(\n      isArray(expr.partitionByFields),\n      \"$densify: `partitionByFields` must be an array of strings\"\n    );\n  }\n  collection = $sort(collection, { [expr.field]: 1 }, options);\n  const nilOptions = ComputeOptions.init(options, null);\n  const computeNextValue = (value) => {\n    return isNumber(value) ? value + step : $dateAdd(\n      EMPTY_OBJECT,\n      { startDate: value, unit, amount: step },\n      nilOptions\n    );\n  };\n  const isValidUnit = !!unit && TIME_UNITS.includes(unit);\n  const getFieldValue = (o) => {\n    const v = resolve(o, expr.field);\n    if (isNil(v)) return v;\n    if (isNumber(v)) {\n      assert(\n        !isValidUnit,\n        \"$densify: Encountered non-date value in collection when step has a date unit.\"\n      );\n    } else if (isDate(v)) {\n      assert(\n        isValidUnit,\n        \"$densify: Encountered date value in collection when step does not have a date unit.\"\n      );\n    } else {\n      assert(false, \"$densify: Densify field type must be numeric or a date\");\n    }\n    return v;\n  };\n  const peekItem = new Array();\n  const nilFieldsIterator = Lazy(() => {\n    const item = collection.next();\n    const fieldValue = getFieldValue(item.value);\n    if (isNil(fieldValue)) return item;\n    peekItem.push(item);\n    return { done: true };\n  });\n  const nextDensifyValueMap = ValueMap.init(\n    options.hashFunction\n  );\n  const [lower, upper] = isArray(bounds) ? bounds : [bounds, bounds];\n  let maxFieldValue = void 0;\n  const updateMaxFieldValue = (value) => {\n    maxFieldValue = maxFieldValue === void 0 || maxFieldValue < value ? value : maxFieldValue;\n  };\n  const rootKey = [];\n  const densifyIterator = Lazy(() => {\n    const item = peekItem.length > 0 ? peekItem.pop() : collection.next();\n    if (item.done) return item;\n    let partitionKey = rootKey;\n    if (isArray(expr.partitionByFields)) {\n      partitionKey = expr.partitionByFields.map(\n        (k) => resolve(item.value, k)\n      );\n      assert(\n        partitionKey.every(isString),\n        \"$densify: Partition fields must evaluate to string values.\"\n      );\n    }\n    assert(isObject(item.value), \"$densify: collection must contain documents\");\n    const itemValue = getFieldValue(item.value);\n    if (!nextDensifyValueMap.has(partitionKey)) {\n      if (lower == \"full\") {\n        if (!nextDensifyValueMap.has(rootKey)) {\n          nextDensifyValueMap.set(rootKey, itemValue);\n        }\n        nextDensifyValueMap.set(partitionKey, nextDensifyValueMap.get(rootKey));\n      } else if (lower == \"partition\") {\n        nextDensifyValueMap.set(partitionKey, itemValue);\n      } else {\n        nextDensifyValueMap.set(partitionKey, lower);\n      }\n    }\n    const densifyValue = nextDensifyValueMap.get(partitionKey);\n    if (\n      // current item field value is lower than current densify value.\n      itemValue <= densifyValue || // range value equals or exceeds upper bound\n      upper != \"full\" && upper != \"partition\" && densifyValue >= upper\n    ) {\n      if (densifyValue <= itemValue) {\n        nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));\n      }\n      updateMaxFieldValue(itemValue);\n      return item;\n    }\n    nextDensifyValueMap.set(partitionKey, computeNextValue(densifyValue));\n    updateMaxFieldValue(densifyValue);\n    const denseObj = { [expr.field]: densifyValue };\n    if (partitionKey) {\n      partitionKey.forEach((v, i) => {\n        denseObj[expr.partitionByFields[i]] = v;\n      });\n    }\n    peekItem.push(item);\n    return { done: false, value: denseObj };\n  });\n  if (lower !== \"full\") return concat(nilFieldsIterator, densifyIterator);\n  let paritionIndex = -1;\n  let partitionKeysSet = void 0;\n  const fullBoundsIterator = Lazy(() => {\n    if (paritionIndex === -1) {\n      const fullDensifyValue = nextDensifyValueMap.get(rootKey);\n      nextDensifyValueMap.delete(rootKey);\n      partitionKeysSet = Array.from(nextDensifyValueMap.keys());\n      if (partitionKeysSet.length === 0) {\n        partitionKeysSet.push(rootKey);\n        nextDensifyValueMap.set(rootKey, fullDensifyValue);\n      }\n      paritionIndex++;\n    }\n    do {\n      const partitionKey = partitionKeysSet[paritionIndex];\n      const partitionMaxValue = nextDensifyValueMap.get(partitionKey);\n      if (partitionMaxValue < maxFieldValue) {\n        nextDensifyValueMap.set(\n          partitionKey,\n          computeNextValue(partitionMaxValue)\n        );\n        const denseObj = { [expr.field]: partitionMaxValue };\n        partitionKey.forEach((v, i) => {\n          denseObj[expr.partitionByFields[i]] = v;\n        });\n        return { done: false, value: denseObj };\n      }\n      paritionIndex++;\n    } while (paritionIndex < partitionKeysSet.length);\n    return { done: true };\n  });\n  return concat(nilFieldsIterator, densifyIterator, fullBoundsIterator);\n};\nexport {\n  $densify\n};\n", "import { groupBy, isEqual, MingoError } from \"../../util\";\nimport { $push } from \"../accumulator\";\nimport { MILLIS_PER_DAY } from \"../expression/date/_internal\";\nimport { isUnbounded } from \"../pipeline/_internal\";\nconst MILLIS_PER_UNIT = {\n  week: MILLIS_PER_DAY * 7,\n  day: MILLIS_PER_DAY,\n  hour: MILLIS_PER_DAY / 24,\n  minute: 6e4,\n  second: 1e3,\n  millisecond: 1\n};\nconst memo = /* @__PURE__ */ new WeakMap();\nfunction withMemo(collection, expr, cacheFn, fn) {\n  if (!isUnbounded(expr.parentExpr.output[expr.field].window)) {\n    return fn(cacheFn());\n  }\n  if (!memo.has(collection)) {\n    memo.set(collection, { [expr.field]: cacheFn() });\n  }\n  const data = memo.get(collection);\n  if (data[expr.field] === void 0) {\n    data[expr.field] = cacheFn();\n  }\n  let failed = false;\n  try {\n    return fn(data[expr.field]);\n  } catch {\n    failed = true;\n  } finally {\n    if (failed || expr.documentNumber === collection.length) {\n      delete data[expr.field];\n      if (Object.keys(data).length === 0) memo.delete(collection);\n    }\n  }\n}\nfunction rank(_, collection, expr, options, dense) {\n  return withMemo(\n    collection,\n    expr,\n    () => {\n      const sortKey = \"$\" + Object.keys(expr.parentExpr.sortBy)[0];\n      const values = $push(collection, sortKey, options);\n      const groups = groupBy(\n        values,\n        (_2, n) => values[n],\n        options.hashFunction\n      );\n      return { values, groups };\n    },\n    (input) => {\n      const { values, groups: partitions } = input;\n      if (partitions.size == collection.length) {\n        return expr.documentNumber;\n      }\n      const current = values[expr.documentNumber - 1];\n      let i = 0;\n      let offset = 0;\n      for (const key of partitions.keys()) {\n        if (isEqual(current, key)) {\n          return dense ? i + 1 : offset + 1;\n        }\n        i++;\n        offset += partitions.get(key).length;\n      }\n      throw new MingoError(\n        \"rank: invalid return value. please submit a bug report.\"\n      );\n    }\n  );\n}\nexport {\n  MILLIS_PER_UNIT,\n  rank,\n  withMemo\n};\n", "import {\n  computeValue\n} from \"../core\";\nimport { Query } from \"../query\";\nimport {\n  compare as mingoCmp,\n  ensureArray,\n  flatten,\n  intersection,\n  isArray,\n  isBoolean,\n  isDate,\n  isEmpty,\n  isEqual,\n  isNil,\n  isNumber,\n  isObject,\n  isOperator,\n  isRegExp,\n  isString,\n  MingoError,\n  resolve,\n  truthy,\n  typeOf\n} from \"../util\";\nfunction createQueryOperator(predicate) {\n  const f = (selector, value, options) => {\n    const opts = { unwrapArray: true };\n    const depth = Math.max(1, selector.split(\".\").length - 1);\n    return (obj) => {\n      const lhs = resolve(obj, selector, opts);\n      return predicate(lhs, value, { ...options, depth });\n    };\n  };\n  return f;\n}\nfunction createExpressionOperator(predicate) {\n  return (obj, expr, options) => {\n    const args = computeValue(obj, expr, null, options);\n    return predicate(...args);\n  };\n}\nfunction $eq(a, b, options) {\n  if (isEqual(a, b)) return true;\n  if (isNil(a) && isNil(b)) return true;\n  if (isArray(a)) {\n    return a.some((v) => isEqual(v, b)) || flatten(a, options?.depth).some((v) => isEqual(v, b));\n  }\n  return false;\n}\nfunction $ne(a, b, options) {\n  return !$eq(a, b, options);\n}\nfunction $in(a, b, options) {\n  if (isNil(a)) return b.some((v) => v === null);\n  return intersection([ensureArray(a), b], options?.hashFunction).length > 0;\n}\nfunction $nin(a, b, options) {\n  return !$in(a, b, options);\n}\nfunction $lt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) < 0);\n}\nfunction $lte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) <= 0);\n}\nfunction $gt(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) > 0);\n}\nfunction $gte(a, b, _options) {\n  return compare(a, b, (x, y) => mingoCmp(x, y) >= 0);\n}\nfunction $mod(a, b, _options) {\n  return ensureArray(a).some(\n    (x) => b.length === 2 && x % b[0] === b[1]\n  );\n}\nfunction $regex(a, b, options) {\n  const lhs = ensureArray(a);\n  const match = (x) => isString(x) && truthy(b.exec(x), options?.useStrictMode);\n  return lhs.some(match) || flatten(lhs, 1).some(match);\n}\nfunction $all(values, queries, options) {\n  if (!isArray(values) || !isArray(queries) || !values.length || !queries.length) {\n    return false;\n  }\n  let matched = true;\n  for (const query of queries) {\n    if (!matched) break;\n    if (isObject(query) && Object.keys(query).includes(\"$elemMatch\")) {\n      matched = $elemMatch(values, query[\"$elemMatch\"], options);\n    } else if (isRegExp(query)) {\n      matched = values.some((s) => typeof s === \"string\" && query.test(s));\n    } else {\n      matched = values.some((v) => isEqual(query, v));\n    }\n  }\n  return matched;\n}\nfunction $size(a, b, _options) {\n  return Array.isArray(a) && a.length === b;\n}\nfunction isNonBooleanOperator(name) {\n  return isOperator(name) && [\"$and\", \"$or\", \"$nor\"].indexOf(name) === -1;\n}\nfunction $elemMatch(a, b, options) {\n  if (isArray(a) && !isEmpty(a)) {\n    let format = (x) => x;\n    let criteria = b;\n    if (Object.keys(b).every(isNonBooleanOperator)) {\n      criteria = { temp: b };\n      format = (x) => ({ temp: x });\n    }\n    const query = new Query(criteria, options);\n    for (let i = 0, len = a.length; i < len; i++) {\n      if (query.test(format(a[i]))) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nconst isNull = (a) => a === null;\nconst compareFuncs = {\n  array: isArray,\n  boolean: isBoolean,\n  bool: isBoolean,\n  date: isDate,\n  number: isNumber,\n  int: isNumber,\n  long: isNumber,\n  double: isNumber,\n  decimal: isNumber,\n  null: isNull,\n  object: isObject,\n  regexp: isRegExp,\n  regex: isRegExp,\n  string: isString,\n  // added for completeness\n  undefined: isNil,\n  // deprecated\n  function: (_) => {\n    throw new MingoError(\"unsupported type key `function`.\");\n  },\n  // Mongo identifiers\n  1: isNumber,\n  //double\n  2: isString,\n  3: isObject,\n  4: isArray,\n  6: isNil,\n  // deprecated\n  8: isBoolean,\n  9: isDate,\n  10: isNull,\n  11: isRegExp,\n  16: isNumber,\n  //int\n  18: isNumber,\n  //long\n  19: isNumber\n  //decimal\n};\nfunction compareType(a, b, _) {\n  const f = compareFuncs[b];\n  return f ? f(a) : false;\n}\nfunction $type(a, b, options) {\n  return isArray(b) ? b.findIndex((t) => compareType(a, t, options)) >= 0 : compareType(a, b, options);\n}\nfunction compare(a, b, f) {\n  return ensureArray(a).some((x) => typeOf(x) === typeOf(b) && f(x, b));\n}\nexport {\n  $all,\n  $elemMatch,\n  $eq,\n  $gt,\n  $gte,\n  $in,\n  $lt,\n  $lte,\n  $mod,\n  $ne,\n  $nin,\n  $regex,\n  $size,\n  $type,\n  createExpressionOperator,\n  createQueryOperator\n};\n", "import { $nin as __nin, createExpressionOperator } from \"../../_predicates\";\nconst $nin = createExpressionOperator(__nin);\nexport {\n  $nin\n};\n", "import { computeValue } from \"../../../core\";\nimport { assert, isArray, isNil, isNumber } from \"../../../util\";\nconst bitwise = (op, compute) => (obj, expr, options) => {\n  assert(isArray(expr), `${op}: expression must be an array.`);\n  const nums = computeValue(obj, expr, null, options);\n  if (nums.some(isNil)) return null;\n  assert(\n    nums.every(isNumber),\n    `${op}: expression must evalue to array of numbers.`\n  );\n  return compute(nums);\n};\nexport {\n  bitwise\n};\n", "import { bitwise } from \"./_internal\";\nconst $bitAnd = bitwise(\n  \"$bitAnd\",\n  (nums) => nums.reduce((a, b) => a & b, -1)\n);\nexport {\n  $bitAnd\n};\n", "import { bitwise } from \"./_internal\";\nconst $bitOr = bitwise(\n  \"$bitOr\",\n  (nums) => nums.reduce((a, b) => a | b, 0)\n);\nexport {\n  $bitOr\n};\n", "import { bitwise } from \"./_internal\";\nconst $bitXor = bitwise(\n  \"$bitXor\",\n  (nums) => nums.reduce((a, b) => a ^ b, 0)\n);\nexport {\n  $bitXor\n};\n", "export * from \"./and\";\nexport * from \"./not\";\nexport * from \"./or\";\n", "import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $and = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  return truthy(value, options.useStrictMode) && value.every((v) => truthy(v, options.useStrictMode));\n};\nexport {\n  $and\n};\n", "import { computeValue } from \"../../../core\";\nimport { assert, ensureArray } from \"../../../util\";\nconst $not = (obj, expr, options) => {\n  const booleanExpr = ensureArray(expr);\n  if (booleanExpr.length == 0) return false;\n  assert(booleanExpr.length == 1, \"Expression $not takes exactly 1 argument\");\n  return !computeValue(obj, booleanExpr[0], null, options);\n};\nexport {\n  $not\n};\n", "import { computeValue } from \"../../../core\";\nimport { truthy } from \"../../../util\";\nconst $or = (obj, expr, options) => {\n  const value = computeValue(obj, expr, null, options);\n  const strict = options.useStrictMode;\n  return truthy(value, strict) && value.some((v) => truthy(v, strict));\n};\nexport {\n  $or\n};\n", "export * from \"./cmp\";\nexport * from \"./eq\";\nexport * from \"./gt\";\nexport * from \"./gte\";\nexport * from \"./lt\";\nexport * from \"./lte\";\nexport * from \"./ne\";\n", "import { computeValue } from \"../../../core\";\nimport { assert, compare, isArray } from \"../../../util\";\nconst $cmp = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  assert(\n    isArray(args) && args.length == 2,\n    \"$cmp: expression must resolve to array of size 2.\"\n  );\n  return compare(args[0], args[1]);\n};\nexport {\n  $cmp\n};\n", "import { $eq as __eq, createExpressionOperator } from \"../../_predicates\";\nconst $eq = createExpressionOperator(__eq);\nexport {\n  $eq\n};\n", "import { $gt as __gt, createExpressionOperator } from \"../../_predicates\";\nconst $gt = createExpressionOperator(__gt);\nexport {\n  $gt\n};\n", "import { $gte as __gte, createExpressionOperator } from \"../../_predicates\";\nconst $gte = createExpressionOperator(__gte);\nexport {\n  $gte\n};\n", "import { $lt as __lt, createExpressionOperator } from \"../../_predicates\";\nconst $lt = createExpressionOperator(__lt);\nexport {\n  $lt\n};\n", "import { $lte as __lte, createExpressionOperator } from \"../../_predicates\";\nconst $lte = createExpressionOperator(__lte);\nexport {\n  $lte\n};\n", "import { $ne as __ne, createExpressionOperator } from \"../../_predicates\";\nconst $ne = createExpressionOperator(__ne);\nexport {\n  $ne\n};\n", "import { computeValue } from \"../../../core\";\nimport { assert, isNil, isObject } from \"../../../util\";\nimport {\n  adjustDate,\n  DATE_FORMAT,\n  DATE_SYM_TABLE,\n  MINUTES_PER_HOUR,\n  parseTimezone\n} from \"./_internal\";\nconst buildMap = (letters, sign) => {\n  const h = {};\n  letters.split(\"\").forEach((v, i) => h[v] = sign * (i + 1));\n  return h;\n};\nconst TZ_LETTER_OFFSETS = {\n  ...buildMap(\"ABCDEFGHIKLM\", 1),\n  ...buildMap(\"NOPQRSTUVWXY\", -1),\n  Z: 0\n};\nconst regexStrip = (s) => s.replace(/^\\//, \"\").replace(/\\/$/, \"\");\nconst REGEX_SPECIAL_CHARS = [\"^\", \".\", \"-\", \"*\", \"?\", \"$\"];\nconst regexQuote = (s) => {\n  REGEX_SPECIAL_CHARS.forEach((c) => {\n    s = s.replace(c, `\\\\${c}`);\n  });\n  return s;\n};\nconst $dateFromString = (obj, expr, options) => {\n  const args = computeValue(obj, expr, null, options);\n  args.format = args.format || DATE_FORMAT;\n  args.onNull = args.onNull || null;\n  let dateString = args.dateString;\n  if (isNil(dateString)) return args.onNull;\n  const separators = args.format.split(/%[YGmdHMSLuVzZ]/);\n  separators.reverse();\n  const matches = args.format.match(\n    /(%%|%Y|%G|%m|%d|%H|%M|%S|%L|%u|%V|%z|%Z)/g\n  );\n  const dateParts = {};\n  let expectedPattern = \"\";\n  for (let i = 0, len = matches.length; i < len; i++) {\n    const formatSpecifier = matches[i];\n    const props = DATE_SYM_TABLE[formatSpecifier];\n    if (isObject(props)) {\n      const m2 = props.re.exec(dateString);\n      const delimiter = separators.pop() || \"\";\n      if (m2 !== null) {\n        dateParts[props.name] = /^\\d+$/.exec(m2[0]) ? parseInt(m2[0]) : m2[0];\n        dateString = dateString.substr(0, m2.index) + dateString.substr(m2.index + m2[0].length);\n        expectedPattern += regexQuote(delimiter) + regexStrip(props.re.toString());\n      } else {\n        dateParts[props.name] = null;\n      }\n    }\n  }\n  if (isNil(dateParts.year) || isNil(dateParts.month) || isNil(dateParts.day) || !new RegExp(\"^\" + expectedPattern + \"[A-Z]?$\").exec(args.dateString)) {\n    return args.onError;\n  }\n  const m = args.dateString.match(/([A-Z])$/);\n  assert(\n    // only one of in-date timeone or timezone argument but not both.\n    !(m && args.timezone),\n    `$dateFromString: you cannot pass in a date/time string with time zone information ('${m && m[0]}') together with a timezone argument`\n  );\n  const minuteOffset = m ? TZ_LETTER_OFFSETS[m[0]] * MINUTES_PER_HOUR : parseTimezone(args.timezone);\n  const d = new Date(\n    Date.UTC(dateParts.year, dateParts.month - 1, dateParts.day, 0, 0, 0)\n  );\n  if (!isNil(dateParts.hour)) d.setUTCHours(dateParts.hour);\n  if (!isNil(dateParts.minute)) d.setUTCMinutes(dateParts.minute);\n  if (!isNil(dateParts.second)) d.setUTCSeconds(dateParts.second);\n  if (!isNil(dateParts.millisecond))\n    d.setUTCMilliseconds(dateParts.millisecond);\n  adjustDate(d, -minuteOffset);\n  return d;\n};\nexport {\n  $dateFromString\n};\n", "import { computeValue } from \"../../../core\";\nimport { MingoError } from \"../../../util\";\nconst FIXED_POINTS = {\n  undefined: null,\n  null: null,\n  NaN: NaN,\n  Infinity: new Error(),\n  \"-Infinity\": new Error()\n};\nfunction createTrignometryOperator(f, fixedPoints = FIXED_POINTS) {\n  const fp = Object.assign({}, FIXED_POINTS, fixedPoints);\n  const keySet = new Set(Object.keys(fp));\n  return (obj, expr, options) => {\n    const n = computeValue(obj, expr, null, options);\n    if (keySet.has(`${n}`)) {\n      const res = fp[`${n}`];\n      if (res instanceof Error) {\n        throw new MingoError(\n          `cannot apply $${f.name} to -inf, value must in (-inf,inf)`\n        );\n      }\n      return res;\n    }\n    return f(n);\n  };\n}\nexport {\n  createTrignometryOperator\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $acos = createTrignometryOperator(Math.acos, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acos\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $acosh = createTrignometryOperator(Math.acosh, {\n  Infinity: Infinity,\n  0: new Error()\n});\nexport {\n  $acosh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $asin = createTrignometryOperator(Math.asin);\nexport {\n  $asin\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $asinh = createTrignometryOperator(Math.asinh, {\n  Infinity: Infinity,\n  \"-Infinity\": -Infinity\n});\nexport {\n  $asinh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $atan = createTrignometryOperator(Math.atan);\nexport {\n  $atan\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $atanh = createTrignometryOperator(Math.atanh, {\n  1: Infinity,\n  \"-1\": -Infinity\n});\nexport {\n  $atanh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $cos = createTrignometryOperator(Math.cos);\nexport {\n  $cos\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $cosh = createTrignometryOperator(Math.cosh, {\n  \"-Infinity\": Infinity,\n  Infinity: Infinity\n});\nexport {\n  $cosh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst RADIANS_FACTOR = Math.PI / 180;\nconst $degreesToRadians = createTrignometryOperator(\n  (n) => n * RADIANS_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": Infinity\n  }\n);\nexport {\n  $degreesToRadians\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst DEGREES_FACTOR = 180 / Math.PI;\nconst $radiansToDegrees = createTrignometryOperator(\n  (n) => n * DEGREES_FACTOR,\n  {\n    Infinity: Infinity,\n    \"-Infinity\": -Infinity\n  }\n);\nexport {\n  $radiansToDegrees\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $sin = createTrignometryOperator(Math.sin);\nexport {\n  $sin\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $sinh = createTrignometryOperator(Math.sinh, {\n  \"-Infinity\": -Infinity,\n  Infinity: Infinity\n});\nexport {\n  $sinh\n};\n", "import { createTrignometryOperator } from \"./_internal\";\nconst $tan = createTrignometryOperator(Math.tan);\nexport {\n  $tan\n};\n", "import { computeValue } from \"../../../core\";\nimport { isDate, isNil, isNumber, isString } from \"../../../util\";\nconst MAX_INT = 2147483647;\nconst MIN_INT = -2147483648;\nconst MAX_LONG = Number.MAX_SAFE_INTEGER;\nconst MIN_LONG = Number.MIN_SAFE_INTEGER;\nclass TypeConvertError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nfunction toInteger(obj, expr, options, min, max) {\n  const val = computeValue(obj, expr, null, options);\n  if (val === true) return 1;\n  if (val === false) return 0;\n  if (isNil(val)) return null;\n  if (isDate(val)) return val.getTime();\n  const n = Number(val);\n  if (isNumber(n) && n >= min && n <= max) {\n    if (!isString(val) || n.toString().indexOf(\".\") === -1) {\n      return Math.trunc(n);\n    }\n  }\n  throw new TypeConvertError(\n    `cannot convert '${val}' to ${max == MAX_INT ? \"int\" : \"long\"}`\n  );\n}\nexport {\n  MAX_INT,\n  MAX_LONG,\n  MIN_INT,\n  MIN_LONG,\n  TypeConvertError,\n  toInteger\n};\n", "import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $and = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression: $and expects value to be an Array.\"\n  );\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.every((q) => q.test(obj));\n};\nexport {\n  $and\n};\n", "import { Query } from \"../../../query\";\nimport { assert, isArray } from \"../../../util\";\nconst $or = (_, rhs, options) => {\n  assert(isArray(rhs), \"Invalid expression. $or expects value to be an Array\");\n  const queries = rhs.map((expr) => new Query(expr, options));\n  return (obj) => queries.some((q) => q.test(obj));\n};\nexport {\n  $or\n};\n", "import { assert, isArray } from \"../../../util\";\nimport { $or } from \"./or\";\nconst $nor = (_, rhs, options) => {\n  assert(\n    isArray(rhs),\n    \"Invalid expression. $nor expects value to be an array.\"\n  );\n  const f = $or(\"$or\", rhs, options);\n  return (obj) => !f(obj);\n};\nexport {\n  $nor\n};\n", "import { Query } from \"../../../query\";\nimport { normalize } from \"../../../util\";\nconst $not = (selector, rhs, options) => {\n  const criteria = {};\n  criteria[selector] = normalize(rhs);\n  const query = new Query(criteria, options);\n  return (obj) => !query.test(obj);\n};\nexport {\n  $not\n};\n", "import { $eq as __eq, createQueryOperator } from \"../../_predicates\";\nconst $eq = createQueryOperator(__eq);\nexport {\n  $eq\n};\n", "import { $gt as __gt, createQueryOperator } from \"../../_predicates\";\nconst $gt = createQueryOperator(__gt);\nexport {\n  $gt\n};\n", "import { $gte as __gte, createQueryOperator } from \"../../_predicates\";\nconst $gte = createQueryOperator(__gte);\nexport {\n  $gte\n};\n", "import { $in as __in, createQueryOperator } from \"../../_predicates\";\nconst $in = createQueryOperator(__in);\nexport {\n  $in\n};\n", "import { $lt as __lt, createQueryOperator } from \"../../_predicates\";\nconst $lt = createQueryOperator(__lt);\nexport {\n  $lt\n};\n", "import { $lte as __lte, createQueryOperator } from \"../../_predicates\";\nconst $lte = createQueryOperator(__lte);\nexport {\n  $lte\n};\n", "import { $ne as __ne, createQueryOperator } from \"../../_predicates\";\nconst $ne = createQueryOperator(__ne);\nexport {\n  $ne\n};\n", "import { $nin as __nin, createQueryOperator } from \"../../_predicates\";\nconst $nin = createQueryOperator(__nin);\nexport {\n  $nin\n};\n", "import { computeValue } from \"../../../core\";\nfunction $expr(_, rhs, options) {\n  return (obj) => computeValue(obj, rhs, null, options);\n}\nexport {\n  $expr\n};\n", "import { MingoError } from \"../../../util\";\nfunction $jsonSchema(_, schema, options) {\n  if (!options?.jsonSchemaValidator) {\n    throw new MingoError(\n      \"Missing option 'jsonSchemaValidator'. Configure to use '$jsonSchema' operator.\"\n    );\n  }\n  const validate = options?.jsonSchemaValidator(schema);\n  return (obj) => validate(obj);\n}\nexport {\n  $jsonSchema\n};\n", "import { $mod as __mod, createQueryOperator } from \"../../_predicates\";\nconst $mod = createQueryOperator(__mod);\nexport {\n  $mod\n};\n", "import { $regex as __regex, createQueryOperator } from \"../../_predicates\";\nconst $regex = createQueryOperator(__regex);\nexport {\n  $regex\n};\n", "import { assert, isFunction, truthy } from \"../../../util\";\nfunction $where(_, rhs, options) {\n  assert(\n    options.scriptEnabled,\n    \"$where operator requires 'scriptEnabled' option to be true\"\n  );\n  const f = rhs;\n  assert(isFunction(f), \"$where only accepts a Function object\");\n  return (obj) => truthy(f.call(obj), options?.useStrictMode);\n}\nexport {\n  $where\n};\n", "import { $all as __all, createQueryOperator } from \"../../_predicates\";\nconst $all = createQueryOperator(__all);\nexport {\n  $all\n};\n", "import {\n  $elemMatch as __elemMatch,\n  createQueryOperator\n} from \"../../_predicates\";\nconst $elemMatch = createQueryOperator(__elemMatch);\nexport {\n  $elemMatch\n};\n", "import { $size as __size, createQueryOperator } from \"../../_predicates\";\nconst $size = createQueryOperator(__size);\nexport {\n  $size\n};\n", "import { isArray, resolve, resolveGraph } from \"../../../util\";\nconst $exists = (selector, value, _options) => {\n  const nested = selector.includes(\".\");\n  const b = !!value;\n  if (!nested || selector.match(/\\.\\d+$/)) {\n    return (o) => resolve(o, selector) !== void 0 === b;\n  }\n  return (o) => {\n    const path = resolveGraph(o, selector, { preserveIndex: true });\n    const val = resolve(path, selector.substring(0, selector.lastIndexOf(\".\")));\n    return isArray(val) ? val.some((v) => v !== void 0) === b : val !== void 0 === b;\n  };\n};\nexport {\n  $exists\n};\n", "import { $type as __type, createQueryOperator } from \"../../_predicates\";\nconst $type = createQueryOperator(__type);\nexport {\n  $type\n};\n", "import { useOperators } from 'mingo/core';\nimport { Query } from 'mingo/query';\nimport type { MangoQuerySelector } from './types/index.d.ts';\nimport {\n    $project,\n    $sort\n} from 'mingo/operators/pipeline';\nimport {\n    $and,\n    $not,\n    $or,\n    $nor\n} from 'mingo/operators/query/logical';\nimport {\n    $eq,\n    $ne,\n    $gt,\n    $gte,\n    $lt,\n    $lte,\n    $nin,\n    $in\n} from 'mingo/operators/query/comparison';\nimport {\n    $regex,\n    $mod\n} from 'mingo/operators/query/evaluation';\nimport {\n    $elemMatch,\n    $size\n} from 'mingo/operators/query/array';\nimport {\n    $exists,\n    $type\n} from 'mingo/operators/query/element';\n\nlet mingoInitDone = false;\n\n\n/**\n * The MongoDB query library is huge and we do not need all the operators.\n * If you add an operator here, make sure that you properly add a test in\n * the file /test/unit/rx-storage-query-correctness.test.ts\n *\n * @link https://github.com/kofrasa/mingo#es6\n */\nexport function getMingoQuery<RxDocType>(\n    selector?: MangoQuerySelector<RxDocType>\n) {\n    if (!mingoInitDone) {\n        useOperators('pipeline', {\n            $sort,\n            $project\n        } as any);\n        useOperators('query', {\n            $and,\n            $eq,\n            $elemMatch,\n            $exists,\n            $gt,\n            $gte,\n            $in,\n            $lt,\n            $lte,\n            $ne,\n            $nin,\n            $mod,\n            $nor,\n            $not,\n            $or,\n            $regex,\n            $size,\n            $type,\n        } as any);\n        mingoInitDone = true;\n    }\n    return new Query(selector as any);\n}\n", "import { LOGICAL_OPERATORS, getQueryPlan } from './query-planner.ts';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper.ts';\nimport type {\n    DeepReadonly,\n    DeterministicSortComparator,\n    FilledMangoQuery,\n    MangoQuery,\n    MangoQuerySortDirection,\n    PreparedQuery,\n    QueryMatcher,\n    RxDocument,\n    RxDocumentData,\n    RxJsonSchema,\n    RxQuery\n} from './types/index.d.ts';\nimport {\n    clone,\n    firstPropertyNameOfObject,\n    toArray,\n    isMaybeReadonlyArray,\n    flatClone,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './plugins/utils/index.ts';\nimport {\n    compare as mingoSortComparator\n} from 'mingo/util';\nimport { newRxError } from './rx-error.ts';\nimport { getMingoQuery } from './rx-query-mingo.ts';\n\n/**\n * Normalize the query to ensure we have all fields set\n * and queries that represent the same query logic are detected as equal by the caching.\n */\nexport function normalizeMangoQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mangoQuery: MangoQuery<RxDocType>\n): FilledMangoQuery<RxDocType> {\n    const primaryKey: string = getPrimaryFieldOfPrimaryKey(schema.primaryKey);\n    mangoQuery = flatClone(mangoQuery);\n\n    const normalizedMangoQuery: FilledMangoQuery<RxDocType> = clone(mangoQuery) as any;\n    if (typeof normalizedMangoQuery.skip !== 'number') {\n        normalizedMangoQuery.skip = 0;\n    }\n\n    if (!normalizedMangoQuery.selector) {\n        normalizedMangoQuery.selector = {};\n    } else {\n        normalizedMangoQuery.selector = normalizedMangoQuery.selector;\n        /**\n         * In mango query, it is possible to have an\n         * equals comparison by directly assigning a value\n         * to a property, without the '$eq' operator.\n         * Like:\n         * selector: {\n         *   foo: 'bar'\n         * }\n         * For normalization, we have to normalize this\n         * so our checks can perform properly.\n         *\n         *\n         * TODO this must work recursive with nested queries that\n         * contain multiple selectors via $and or $or etc.\n         */\n        Object\n            .entries(normalizedMangoQuery.selector)\n            .forEach(([field, matcher]) => {\n                if (typeof matcher !== 'object' || matcher === null) {\n                    (normalizedMangoQuery as any).selector[field] = {\n                        $eq: matcher\n                    };\n                }\n            });\n    }\n\n    /**\n     * Ensure that if an index is specified,\n     * the primaryKey is inside of it.\n     */\n    if (normalizedMangoQuery.index) {\n        const indexAr = toArray(normalizedMangoQuery.index);\n        if (!indexAr.includes(primaryKey)) {\n            indexAr.push(primaryKey);\n        }\n        normalizedMangoQuery.index = indexAr;\n    }\n\n    /**\n     * To ensure a deterministic sorting,\n     * we have to ensure the primary key is always part\n     * of the sort query.\n     * Primary sorting is added as last sort parameter,\n     * similar to how we add the primary key to indexes that do not have it.\n     *\n     */\n    if (!normalizedMangoQuery.sort) {\n        /**\n         * If no sort is given at all,\n         * we can assume that the user does not care about sort order at al.\n         *\n         * we cannot just use the primary key as sort parameter\n         * because it would likely cause the query to run over the primary key index\n         * which has a bad performance in most cases.\n         */\n        if (normalizedMangoQuery.index) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.index.map((field: string) => {\n                return { [field as any]: 'asc' } as any;\n            });\n        } else {\n            /**\n             * Find the index that best matches the fields with the logical operators\n             */\n            if (schema.indexes) {\n                const fieldsWithLogicalOperator: Set<string> = new Set();\n                Object.entries(normalizedMangoQuery.selector).forEach(([field, matcher]) => {\n                    let hasLogical = false;\n                    if (typeof matcher === 'object' && matcher !== null) {\n                        hasLogical = !!Object.keys(matcher).find(operator => LOGICAL_OPERATORS.has(operator));\n                    } else {\n                        hasLogical = true;\n                    }\n                    if (hasLogical) {\n                        fieldsWithLogicalOperator.add(field);\n                    }\n                });\n\n\n                let currentFieldsAmount = -1;\n                let currentBestIndexForSort: string[] | readonly string[] | undefined;\n                schema.indexes.forEach(index => {\n                    const useIndex = isMaybeReadonlyArray(index) ? index : [index];\n                    const firstWrongIndex = useIndex.findIndex(indexField => !fieldsWithLogicalOperator.has(indexField));\n                    if (\n                        firstWrongIndex > 0 &&\n                        firstWrongIndex > currentFieldsAmount\n                    ) {\n                        currentFieldsAmount = firstWrongIndex;\n                        currentBestIndexForSort = useIndex;\n                    }\n                });\n                if (currentBestIndexForSort) {\n                    normalizedMangoQuery.sort = currentBestIndexForSort.map((field: string) => {\n                        return { [field as any]: 'asc' } as any;\n                    });\n                }\n\n            }\n\n            /**\n             * If no good index was found as default sort-order,\n             * just use the first index of the schema.\n             * If no index is in the schema, use the default-index which\n             * is created by RxDB ONLY if there is no other index defined.\n             */\n            if (!normalizedMangoQuery.sort) {\n                if (schema.indexes && schema.indexes.length > 0) {\n                    const firstIndex = schema.indexes[0];\n                    const useIndex = isMaybeReadonlyArray(firstIndex) ? firstIndex : [firstIndex];\n                    normalizedMangoQuery.sort = useIndex.map(field => ({ [field]: 'asc' })) as any;\n                } else {\n                    normalizedMangoQuery.sort = [{ [primaryKey]: 'asc' }] as any;\n                }\n            }\n        }\n    } else {\n        const isPrimaryInSort = normalizedMangoQuery.sort\n            .find(p => firstPropertyNameOfObject(p) === primaryKey);\n        if (!isPrimaryInSort) {\n            normalizedMangoQuery.sort = normalizedMangoQuery.sort.slice(0);\n            normalizedMangoQuery.sort.push({ [primaryKey]: 'asc' } as any);\n        }\n    }\n\n    return normalizedMangoQuery;\n}\n\n/**\n * Returns the sort-comparator,\n * which is able to sort documents in the same way\n * a query over the db would do.\n */\nexport function getSortComparator<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): DeterministicSortComparator<RxDocType> {\n    if (!query.sort) {\n        throw newRxError('SNH', { query });\n    }\n    const sortParts: {\n        key: string;\n        direction: MangoQuerySortDirection;\n        getValueFn: ObjectPathMonadFunction<RxDocType>;\n    }[] = [];\n    query.sort.forEach(sortBlock => {\n        const key = Object.keys(sortBlock)[0];\n        const direction = Object.values(sortBlock)[0];\n        sortParts.push({\n            key,\n            direction,\n            getValueFn: objectPathMonad(key)\n        });\n    });\n    const fun: DeterministicSortComparator<RxDocType> = (a: RxDocType, b: RxDocType) => {\n        for (let i = 0; i < sortParts.length; ++i) {\n            const sortPart = sortParts[i];\n            const valueA = sortPart.getValueFn(a);\n            const valueB = sortPart.getValueFn(b);\n            if (valueA !== valueB) {\n                const ret = sortPart.direction === 'asc' ? mingoSortComparator(valueA, valueB) : mingoSortComparator(valueB, valueA);\n                return ret as any;\n            }\n        }\n    };\n\n    return fun;\n}\n\n\n/**\n * Returns a function\n * that can be used to check if a document\n * matches the query.\n */\nexport function getQueryMatcher<RxDocType>(\n    _schema: RxJsonSchema<RxDocType> | RxJsonSchema<RxDocumentData<RxDocType>>,\n    query: FilledMangoQuery<RxDocType>\n): QueryMatcher<RxDocumentData<RxDocType>> {\n    if (!query.sort) {\n        throw newRxError('SNH', { query });\n    }\n\n    const mingoQuery = getMingoQuery(query.selector as any);\n    const fun: QueryMatcher<RxDocumentData<RxDocType>> = (doc: RxDocumentData<RxDocType> | DeepReadonly<RxDocumentData<RxDocType>>) => {\n        return mingoQuery.test(doc);\n    };\n    return fun;\n}\n\n\nexport async function runQueryUpdateFunction<RxDocType, RxQueryResult>(\n    rxQuery: RxQuery<RxDocType, RxQueryResult>,\n    fn: (doc: RxDocument<RxDocType>) => Promise<RxDocument<RxDocType>>\n): Promise<RxQueryResult> {\n    const docs = await rxQuery.exec();\n    if (!docs) {\n        // only findOne() queries can return null\n        return null as any;\n    }\n    if (Array.isArray(docs)) {\n        return Promise.all(\n            docs.map(doc => fn(doc))\n        ) as any;\n    } else if (docs instanceof Map) {\n        return Promise.all(\n            [...docs.values()].map((doc) => fn(doc))\n        ) as any;\n    } else {\n        // via findOne()\n        const result = await fn(docs as any);\n        return result as any;\n    }\n}\n\n/**\n * @returns a format of the query that can be used with the storage\n * when calling RxStorageInstance().query()\n */\nexport function prepareQuery<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    mutateableQuery: FilledMangoQuery<RxDocType>\n): PreparedQuery<RxDocType> {\n    if (!mutateableQuery.sort) {\n        throw newRxError('SNH', {\n            query: mutateableQuery\n        });\n    }\n\n    /**\n     * Store the query plan together with the\n     * prepared query to save performance.\n     */\n    const queryPlan = getQueryPlan(\n        schema,\n        mutateableQuery\n    );\n\n    return {\n        query: mutateableQuery,\n        queryPlan\n    };\n}\n"],
  "mappings": "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AA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,KAAK;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,MAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF,CAAC;;;AChnBD,IAAM,gBAAgB;AAmCtB,IAAM,iBAAiB,MAAM,KAAK,KAAK;AACvC,IAAM,qBAAqB;AAAA,EACzB,MAAM,iBAAiB;AAAA,EACvB,KAAK;AAAA,EACL,MAAM,MAAM,KAAK;AAAA,EACjB,QAAQ,MAAM;AAAA,EACd,QAAQ;AAAA,EACR,aAAa;AACf;AACA,IAAM,eAAe;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AACA,IAAM,mBAAmB,IAAI,IAAI,YAAY;AAC7C,IAAM,kBAAkB,OAAO,OAAO;AAAA,EACpC,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AACP,CAAC;AAWD,IAAM,iBAAiB,OAAO,OAAO;AAAA,EACnC,MAAM,EAAE,MAAM,QAAQ,SAAS,GAAG,IAAI,aAAa;AAAA,EACnD,MAAM,EAAE,MAAM,QAAQ,SAAS,GAAG,IAAI,aAAa;AAAA,EACnD,MAAM,EAAE,MAAM,SAAS,SAAS,GAAG,IAAI,kBAAkB;AAAA,EACzD,MAAM,EAAE,MAAM,OAAO,SAAS,GAAG,IAAI,2BAA2B;AAAA,EAChE,MAAM,EAAE,MAAM,QAAQ,SAAS,GAAG,IAAI,qBAAqB;AAAA,EAC3D,MAAM,EAAE,MAAM,UAAU,SAAS,GAAG,IAAI,eAAe;AAAA,EACvD,MAAM,EAAE,MAAM,UAAU,SAAS,GAAG,IAAI,kBAAkB;AAAA,EAC1D,MAAM,EAAE,MAAM,eAAe,SAAS,GAAG,IAAI,aAAa;AAAA,EAC1D,MAAM,EAAE,MAAM,WAAW,SAAS,GAAG,IAAI,UAAU;AAAA,EACnD,MAAM,EAAE,MAAM,QAAQ,SAAS,GAAG,IAAI,wBAAwB;AAAA,EAC9D,MAAM,EAAE,MAAM,WAAW,SAAS,GAAG,IAAI,wBAAwB;AAAA,EACjE,MAAM;AAAA,IACJ,MAAM;AAAA,IACN,SAAS;AAAA,IACT,IAAI;AAAA,EACN;AAAA,EACA,MAAM,EAAE,MAAM,gBAAgB,SAAS,GAAG,IAAI,iBAAiB;AAAA;AAEjE,CAAC;;;ACtFD,IAAM,eAAe,OAAO,OAAO,CAAC,CAAC;;;ACZrC,IAAM,kBAAkB;AAAA,EACtB,MAAM,iBAAiB;AAAA,EACvB,KAAK;AAAA,EACL,MAAM,iBAAiB;AAAA,EACvB,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,aAAa;AACf;;;ACcA,SAAS,oBAAoB,WAAW;AACtC,QAAM,IAAI,CAAC,UAAU,OAAO,YAAY;AACtC,UAAM,OAAO,EAAE,aAAa,KAAK;AACjC,UAAM,QAAQ,KAAK,IAAI,GAAG,SAAS,MAAM,GAAG,EAAE,SAAS,CAAC;AACxD,WAAO,CAAC,QAAQ;AACd,YAAM,MAAM,QAAQ,KAAK,UAAU,IAAI;AACvC,aAAO,UAAU,KAAK,OAAO,EAAE,GAAG,SAAS,MAAM,CAAC;AAAA,IACpD;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,yBAAyB,WAAW;AAC3C,SAAO,CAAC,KAAK,MAAM,YAAY;AAC7B,UAAM,OAAO,aAAa,KAAK,MAAM,MAAM,OAAO;AAClD,WAAO,UAAU,GAAG,IAAI;AAAA,EAC1B;AACF;AACA,SAAS,IAAI,GAAG,GAAG,SAAS;AAC1B,MAAI,QAAQ,GAAG,CAAC;AAAG,WAAO;AAC1B,MAAI,MAAM,CAAC,KAAK,MAAM,CAAC;AAAG,WAAO;AACjC,MAAI,QAAQ,CAAC,GAAG;AACd,WAAO,EAAE,KAAK,CAAC,MAAM,QAAQ,GAAG,CAAC,CAAC,KAAK,QAAQ,GAAG,mCAAS,KAAK,EAAE,KAAK,CAAC,MAAM,QAAQ,GAAG,CAAC,CAAC;AAAA,EAC7F;AACA,SAAO;AACT;AACA,SAAS,IAAI,GAAG,GAAG,SAAS;AAC1B,SAAO,CAAC,IAAI,GAAG,GAAG,OAAO;AAC3B;AACA,SAAS,IAAI,GAAG,GAAG,SAAS;AAC1B,MAAI,MAAM,CAAC;AAAG,WAAO,EAAE,KAAK,CAAC,MAAM,MAAM,IAAI;AAC7C,SAAO,aAAa,CAAC,YAAY,CAAC,GAAG,CAAC,GAAG,mCAAS,YAAY,EAAE,SAAS;AAC3E;AACA,SAAS,KAAK,GAAG,GAAG,SAAS;AAC3B,SAAO,CAAC,IAAI,GAAG,GAAG,OAAO;AAC3B;AACA,SAAS,IAAI,GAAG,GAAGC,WAAU;AAC3B,SAAOC,SAAQ,GAAG,GAAG,CAAC,GAAG,MAAM,QAAS,GAAG,CAAC,IAAI,CAAC;AACnD;AACA,SAAS,KAAK,GAAG,GAAGD,WAAU;AAC5B,SAAOC,SAAQ,GAAG,GAAG,CAAC,GAAG,MAAM,QAAS,GAAG,CAAC,KAAK,CAAC;AACpD;AACA,SAAS,IAAI,GAAG,GAAGD,WAAU;AAC3B,SAAOC,SAAQ,GAAG,GAAG,CAAC,GAAG,MAAM,QAAS,GAAG,CAAC,IAAI,CAAC;AACnD;AACA,SAAS,KAAK,GAAG,GAAGD,WAAU;AAC5B,SAAOC,SAAQ,GAAG,GAAG,CAAC,GAAG,MAAM,QAAS,GAAG,CAAC,KAAK,CAAC;AACpD;AACA,SAAS,KAAK,GAAG,GAAGD,WAAU;AAC5B,SAAO,YAAY,CAAC,EAAE;AAAA,IACpB,CAAC,MAAM,EAAE,WAAW,KAAK,IAAI,EAAE,CAAC,MAAM,EAAE,CAAC;AAAA,EAC3C;AACF;AACA,SAAS,OAAO,GAAG,GAAG,SAAS;AAC7B,QAAM,MAAM,YAAY,CAAC;AACzB,QAAM,QAAQ,CAAC,MAAM,SAAS,CAAC,KAAK,OAAO,EAAE,KAAK,CAAC,GAAG,mCAAS,aAAa;AAC5E,SAAO,IAAI,KAAK,KAAK,KAAK,QAAQ,KAAK,CAAC,EAAE,KAAK,KAAK;AACtD;AACA,SAAS,KAAK,QAAQ,SAAS,SAAS;AACtC,MAAI,CAAC,QAAQ,MAAM,KAAK,CAAC,QAAQ,OAAO,KAAK,CAAC,OAAO,UAAU,CAAC,QAAQ,QAAQ;AAC9E,WAAO;AAAA,EACT;AACA,MAAI,UAAU;AACd,aAAW,SAAS,SAAS;AAC3B,QAAI,CAAC;AAAS;AACd,QAAI,SAAS,KAAK,KAAK,OAAO,KAAK,KAAK,EAAE,SAAS,YAAY,GAAG;AAChE,gBAAU,WAAW,QAAQ,MAAM,YAAY,GAAG,OAAO;AAAA,IAC3D,WAAW,SAAS,KAAK,GAAG;AAC1B,gBAAU,OAAO,KAAK,CAAC,MAAM,OAAO,MAAM,YAAY,MAAM,KAAK,CAAC,CAAC;AAAA,IACrE,OAAO;AACL,gBAAU,OAAO,KAAK,CAAC,MAAM,QAAQ,OAAO,CAAC,CAAC;AAAA,IAChD;AAAA,EACF;AACA,SAAO;AACT;AACA,SAAS,MAAM,GAAG,GAAGA,WAAU;AAC7B,SAAO,MAAM,QAAQ,CAAC,KAAK,EAAE,WAAW;AAC1C;AACA,SAAS,qBAAqB,MAAM;AAClC,SAAO,WAAW,IAAI,KAAK,CAAC,QAAQ,OAAO,MAAM,EAAE,QAAQ,IAAI,MAAM;AACvE;AACA,SAAS,WAAW,GAAG,GAAG,SAAS;AACjC,MAAI,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG;AAC7B,QAAI,SAAS,CAAC,MAAM;AACpB,QAAI,WAAW;AACf,QAAI,OAAO,KAAK,CAAC,EAAE,MAAM,oBAAoB,GAAG;AAC9C,iBAAW,EAAE,MAAM,EAAE;AACrB,eAAS,CAAC,OAAO,EAAE,MAAM,EAAE;AAAA,IAC7B;AACA,UAAM,QAAQ,IAAI,MAAM,UAAU,OAAO;AACzC,aAAS,IAAI,GAAG,MAAM,EAAE,QAAQ,IAAI,KAAK,KAAK;AAC5C,UAAI,MAAM,KAAK,OAAO,EAAE,CAAC,CAAC,CAAC,GAAG;AAC5B,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAM,SAAS,CAAC,MAAM,MAAM;AAC5B,IAAM,eAAe;AAAA,EACnB,OAAO;AAAA,EACP,SAAS;AAAA,EACT,MAAM;AAAA,EACN,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,KAAK;AAAA,EACL,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,OAAO;AAAA,EACP,QAAQ;AAAA;AAAA,EAER,WAAW;AAAA;AAAA,EAEX,UAAU,CAAC,MAAM;AACf,UAAM,IAAI,WAAW,kCAAkC;AAAA,EACzD;AAAA;AAAA,EAEA,GAAG;AAAA;AAAA,EAEH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,GAAG;AAAA;AAAA,EAEH,GAAG;AAAA,EACH,GAAG;AAAA,EACH,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA;AAAA,EAEJ,IAAI;AAAA;AAAA,EAEJ,IAAI;AAAA;AAEN;AACA,SAAS,YAAY,GAAG,GAAG,GAAG;AAC5B,QAAM,IAAI,aAAa,CAAC;AACxB,SAAO,IAAI,EAAE,CAAC,IAAI;AACpB;AACA,SAAS,MAAM,GAAG,GAAG,SAAS;AAC5B,SAAO,QAAQ,CAAC,IAAI,EAAE,UAAU,CAAC,MAAM,YAAY,GAAG,GAAG,OAAO,CAAC,KAAK,IAAI,YAAY,GAAG,GAAG,OAAO;AACrG;AACA,SAASC,SAAQ,GAAG,GAAG,GAAG;AACxB,SAAO,YAAY,CAAC,EAAE,KAAK,CAAC,MAAM,OAAO,CAAC,MAAM,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AACtE;;;AC3KA,IAAMC,QAAO,yBAAyB,IAAK;;;ACC3C,IAAM,UAAU,CAAC,IAAI,YAAY,CAAC,KAAK,MAAM,YAAY;AACvD,SAAO,QAAQ,IAAI,GAAG,GAAG,EAAE,gCAAgC;AAC3D,QAAM,OAAO,aAAa,KAAK,MAAM,MAAM,OAAO;AAClD,MAAI,KAAK,KAAK,KAAK;AAAG,WAAO;AAC7B;AAAA,IACE,KAAK,MAAM,QAAQ;AAAA,IACnB,GAAG,EAAE;AAAA,EACP;AACA,SAAO,QAAQ,IAAI;AACrB;;;ACVA,IAAM,UAAU;AAAA,EACd;AAAA,EACA,CAAC,SAAS,KAAK,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,EAAE;AAC3C;;;ACHA,IAAM,SAAS;AAAA,EACb;AAAA,EACA,CAAC,SAAS,KAAK,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAC1C;;;ACHA,IAAM,UAAU;AAAA,EACd;AAAA,EACA,CAAC,SAAS,KAAK,OAAO,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC;AAC1C;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEA,IAAM,OAAO,CAAC,KAAK,MAAM,YAAY;AACnC,QAAM,QAAQ,aAAa,KAAK,MAAM,MAAM,OAAO;AACnD,SAAO,OAAO,OAAO,QAAQ,aAAa,KAAK,MAAM,MAAM,CAAC,MAAM,OAAO,GAAG,QAAQ,aAAa,CAAC;AACpG;;;ACHA,IAAM,OAAO,CAAC,KAAK,MAAM,YAAY;AACnC,QAAM,cAAc,YAAY,IAAI;AACpC,MAAI,YAAY,UAAU;AAAG,WAAO;AACpC,SAAO,YAAY,UAAU,GAAG,0CAA0C;AAC1E,SAAO,CAAC,aAAa,KAAK,YAAY,CAAC,GAAG,MAAM,OAAO;AACzD;;;ACLA,IAAM,MAAM,CAAC,KAAK,MAAM,YAAY;AAClC,QAAM,QAAQ,aAAa,KAAK,MAAM,MAAM,OAAO;AACnD,QAAM,SAAS,QAAQ;AACvB,SAAO,OAAO,OAAO,MAAM,KAAK,MAAM,KAAK,CAAC,MAAM,OAAO,GAAG,MAAM,CAAC;AACrE;;;ACNA;AAAA;AAAA;AAAA,aAAAC;AAAA,EAAA,WAAAC;AAAA,EAAA,YAAAC;AAAA,EAAA,WAAAC;AAAA,EAAA,YAAAC;AAAA,EAAA,WAAAC;AAAA;;;ACEA,IAAM,OAAO,CAAC,KAAK,MAAM,YAAY;AACnC,QAAM,OAAO,aAAa,KAAK,MAAM,MAAM,OAAO;AAClD;AAAA,IACE,QAAQ,IAAI,KAAK,KAAK,UAAU;AAAA,IAChC;AAAA,EACF;AACA,SAAO,QAAQ,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACjC;;;ACRA,IAAMC,OAAM,yBAAyB,GAAI;;;ACAzC,IAAMC,OAAM,yBAAyB,GAAI;;;ACAzC,IAAMC,QAAO,yBAAyB,IAAK;;;ACA3C,IAAMC,OAAM,yBAAyB,GAAI;;;ACAzC,IAAMC,QAAO,yBAAyB,IAAK;;;ACA3C,IAAMC,OAAM,yBAAyB,GAAI;;;ACQzC,IAAM,WAAW,CAAC,SAAS,SAAS;AAClC,QAAM,IAAI,CAAC;AACX,UAAQ,MAAM,EAAE,EAAE,QAAQ,CAAC,GAAG,MAAM,EAAE,CAAC,IAAI,QAAQ,IAAI,EAAE;AACzD,SAAO;AACT;AACA,IAAM,oBAAoB;AAAA,EACxB,GAAG,SAAS,gBAAgB,CAAC;AAAA,EAC7B,GAAG,SAAS,gBAAgB,EAAE;AAAA,EAC9B,GAAG;AACL;;;AChBA,IAAM,eAAe;AAAA,EACnB,WAAW;AAAA,EACX,MAAM;AAAA,EACN,KAAK;AAAA,EACL,UAAU,IAAI,MAAM;AAAA,EACpB,aAAa,IAAI,MAAM;AACzB;AACA,SAAS,0BAA0B,GAAG,cAAc,cAAc;AAChE,QAAM,KAAK,OAAO,OAAO,CAAC,GAAG,cAAc,WAAW;AACtD,QAAM,SAAS,IAAI,IAAI,OAAO,KAAK,EAAE,CAAC;AACtC,SAAO,CAAC,KAAK,MAAM,YAAY;AAC7B,UAAM,IAAI,aAAa,KAAK,MAAM,MAAM,OAAO;AAC/C,QAAI,OAAO,IAAI,GAAG,CAAC,EAAE,GAAG;AACtB,YAAM,MAAM,GAAG,GAAG,CAAC,EAAE;AACrB,UAAI,eAAe,OAAO;AACxB,cAAM,IAAI;AAAA,UACR,iBAAiB,EAAE,IAAI;AAAA,QACzB;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,WAAO,EAAE,CAAC;AAAA,EACZ;AACF;;;ACxBA,IAAM,QAAQ,0BAA0B,KAAK,MAAM;AAAA,EACjD,UAAU;AAAA,EACV,GAAG,IAAI,MAAM;AACf,CAAC;;;ACHD,IAAM,SAAS,0BAA0B,KAAK,OAAO;AAAA,EACnD,UAAU;AAAA,EACV,GAAG,IAAI,MAAM;AACf,CAAC;;;ACHD,IAAM,QAAQ,0BAA0B,KAAK,IAAI;;;ACAjD,IAAM,SAAS,0BAA0B,KAAK,OAAO;AAAA,EACnD,UAAU;AAAA,EACV,aAAa;AACf,CAAC;;;ACHD,IAAM,QAAQ,0BAA0B,KAAK,IAAI;;;ACAjD,IAAM,SAAS,0BAA0B,KAAK,OAAO;AAAA,EACnD,GAAG;AAAA,EACH,MAAM;AACR,CAAC;;;ACHD,IAAM,OAAO,0BAA0B,KAAK,GAAG;;;ACA/C,IAAM,QAAQ,0BAA0B,KAAK,MAAM;AAAA,EACjD,aAAa;AAAA,EACb,UAAU;AACZ,CAAC;;;ACHD,IAAM,iBAAiB,KAAK,KAAK;AACjC,IAAM,oBAAoB;AAAA,EACxB,CAAC,MAAM,IAAI;AAAA,EACX;AAAA,IACE,UAAU;AAAA,IACV,aAAa;AAAA,EACf;AACF;;;ACPA,IAAM,iBAAiB,MAAM,KAAK;AAClC,IAAM,oBAAoB;AAAA,EACxB,CAAC,MAAM,IAAI;AAAA,EACX;AAAA,IACE,UAAU;AAAA,IACV,aAAa;AAAA,EACf;AACF;;;ACPA,IAAM,OAAO,0BAA0B,KAAK,GAAG;;;ACA/C,IAAM,QAAQ,0BAA0B,KAAK,MAAM;AAAA,EACjD,aAAa;AAAA,EACb,UAAU;AACZ,CAAC;;;ACHD,IAAM,OAAO,0BAA0B,KAAK,GAAG;;;ACG/C,IAAM,WAAW,OAAO;AACxB,IAAM,WAAW,OAAO;;;ACHxB,IAAMC,QAAO,CAAC,GAAG,KAAK,YAAY;AAChC;AAAA,IACE,QAAQ,GAAG;AAAA,IACX;AAAA,EACF;AACA,QAAM,UAAU,IAAI,IAAI,CAAC,SAAS,IAAI,MAAM,MAAM,OAAO,CAAC;AAC1D,SAAO,CAAC,QAAQ,QAAQ,MAAM,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC;AAClD;;;ACPA,IAAMC,OAAM,CAAC,GAAG,KAAK,YAAY;AAC/B,SAAO,QAAQ,GAAG,GAAG,sDAAsD;AAC3E,QAAM,UAAU,IAAI,IAAI,CAAC,SAAS,IAAI,MAAM,MAAM,OAAO,CAAC;AAC1D,SAAO,CAAC,QAAQ,QAAQ,KAAK,CAAC,MAAM,EAAE,KAAK,GAAG,CAAC;AACjD;;;ACJA,IAAM,OAAO,CAAC,GAAG,KAAK,YAAY;AAChC;AAAA,IACE,QAAQ,GAAG;AAAA,IACX;AAAA,EACF;AACA,QAAM,IAAIC,KAAI,OAAO,KAAK,OAAO;AACjC,SAAO,CAAC,QAAQ,CAAC,EAAE,GAAG;AACxB;;;ACPA,IAAMC,QAAO,CAAC,UAAU,KAAK,YAAY;AACvC,QAAM,WAAW,CAAC;AAClB,WAAS,QAAQ,IAAI,UAAU,GAAG;AAClC,QAAM,QAAQ,IAAI,MAAM,UAAU,OAAO;AACzC,SAAO,CAAC,QAAQ,CAAC,MAAM,KAAK,GAAG;AACjC;;;ACNA,IAAMC,OAAM,oBAAoB,GAAI;;;ACApC,IAAMC,OAAM,oBAAoB,GAAI;;;ACApC,IAAMC,QAAO,oBAAoB,IAAK;;;ACAtC,IAAMC,OAAM,oBAAoB,GAAI;;;ACApC,IAAMC,OAAM,oBAAoB,GAAI;;;ACApC,IAAMC,QAAO,oBAAoB,IAAK;;;ACAtC,IAAMC,OAAM,oBAAoB,GAAI;;;ACApC,IAAMC,QAAO,oBAAoB,IAAK;;;ACAtC,SAAS,MAAM,GAAG,KAAK,SAAS;AAC9B,SAAO,CAAC,QAAQ,aAAa,KAAK,KAAK,MAAM,OAAO;AACtD;;;ACFA,SAAS,YAAY,GAAG,QAAQ,SAAS;AACvC,MAAI,EAAC,mCAAS,sBAAqB;AACjC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AACA,QAAM,WAAW,mCAAS,oBAAoB;AAC9C,SAAO,CAAC,QAAQ,SAAS,GAAG;AAC9B;;;ACRA,IAAMC,QAAO,oBAAoB,IAAK;;;ACAtC,IAAMC,UAAS,oBAAoB,MAAO;;;ACA1C,SAAS,OAAO,GAAG,KAAK,SAAS;AAC/B;AAAA,IACE,QAAQ;AAAA,IACR;AAAA,EACF;AACA,QAAM,IAAI;AACV,SAAO,WAAW,CAAC,GAAG,uCAAuC;AAC7D,SAAO,CAAC,QAAQ,OAAO,EAAE,KAAK,GAAG,GAAG,mCAAS,aAAa;AAC5D;;;ACRA,IAAMC,QAAO,oBAAoB,IAAK;;;ACGtC,IAAMC,cAAa,oBAAoB,UAAW;;;ACHlD,IAAMC,SAAQ,oBAAoB,KAAM;;;ACAxC,IAAM,UAAU,CAAC,UAAU,OAAOC,cAAa;AAC7C,QAAM,SAAS,SAAS,SAAS,GAAG;AACpC,QAAM,IAAI,CAAC,CAAC;AACZ,MAAI,CAAC,UAAU,SAAS,MAAM,QAAQ,GAAG;AACvC,WAAO,CAAC,MAAM,QAAQ,GAAG,QAAQ,MAAM,WAAW;AAAA,EACpD;AACA,SAAO,CAAC,MAAM;AACZ,UAAM,OAAO,aAAa,GAAG,UAAU,EAAE,eAAe,KAAK,CAAC;AAC9D,UAAM,MAAM,QAAQ,MAAM,SAAS,UAAU,GAAG,SAAS,YAAY,GAAG,CAAC,CAAC;AAC1E,WAAO,QAAQ,GAAG,IAAI,IAAI,KAAK,CAAC,MAAM,MAAM,MAAM,MAAM,IAAI,QAAQ,WAAW;AAAA,EACjF;AACF;;;ACXA,IAAMC,SAAQ,oBAAoB,KAAM;;;ACmCxC,IAAIC,gBAAgB;AAUb,SAASC,cACZC,UACF;AACE,MAAI,CAACF,eAAe;AAChBG,iBAAa,YAAY;MACrBC;MACAC;IACJ,CAAQ;AACRF,iBAAa,SAAS;MAClBG,MAAAA;MACAC,KAAAA;MACAC,YAAAA;MACAC;MACAC,KAAAA;MACAC,MAAAA;MACAC,KAAAA;MACAC,KAAAA;MACAC,MAAAA;MACAC,KAAAA;MACAC,MAAAA;MACAC,MAAAA;MACAC;MACAC,MAAAA;MACAC,KAAAA;MACAC,QAAAA;MACAC,OAAAA;MACAC,OAAAA;IACJ,CAAQ;AACRvB,oBAAgB;EACpB;AACA,SAAO,IAAIwB,MAAMtB,QAAe;AACpC;;;AC3CO,SAASuB,oBACZC,QACAC,YAC2B;AAC3B,MAAMC,aAAqBC,4BAA4BH,OAAOE,UAAU;AACxED,eAAaG,UAAUH,UAAU;AAEjC,MAAMI,uBAAoDC,MAAML,UAAU;AAC1E,MAAI,OAAOI,qBAAqBE,SAAS,UAAU;AAC/CF,yBAAqBE,OAAO;EAChC;AAEA,MAAI,CAACF,qBAAqBG,UAAU;AAChCH,yBAAqBG,WAAW,CAAC;EACrC,OAAO;AACHH,yBAAqBG,WAAWH,qBAAqBG;AAgBrDC,WACKC,QAAQL,qBAAqBG,QAAQ,EACrCG,QAAQ,CAAC,CAACC,OAAOC,OAAO,MAAM;AAC3B,UAAI,OAAOA,YAAY,YAAYA,YAAY,MAAM;AAChDR,6BAA6BG,SAASI,KAAK,IAAI;UAC5CE,KAAKD;QACT;MACJ;IACJ,CAAC;EACT;AAMA,MAAIR,qBAAqBU,OAAO;AAC5B,QAAMC,UAAUC,QAAQZ,qBAAqBU,KAAK;AAClD,QAAI,CAACC,QAAQE,SAAShB,UAAU,GAAG;AAC/Bc,cAAQG,KAAKjB,UAAU;IAC3B;AACAG,yBAAqBU,QAAQC;EACjC;AAUA,MAAI,CAACX,qBAAqBe,MAAM;AAS5B,QAAIf,qBAAqBU,OAAO;AAC5BV,2BAAqBe,OAAOf,qBAAqBU,MAAMM,IAAKT,WAAkB;AAC1E,eAAO;UAAE,CAACA,KAAK,GAAU;QAAM;MACnC,CAAC;IACL,OAAO;AAIH,UAAIZ,OAAOsB,SAAS;AAChB,YAAMC,4BAAyC,oBAAIC,IAAI;AACvDf,eAAOC,QAAQL,qBAAqBG,QAAQ,EAAEG,QAAQ,CAAC,CAACC,OAAOC,OAAO,MAAM;AACxE,cAAIY,aAAa;AACjB,cAAI,OAAOZ,YAAY,YAAYA,YAAY,MAAM;AACjDY,yBAAa,CAAC,CAAChB,OAAOiB,KAAKb,OAAO,EAAEc,KAAKC,cAAYC,kBAAkBC,IAAIF,QAAQ,CAAC;UACxF,OAAO;AACHH,yBAAa;UACjB;AACA,cAAIA,YAAY;AACZF,sCAA0BQ,IAAInB,KAAK;UACvC;QACJ,CAAC;AAGD,YAAIoB,sBAAsB;AAC1B,YAAIC;AACJjC,eAAOsB,QAAQX,QAAQI,WAAS;AAC5B,cAAMmB,YAAWC,qBAAqBpB,KAAK,IAAIA,QAAQ,CAACA,KAAK;AAC7D,cAAMqB,kBAAkBF,UAASG,UAAUC,gBAAc,CAACf,0BAA0BO,IAAIQ,UAAU,CAAC;AACnG,cACIF,kBAAkB,KAClBA,kBAAkBJ,qBACpB;AACEA,kCAAsBI;AACtBH,sCAA0BC;UAC9B;QACJ,CAAC;AACD,YAAID,yBAAyB;AACzB5B,+BAAqBe,OAAOa,wBAAwBZ,IAAKT,WAAkB;AACvE,mBAAO;cAAE,CAACA,KAAK,GAAU;YAAM;UACnC,CAAC;QACL;MAEJ;AAQA,UAAI,CAACP,qBAAqBe,MAAM;AAC5B,YAAIpB,OAAOsB,WAAWtB,OAAOsB,QAAQiB,SAAS,GAAG;AAC7C,cAAMC,aAAaxC,OAAOsB,QAAQ,CAAC;AACnC,cAAMY,WAAWC,qBAAqBK,UAAU,IAAIA,aAAa,CAACA,UAAU;AAC5EnC,+BAAqBe,OAAOc,SAASb,IAAIT,YAAU;YAAE,CAACA,KAAK,GAAG;UAAM,EAAE;QAC1E,OAAO;AACHP,+BAAqBe,OAAO,CAAC;YAAE,CAAClB,UAAU,GAAG;UAAM,CAAC;QACxD;MACJ;IACJ;EACJ,OAAO;AACH,QAAMuC,kBAAkBpC,qBAAqBe,KACxCO,KAAKe,OAAKC,0BAA0BD,CAAC,MAAMxC,UAAU;AAC1D,QAAI,CAACuC,iBAAiB;AAClBpC,2BAAqBe,OAAOf,qBAAqBe,KAAKwB,MAAM,CAAC;AAC7DvC,2BAAqBe,KAAKD,KAAK;QAAE,CAACjB,UAAU,GAAG;MAAM,CAAQ;IACjE;EACJ;AAEA,SAAOG;AACX;AAOO,SAASwC,kBACZ7C,QACA8C,OACsC;AACtC,MAAI,CAACA,MAAM1B,MAAM;AACb,UAAM2B,WAAW,OAAO;MAAED;IAAM,CAAC;EACrC;AACA,MAAME,YAIA,CAAA;AACNF,QAAM1B,KAAKT,QAAQsC,eAAa;AAC5B,QAAMC,MAAMzC,OAAOiB,KAAKuB,SAAS,EAAE,CAAC;AACpC,QAAME,YAAY1C,OAAO2C,OAAOH,SAAS,EAAE,CAAC;AAC5CD,cAAU7B,KAAK;MACX+B;MACAC;MACAE,YAAYC,gBAAgBJ,GAAG;IACnC,CAAC;EACL,CAAC;AACD,MAAMK,MAA8CA,CAACC,GAAcC,MAAiB;AAChF,aAASC,IAAI,GAAGA,IAAIV,UAAUT,QAAQ,EAAEmB,GAAG;AACvC,UAAMC,WAAWX,UAAUU,CAAC;AAC5B,UAAME,SAASD,SAASN,WAAWG,CAAC;AACpC,UAAMK,SAASF,SAASN,WAAWI,CAAC;AACpC,UAAIG,WAAWC,QAAQ;AACnB,YAAMC,MAAMH,SAASR,cAAc,QAAQY,QAAoBH,QAAQC,MAAM,IAAIE,QAAoBF,QAAQD,MAAM;AACnH,eAAOE;MACX;IACJ;EACJ;AAEA,SAAOP;AACX;AAQO,SAASS,gBACZC,SACAnB,OACuC;AACvC,MAAI,CAACA,MAAM1B,MAAM;AACb,UAAM2B,WAAW,OAAO;MAAED;IAAM,CAAC;EACrC;AAEA,MAAMoB,aAAaC,cAAcrB,MAAMtC,QAAe;AACtD,MAAM+C,MAAgDa,SAA6E;AAC/H,WAAOF,WAAWG,KAAKD,GAAG;EAC9B;AACA,SAAOb;AACX;AAGA,eAAsBe,uBAClBC,SACAC,IACsB;AACtB,MAAMC,OAAO,MAAMF,QAAQG,KAAK;AAChC,MAAI,CAACD,MAAM;AAEP,WAAO;EACX;AACA,MAAIE,MAAMC,QAAQH,IAAI,GAAG;AACrB,WAAOI,QAAQC,IACXL,KAAKpD,IAAI+C,SAAOI,GAAGJ,GAAG,CAAC,CAC3B;EACJ,WAAWK,gBAAgBM,KAAK;AAC5B,WAAOF,QAAQC,IACX,CAAC,GAAGL,KAAKrB,OAAO,CAAC,EAAE/B,IAAK+C,SAAQI,GAAGJ,GAAG,CAAC,CAC3C;EACJ,OAAO;AAEH,QAAMY,SAAS,MAAMR,GAAGC,IAAW;AACnC,WAAOO;EACX;AACJ;AAMO,SAASC,aACZjF,QACAkF,iBACwB;AACxB,MAAI,CAACA,gBAAgB9D,MAAM;AACvB,UAAM2B,WAAW,OAAO;MACpBD,OAAOoC;IACX,CAAC;EACL;AAMA,MAAMC,YAAYC,aACdpF,QACAkF,eACJ;AAEA,SAAO;IACHpC,OAAOoC;IACPC;EACJ;AACJ;",
  "names": ["INDEX_MAX", "String", "fromCharCode", "INDEX_MIN", "Number", "MIN_SAFE_INTEGER", "getQueryPlan", "schema", "query", "selector", "indexes", "slice", "index", "hasDescSorting", "sort", "find", "sortField", "Object", "values", "sortIrrelevevantFields", "Set", "keys", "forEach", "fieldName", "schemaPart", "getSchemaByObjectPath", "type", "prototype", "hasOwnProperty", "call", "add", "optimalSortIndex", "map", "optimalSortIndexCompareString", "filter", "f", "has", "join", "currentBestQuality", "currentBestQueryPlan", "inclusiveEnd", "inclusiveStart", "opts", "indexField", "matcher", "operators", "matcherOpts", "length", "startKey", "endKey", "operator", "LOGICAL_OPERATORS", "operatorValue", "partialOpts", "getMatcherQueryOpts", "assign", "startKeys", "opt", "endKeys", "queryPlan", "sortSatisfiedByIndex", "selectorSatisfiedByIndex", "isSelectorSatisfiedByIndex", "quality", "rateQueryPlan", "newRxError", "LOWER_BOUND_LOGICAL_OPERATORS", "UPPER_BOUND_LOGICAL_OPERATORS", "selectorEntries", "entries", "hasNonMatchingOperator", "operation", "includes", "hasNonLogicOperator", "op", "_value", "$and", "$or", "satisfieldLowerBound", "lowerOperatorFieldNames", "lowerLogicOps", "key", "hasLowerLogicOp", "push", "satisfieldUpperBound", "upperOperatorFieldNames", "upperLogicOps", "hasUperLogicOp", "i", "set", "size", "delete", "Error", "addQuality", "value", "pointsPerMatchingKey", "nonMinKeyCount", "countUntilNotMatching", "keyValue", "nonMaxKeyCount", "equalKeyCount", "idx", "pointsIfNoReSortMustBeDone", "_options", "_options", "_options", "_operators", "_options", "_options", "compare", "$nin", "$eq", "$gt", "$gte", "$lt", "$lte", "$ne", "$eq", "$gt", "$gte", "$lt", "$lte", "$ne", "$and", "$or", "$or", "$not", "$eq", "$gt", "$gte", "$in", "$lt", "$lte", "$ne", "$nin", "$mod", "$regex", "$all", "$elemMatch", "$size", "_options", "$type", "mingoInitDone", "getMingoQuery", "selector", "useOperators", "$sort", "$project", "$and", "$eq", "$elemMatch", "$exists", "$gt", "$gte", "$in", "$lt", "$lte", "$ne", "$nin", "$mod", "$nor", "$not", "$or", "$regex", "$size", "$type", "Query", "normalizeMangoQuery", "schema", "mangoQuery", "primaryKey", "getPrimaryFieldOfPrimaryKey", "flatClone", "normalizedMangoQuery", "clone", "skip", "selector", "Object", "entries", "forEach", "field", "matcher", "$eq", "index", "indexAr", "toArray", "includes", "push", "sort", "map", "indexes", "fieldsWithLogicalOperator", "Set", "hasLogical", "keys", "find", "operator", "LOGICAL_OPERATORS", "has", "add", "currentFieldsAmount", "currentBestIndexForSort", "useIndex", "isMaybeReadonlyArray", "firstWrongIndex", "findIndex", "indexField", "length", "firstIndex", "isPrimaryInSort", "p", "firstPropertyNameOfObject", "slice", "getSortComparator", "query", "newRxError", "sortParts", "sortBlock", "key", "direction", "values", "getValueFn", "objectPathMonad", "fun", "a", "b", "i", "sortPart", "valueA", "valueB", "ret", "mingoSortComparator", "getQueryMatcher", "_schema", "mingoQuery", "getMingoQuery", "doc", "test", "runQueryUpdateFunction", "rxQuery", "fn", "docs", "exec", "Array", "isArray", "Promise", "all", "Map", "result", "prepareQuery", "mutateableQuery", "queryPlan", "getQueryPlan"]
}
