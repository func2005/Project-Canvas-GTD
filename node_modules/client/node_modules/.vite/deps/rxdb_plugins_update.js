import {
  $all,
  $and,
  $elemMatch,
  $eq,
  $exists,
  $expr,
  $gt,
  $gte,
  $in,
  $jsonSchema,
  $lt,
  $lte,
  $mod,
  $ne,
  $nin,
  $nor,
  $not,
  $or,
  $regex,
  $size,
  $type,
  $where,
  Context,
  Query,
  assert,
  boolean_exports,
  cloneDeep,
  compare,
  comparison_exports,
  createQueryOperator,
  has,
  initOptions,
  intersection,
  isArray,
  isDate,
  isEqual,
  isNumber,
  isObject,
  isOperator,
  isRegExp,
  resolve,
  runQueryUpdateFunction,
  unique,
  walk
} from "./chunk-NTRYYW7Y.js";
import {
  clone
} from "./chunk-PGZMEVAM.js";
import {
  __export
} from "./chunk-C3M7BXFS.js";

// ../../node_modules/mingo/dist/esm/operators/update/index.js
var update_exports = {};
__export(update_exports, {
  $addToSet: () => $addToSet,
  $bit: () => $bit,
  $currentDate: () => $currentDate,
  $inc: () => $inc,
  $max: () => $max,
  $min: () => $min,
  $mul: () => $mul,
  $pop: () => $pop,
  $pull: () => $pull,
  $pullAll: () => $pullAll,
  $push: () => $push,
  $rename: () => $rename,
  $set: () => $set,
  $unset: () => $unset
});

// ../../node_modules/mingo/dist/esm/operators/query/index.js
var query_exports = {};
__export(query_exports, {
  $all: () => $all,
  $and: () => $and,
  $bitsAllClear: () => $bitsAllClear,
  $bitsAllSet: () => $bitsAllSet,
  $bitsAnyClear: () => $bitsAnyClear,
  $bitsAnySet: () => $bitsAnySet,
  $elemMatch: () => $elemMatch,
  $eq: () => $eq,
  $exists: () => $exists,
  $expr: () => $expr,
  $gt: () => $gt,
  $gte: () => $gte,
  $in: () => $in,
  $jsonSchema: () => $jsonSchema,
  $lt: () => $lt,
  $lte: () => $lte,
  $mod: () => $mod,
  $ne: () => $ne,
  $nin: () => $nin,
  $nor: () => $nor,
  $not: () => $not,
  $or: () => $or,
  $regex: () => $regex,
  $size: () => $size,
  $type: () => $type,
  $where: () => $where
});

// ../../node_modules/mingo/dist/esm/operators/query/bitwise/_internal.js
var createBitwiseOperator = (predicate) => {
  return createQueryOperator(
    (value, mask, _options) => {
      let b = 0;
      if (isArray(mask)) {
        for (const n of mask)
          b = b | 1 << n;
      } else {
        b = mask;
      }
      return predicate(value & b, b);
    }
  );
};

// ../../node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllClear.js
var $bitsAllClear = createBitwiseOperator((result, _) => result == 0);

// ../../node_modules/mingo/dist/esm/operators/query/bitwise/bitsAllSet.js
var $bitsAllSet = createBitwiseOperator(
  (result, mask) => result == mask
);

// ../../node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnyClear.js
var $bitsAnyClear = createBitwiseOperator(
  (result, mask) => result < mask
);

// ../../node_modules/mingo/dist/esm/operators/query/bitwise/bitsAnySet.js
var $bitsAnySet = createBitwiseOperator((result, _) => result > 0);

// ../../node_modules/mingo/dist/esm/operators/update/_internal.js
var UPDATE_OPTIONS = {
  cloneMode: "copy",
  queryOptions: initOptions({
    context: Context.init().addQueryOps(query_exports).addExpressionOps(boolean_exports).addExpressionOps(comparison_exports)
  })
};
var clone2 = (mode, val) => {
  switch (mode) {
    case "deep":
      return cloneDeep(val);
    case "copy": {
      if (isDate(val))
        return new Date(val);
      if (isArray(val))
        return [...val];
      if (isObject(val))
        return { ...val };
      if (isRegExp(val))
        return new RegExp(val);
      return val;
    }
    default:
      return val;
  }
};
var FILTER_IDENT_RE = /^[a-z]+[a-zA-Z0-9]*$/;
function tokenizePath(selector) {
  if (!selector.includes(".$")) {
    return [{ parent: selector, selector }, []];
  }
  const begin = selector.indexOf(".$");
  const end = selector.indexOf("]");
  const parent = selector.substring(0, begin);
  const child = selector.substring(begin + 3, end);
  assert(
    child === "" || FILTER_IDENT_RE.test(child),
    "The filter <identifier> must begin with a lowercase letter and contain only alphanumeric characters."
  );
  const rest = selector.substring(end + 2);
  const [next, elems] = rest ? tokenizePath(rest) : [];
  return [
    { selector, parent, child: child || "$", next },
    [child, ...elems || []].filter(Boolean)
  ];
}
var applyUpdate = (o, n, q, f, opts) => {
  const { parent, child: c, next } = n;
  if (!c) {
    let b = false;
    const g = (u, k) => b = Boolean(f(u, k)) || b;
    walk(o, parent, g, opts);
    return b;
  }
  const t = resolve(o, parent);
  if (!isArray(t))
    return false;
  return t.map((e, i) => {
    if (q[c] && !q[c].test({ [c]: e }))
      return false;
    return next ? applyUpdate(e, next, q, f, opts) : f(t, i);
  }).some(Boolean);
};
function walkExpression(expr, arrayFilter, options, callback) {
  const res = [];
  for (const [selector, val] of Object.entries(expr)) {
    const [node, vars] = tokenizePath(selector);
    if (!vars.length) {
      if (callback(val, node, {}))
        res.push(node.parent);
    } else {
      const conditions = {};
      arrayFilter.forEach((o) => {
        Object.keys(o).forEach((k) => {
          vars.forEach((w) => {
            if (k === w || k.startsWith(w + ".")) {
              conditions[w] = conditions[w] || {};
              Object.assign(conditions[w], { [k]: o[k] });
            }
          });
        });
      });
      const queries = {};
      for (const [k, condition] of Object.entries(conditions)) {
        queries[k] = new Query(condition, options.queryOptions);
      }
      if (callback(val, node, queries))
        res.push(node.parent);
    }
  }
  return res;
}

// ../../node_modules/mingo/dist/esm/operators/update/addToSet.js
var $addToSet = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const args = { $each: [val] };
    if (isObject(val) && has(val, "$each")) {
      Object.assign(args, val);
    }
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        const prev = o[k] || (o[k] = []);
        const common = intersection([prev, args.$each]);
        if (common.length === args.$each.length)
          return false;
        o[k] = clone2(options.cloneMode, unique(prev.concat(args.$each)));
        return true;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/bit.js
var BIT_OPS = /* @__PURE__ */ new Set(["and", "or", "xor"]);
var $bit = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const op = Object.keys(val);
    assert(
      op.length === 1 && BIT_OPS.has(op[0]),
      `Invalid bit operator '${op[0]}'. Must be one of 'and', 'or', or 'xor'.`
    );
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        let n = o[k];
        const v = val[op[0]];
        if (n !== void 0 && !(isNumber(n) && isNumber(v)))
          return false;
        n = n || 0;
        switch (op[0]) {
          case "and":
            o[k] = n & v;
            break;
          case "or":
            o[k] = n | v;
            break;
          case "xor":
            o[k] = n ^ v;
            break;
        }
        return o[k] !== n;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/currentDate.js
var $currentDate = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  const now = Date.now();
  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        o[k] = now;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/inc.js
var $inc = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    if (!node.child) {
      const n = resolve(obj, node.parent);
      assert(
        n === void 0 || isNumber(n),
        `cannot apply $inc to a value of non-numeric type`
      );
    }
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        o[k] = (o[k] || (o[k] = 0)) + val;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/max.js
var $max = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        if (o[k] !== void 0 && compare(o[k], val) > -1)
          return false;
        o[k] = val;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/min.js
var $min = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        if (o[k] !== void 0 && compare(o[k], val) < 1)
          return false;
        o[k] = val;
        return true;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/mul.js
var $mul = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        const prev = o[k];
        o[k] = o[k] === void 0 ? 0 : o[k] * val;
        return o[k] !== prev;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/pop.js
var $pop = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(obj, node, queries, (o, k) => {
      const arr = o[k];
      assert(
        isArray(arr),
        `path '${node.selector}' contains an element of non-array type.`
      );
      if (!arr.length)
        return false;
      if (val === -1) {
        arr.splice(0, 1);
      } else {
        arr.pop();
      }
      return true;
    });
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/pull.js
var $pull = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const wrap = !isObject(val) || Object.keys(val).some(isOperator);
    const query = new Query(
      wrap ? { k: val } : val,
      options.queryOptions
    );
    const pred = wrap ? (v) => query.test({ k: v }) : (v) => query.test(v);
    return applyUpdate(obj, node, queries, (o, k) => {
      const prev = o[k];
      const curr = new Array();
      const found = prev.map((v) => {
        const b = pred(v);
        if (!b)
          curr.push(v);
        return b;
      }).some(Boolean);
      if (!found)
        return false;
      o[k] = curr;
      return true;
    });
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/pullAll.js
var $pullAll = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  const pullExpr = {};
  Object.entries(expr).forEach(([k, v]) => {
    pullExpr[k] = { $in: v };
  });
  return $pull(obj, pullExpr, arrayFilters, options);
};

// ../../node_modules/mingo/dist/esm/operators/update/push.js
var OPERATOR_MODIFIERS = Object.freeze([
  "$each",
  "$slice",
  "$sort",
  "$position"
]);
var $push = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    const args = {
      $each: [val]
    };
    if (isObject(val) && OPERATOR_MODIFIERS.some((m) => has(val, m))) {
      Object.assign(args, val);
    }
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        const arr = o[k] || (o[k] = []);
        const prev = arr.slice(0, args.$slice || arr.length);
        const oldsize = arr.length;
        const pos = isNumber(args.$position) ? args.$position : arr.length;
        arr.splice(pos, 0, ...clone2(options.cloneMode, args.$each));
        if (args.$sort) {
          const sortKey = isObject(args.$sort) ? Object.keys(args.$sort || {}).pop() : "";
          const order = !sortKey ? args.$sort : args.$sort[sortKey];
          const f = !sortKey ? (a) => a : (a) => resolve(a, sortKey);
          arr.sort((a, b) => order * compare(f(a), f(b)));
        }
        if (isNumber(args.$slice)) {
          if (args.$slice < 0)
            arr.splice(0, arr.length + args.$slice);
          else
            arr.splice(args.$slice);
        }
        return oldsize != arr.length || !isEqual(prev, arr);
      },
      { descendArray: true, buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/set.js
var $set = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(
      obj,
      node,
      queries,
      (o, k) => {
        if (isEqual(o[k], val))
          return false;
        o[k] = clone2(options.cloneMode, val);
        return true;
      },
      { buildGraph: true }
    );
  });
};

// ../../node_modules/mingo/dist/esm/operators/update/rename.js
var $rename = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  const res = [];
  const changed = walkExpression(expr, arrayFilters, options, (val, node, queries) => {
    return applyUpdate(obj, node, queries, (o, k) => {
      if (!has(o, k))
        return false;
      res.push(...$set(obj, { [val]: o[k] }, arrayFilters, options));
      delete o[k];
      return true;
    });
  });
  return Array.from(new Set(changed.concat(res)));
};

// ../../node_modules/mingo/dist/esm/operators/update/unset.js
var $unset = (obj, expr, arrayFilters = [], options = UPDATE_OPTIONS) => {
  return walkExpression(expr, arrayFilters, options, (_, node, queries) => {
    return applyUpdate(obj, node, queries, (o, k) => {
      if (!has(o, k))
        return false;
      if (isArray(o)) {
        o[k] = null;
      } else {
        delete o[k];
      }
      return true;
    });
  });
};

// ../../node_modules/mingo/dist/esm/updater.js
function createUpdater(defaultOptions) {
  defaultOptions = defaultOptions ?? UPDATE_OPTIONS;
  return (obj, expr, arrayFilters = [], condition = {}, options = defaultOptions) => {
    const entry = Object.entries(expr);
    assert(
      entry.length === 1,
      "Update expression must contain only one operator."
    );
    const [op, args] = entry[0];
    assert(
      has(update_exports, op),
      `Update operator '${op}' is not supported.`
    );
    const mutate = update_exports[op];
    if (Object.keys(condition).length) {
      const q = new Query(condition, options.queryOptions);
      if (!q.test(obj))
        return [];
    }
    return mutate(obj, args, arrayFilters, options);
  };
}
var update = createUpdater();

// ../../node_modules/rxdb/dist/esm/plugins/update/mingo-updater.js
var updater;
function mingoUpdater(d, op) {
  if (!updater) {
    var updateObject = createUpdater({
      cloneMode: "none"
    });
    updater = (d2, op2) => {
      var cloned = clone(d2);
      updateObject(cloned, op2);
      return cloned;
    };
  }
  return updater(d, op);
}

// ../../node_modules/rxdb/dist/esm/plugins/update/index.js
function incrementalUpdate(updateObj) {
  return this.incrementalModify((docData) => {
    var newDocData = mingoUpdater(docData, updateObj);
    return newDocData;
  });
}
function update2(updateObj) {
  var oldDocData = this._data;
  var newDocData = mingoUpdater(oldDocData, updateObj);
  return this._saveData(newDocData, oldDocData);
}
async function RxQueryUpdate(updateObj) {
  return runQueryUpdateFunction(this.asRxQuery, (doc) => doc.update(updateObj));
}
var RxDBUpdatePlugin = {
  name: "update",
  rxdb: true,
  prototypes: {
    RxDocument: (proto) => {
      proto.update = update2;
      proto.incrementalUpdate = incrementalUpdate;
    },
    RxQuery: (proto) => {
      proto.update = RxQueryUpdate;
    }
  }
};
export {
  RxDBUpdatePlugin,
  RxQueryUpdate,
  incrementalUpdate,
  update2 as update
};
//# sourceMappingURL=rxdb_plugins_update.js.map
