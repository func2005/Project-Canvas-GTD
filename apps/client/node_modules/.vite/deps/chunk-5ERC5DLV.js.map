{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/plugin-helpers.ts"],
  "sourcesContent": ["import { filter, mergeMap, tap } from 'rxjs/operators';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper.ts';\nimport { WrappedRxStorageInstance } from './rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxChangeEvent,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageWriteError,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxValidationError,\n    RxStorageWriteErrorConflict,\n    MaybePromise\n} from './types/index.d.ts';\nimport {\n    flatClone,\n    getFromMapOrCreate,\n    requestIdleCallbackIfAvailable\n} from './plugins/utils/index.ts';\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\n\n\ntype WrappedStorageFunction = <Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n) => RxStorage<Internals, InstanceCreationOptions>;\n\n/**\n * Returns the validation errors.\n * If document is fully valid, returns an empty array.\n */\ntype ValidatorFunction = (docData: RxDocumentData<any>) => RxValidationError[];\n\n/**\n * cache the validators by the schema string\n * so we can reuse them when multiple collections have the same schema\n *\n * Notice: to make it easier and not dependent on a hash function,\n * we use the plain json string.\n */\nconst VALIDATOR_CACHE_BY_VALIDATOR_KEY: Map<string, Map<string, ValidatorFunction>> = new Map();\n\n/**\n * This factory is used in the validation plugins\n * so that we can reuse the basic storage wrapping code.\n */\nexport function wrappedValidateStorageFactory(\n    /**\n     * Returns a method that can be used to validate\n     * documents and throws when the document is not valid.\n     */\n    getValidator: (schema: RxJsonSchema<any>) => ValidatorFunction,\n    /**\n     * A string to identify the validation library.\n     */\n    validatorKey: string\n): WrappedStorageFunction {\n    const VALIDATOR_CACHE = getFromMapOrCreate(\n        VALIDATOR_CACHE_BY_VALIDATOR_KEY,\n        validatorKey,\n        () => new Map()\n    );\n\n    function initValidator(\n        schema: RxJsonSchema<any>\n    ): ValidatorFunction {\n        return getFromMapOrCreate(\n            VALIDATOR_CACHE,\n            JSON.stringify(schema),\n            () => getValidator(schema)\n        );\n    }\n\n    return (args) => {\n        return Object.assign(\n            {},\n            args.storage,\n            {\n                name: 'validate-' + validatorKey + '-' + args.storage.name,\n                async createStorageInstance<RxDocType>(\n                    params: RxStorageInstanceCreationParams<RxDocType, any>\n                ) {\n                    const instance = await args.storage.createStorageInstance(params);\n                    const primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\n\n                    /**\n                     * Lazy initialize the validator\n                     * to save initial page load performance.\n                     * Some libraries take really long to initialize the validator\n                     * from the schema.\n                     */\n                    let validatorCached: ValidatorFunction;\n                    requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));\n\n                    const oldBulkWrite = instance.bulkWrite.bind(instance);\n                    instance.bulkWrite = (\n                        documentWrites: BulkWriteRow<RxDocType>[],\n                        context: string\n                    ) => {\n                        if (!validatorCached) {\n                            validatorCached = initValidator(params.schema);\n                        }\n                        const errors: RxStorageWriteError<RxDocType>[] = [];\n                        const continueWrites: typeof documentWrites = [];\n                        documentWrites.forEach(row => {\n                            const documentId: string = row.document[primaryPath] as any;\n                            const validationErrors = validatorCached(row.document);\n                            if (validationErrors.length > 0) {\n                                errors.push({\n                                    status: 422,\n                                    isError: true,\n                                    documentId,\n                                    writeRow: row,\n                                    validationErrors,\n                                    schema: instance.schema\n                                });\n                            } else {\n                                continueWrites.push(row);\n                            }\n                        });\n                        const writePromise: Promise<RxStorageBulkWriteResponse<RxDocType>> = continueWrites.length > 0 ?\n                            oldBulkWrite(continueWrites, context) :\n                            Promise.resolve({ error: [], success: [] });\n                        return writePromise.then(writeResult => {\n                            errors.forEach(validationError => {\n                                writeResult.error.push(validationError);\n                            });\n                            return writeResult;\n                        });\n                    };\n\n                    return instance;\n                }\n            }\n        );\n    };\n\n}\n\n\n\n/**\n * Used in plugins to easily modify all in- and outgoing\n * data of that storage instance.\n */\nexport function wrapRxStorageInstance<RxDocType>(\n    originalSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    instance: RxStorageInstance<RxDocType, any, any>,\n    modifyToStorage: (docData: RxDocumentWriteData<RxDocType>) => MaybePromise<RxDocumentData<any>>,\n    modifyFromStorage: (docData: RxDocumentData<any>) => MaybePromise<RxDocumentData<RxDocType>>,\n    modifyAttachmentFromStorage: (attachmentData: string) => MaybePromise<string> = (v) => v\n): WrappedRxStorageInstance<RxDocType, any, any> {\n    async function toStorage(docData: RxDocumentWriteData<RxDocType>): Promise<RxDocumentData<any>> {\n        if (!docData) {\n            return docData;\n        }\n        return await modifyToStorage(docData);\n    }\n    async function fromStorage(docData: RxDocumentData<any> | null): Promise<RxDocumentData<RxDocType>> {\n        if (!docData) {\n            return docData;\n        }\n        return await modifyFromStorage(docData);\n    }\n    async function errorFromStorage(\n        error: RxStorageWriteError<any>\n    ): Promise<RxStorageWriteError<RxDocType>> {\n        const ret = flatClone(error);\n        ret.writeRow = flatClone(ret.writeRow);\n        if ((ret as RxStorageWriteErrorConflict<any>).documentInDb) {\n            (ret as RxStorageWriteErrorConflict<any>).documentInDb = await fromStorage((ret as RxStorageWriteErrorConflict<any>).documentInDb);\n        }\n        if (ret.writeRow.previous) {\n            ret.writeRow.previous = await fromStorage(ret.writeRow.previous);\n        }\n        ret.writeRow.document = await fromStorage(ret.writeRow.document);\n        return ret;\n    }\n\n\n    const processingChangesCount$ = new BehaviorSubject(0);\n\n    const wrappedInstance: WrappedRxStorageInstance<RxDocType, any, any> = {\n        databaseName: instance.databaseName,\n        internals: instance.internals,\n        cleanup: instance.cleanup.bind(instance),\n        options: instance.options,\n        close: instance.close.bind(instance),\n        schema: originalSchema,\n        collectionName: instance.collectionName,\n        count: instance.count.bind(instance),\n        remove: instance.remove.bind(instance),\n        originalStorageInstance: instance,\n        bulkWrite: async (\n            documentWrites: BulkWriteRow<RxDocType>[],\n            context: string\n        ) => {\n            const useRows: BulkWriteRow<any>[] = [];\n            await Promise.all(\n                documentWrites.map(async (row) => {\n                    const [previous, document] = await Promise.all([\n                        row.previous ? toStorage(row.previous) : undefined,\n                        toStorage(row.document)\n                    ]);\n                    useRows.push({ previous, document });\n                })\n            );\n\n            const writeResult = await instance.bulkWrite(useRows, context);\n            const ret: RxStorageBulkWriteResponse<RxDocType> = {\n                error: []\n            };\n            const promises: Promise<any>[] = [];\n            writeResult.error.forEach(error => {\n                promises.push(\n                    errorFromStorage(error).then(err => ret.error.push(err))\n                );\n            });\n            await Promise.all(promises);\n\n            /**\n             * By definition, all change events must be emitted\n             * BEFORE the write call resolves.\n             * To ensure that even when the modifiers are async,\n             * we wait here until the processing queue is empty.\n             */\n            await firstValueFrom(\n                processingChangesCount$.pipe(\n                    filter(v => v === 0)\n                )\n            );\n            return ret;\n        },\n        query: (preparedQuery) => {\n            return instance.query(preparedQuery)\n                .then(queryResult => {\n                    return Promise.all(queryResult.documents.map(doc => fromStorage(doc)));\n                })\n                .then(documents => ({ documents: documents as any }));\n        },\n        getAttachmentData: async (\n            documentId: string,\n            attachmentId: string,\n            digest: string\n        ) => {\n            let data = await instance.getAttachmentData(documentId, attachmentId, digest);\n            data = await modifyAttachmentFromStorage(data);\n            return data;\n        },\n        findDocumentsById: (ids, deleted) => {\n            return instance.findDocumentsById(ids, deleted)\n                .then(async (findResult) => {\n                    const ret: RxDocumentData<RxDocType>[] = [];\n                    await Promise.all(\n                        findResult\n                            .map(async (doc) => {\n                                ret.push(await fromStorage(doc));\n                            })\n                    );\n                    return ret;\n                });\n        },\n        getChangedDocumentsSince: !instance.getChangedDocumentsSince ? undefined : (limit, checkpoint) => {\n            return ((instance as any).getChangedDocumentsSince)(limit, checkpoint)\n                .then(async (result: any) => {\n                    return {\n                        checkpoint: result.checkpoint,\n                        documents: await Promise.all(\n                            result.documents.map((d: any) => fromStorage(d))\n                        )\n                    };\n                });\n        },\n        changeStream: () => {\n            return instance.changeStream().pipe(\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)),\n                mergeMap(async (eventBulk) => {\n                    const useEvents = await Promise.all(\n                        eventBulk.events.map(async (event) => {\n                            const [\n                                documentData,\n                                previousDocumentData\n                            ] = await Promise.all([\n                                fromStorage(event.documentData),\n                                fromStorage(event.previousDocumentData)\n                            ]);\n                            const ev: RxChangeEvent<RxDocType> = {\n                                operation: event.operation,\n                                documentId: event.documentId,\n                                documentData: documentData as any,\n                                previousDocumentData: previousDocumentData as any,\n                                isLocal: false\n                            };\n                            return ev;\n                        })\n                    );\n                    const ret: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any> = {\n                        id: eventBulk.id,\n                        events: useEvents,\n                        checkpoint: eventBulk.checkpoint,\n                        context: eventBulk.context\n                    };\n                    return ret;\n                }),\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1))\n            );\n        },\n    };\n\n    return wrappedInstance;\n}\n"],
  "mappings": "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",
  "names": ["VALIDATOR_CACHE_BY_VALIDATOR_KEY", "Map", "wrappedValidateStorageFactory", "getValidator", "validatorKey", "VALIDATOR_CACHE", "getFromMapOrCreate", "initValidator", "schema", "JSON", "stringify", "args", "Object", "assign", "storage", "name", "createStorageInstance", "params", "instance", "primaryPath", "getPrimaryFieldOfPrimaryKey", "primaryKey", "validatorCached", "requestIdleCallbackIfAvailable", "oldBulkWrite", "bulkWrite", "bind", "documentWrites", "context", "errors", "continueWrites", "forEach", "row", "documentId", "document", "validationErrors", "length", "push", "status", "isError", "writeRow", "writePromise", "Promise", "resolve", "error", "success", "then", "writeResult", "validationError", "wrapRxStorageInstance", "originalSchema", "modifyToStorage", "modifyFromStorage", "modifyAttachmentFromStorage", "v", "toStorage", "docData", "fromStorage", "errorFromStorage", "ret", "flatClone", "documentInDb", "previous", "processingChangesCount$", "BehaviorSubject", "wrappedInstance", "databaseName", "internals", "cleanup", "options", "close", "collectionName", "count", "remove", "originalStorageInstance", "useRows", "all", "map", "undefined", "promises", "err", "firstValueFrom", "pipe", "filter", "query", "preparedQuery", "queryResult", "documents", "doc", "getAttachmentData", "attachmentId", "digest", "data", "findDocumentsById", "ids", "deleted", "findResult", "getChangedDocumentsSince", "limit", "checkpoint", "result", "d", "changeStream", "tap", "next", "getValue", "mergeMap", "eventBulk", "useEvents", "events", "event", "documentData", "previousDocumentData", "ev", "operation", "isLocal", "id"]
}
