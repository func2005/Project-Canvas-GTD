import {
  COLLECTIONS_WITH_RUNNING_CLEANUP,
  DEFAULT_TRY_TO_KEEP_MAX,
  DEFAULT_UNEXECUTED_LIFETIME,
  INTERNAL_CONTEXT_COLLECTION,
  INTERNAL_CONTEXT_MIGRATION_STATUS,
  INTERNAL_CONTEXT_PIPELINE_CHECKPOINT,
  INTERNAL_CONTEXT_STORAGE_TOKEN,
  INTERNAL_STORE_SCHEMA,
  INTERNAL_STORE_SCHEMA_TITLE,
  OPEN_COLLECTIONS,
  QueryCache,
  RxCollectionBase,
  RxDatabaseBase,
  RxQueryBase,
  RxQuerySingleResult,
  RxSchema,
  STORAGE_TOKEN_DOCUMENT_ID,
  STORAGE_TOKEN_DOCUMENT_KEY,
  _collectionNamePrimary,
  _getDefaultQuery,
  addConnectedStorageToCollection,
  basePrototype,
  beforeDocumentUpdateWrite,
  countRxQuerySubscribers,
  createNewRxDocument,
  createQueryCache,
  createRxCollection,
  createRxCollectionStorageInstance,
  createRxDatabase,
  createRxDatabaseStorageInstance,
  createRxDocumentConstructor,
  createRxQuery,
  createRxSchema,
  createWithConstructor,
  dbCount,
  defaultCacheReplacementPolicy,
  defaultCacheReplacementPolicyMonad,
  defaultConflictHandler,
  ensureNoStartupErrors,
  ensureRxCollectionIsNotClosed,
  ensureStorageTokenDocumentExists,
  fillObjectDataBeforeInsert,
  flattenEvents,
  getAllCollectionDocuments,
  getDocumentDataOfRxChangeEvent,
  getDocumentOrmPrototype,
  getDocumentPrototype,
  getIndexes,
  getPreviousVersions,
  getPrimaryKeyOfInternalDocument,
  getRxDocumentConstructor,
  isDatabaseStateVersionCompatibleWithDatabaseCode,
  isFindOneByIdQuery,
  isRxCollection,
  isRxDatabase,
  isRxDatabaseFirstTimeInstantiated,
  isRxDocument,
  isRxQuery,
  isRxSchema,
  queryCollection,
  removeCollectionStorages,
  removeConnectedStorageFromCollection,
  removeRxDatabase,
  rxChangeEventBulkToRxChangeEvents,
  rxChangeEventToEventReduceChangeEvent,
  toTypedRxJsonSchema,
  triggerCacheReplacement,
  tunnelQueryCache,
  uncacheRxQuery
} from "./chunk-MFGZ5JAX.js";
import {
  wrapRxStorageInstance,
  wrappedValidateStorageFactory
} from "./chunk-5ERC5DLV.js";
import {
  BROADCAST_CHANNEL_BY_TOKEN,
  addRxStorageMultiInstanceSupport,
  getBroadcastChannelReference,
  removeBroadcastChannelReference
} from "./chunk-CG4BLLEP.js";
import {
  HOOKS,
  INTERNAL_STORAGE_NAME,
  RX_DATABASE_LOCAL_DOCS_STORAGE_NAME,
  _clearHook,
  attachmentWriteDataToNormalData,
  categorizeBulkWriteRows,
  ensureRxStorageInstanceParamsAreCorrect,
  flatCloneDocWithMeta,
  getAttachmentSize,
  getChangedDocumentsSince,
  getChangedDocumentsSinceQuery,
  getSingleDocument,
  getWrappedStorageInstance,
  getWrittenDocumentsFromBulkWriteResponse,
  hasEncryption,
  observeSingle,
  randomDelayStorage,
  runAsyncPluginHooks,
  runPluginHooks,
  stackCheckpoints,
  stripAttachmentsDataFromDocument,
  stripAttachmentsDataFromRow,
  throwIfIsStorageWriteError,
  writeSingle
} from "./chunk-NEJ5EZVI.js";
import {
  INDEX_MAX,
  INDEX_MIN,
  LOGICAL_OPERATORS,
  LOWER_BOUND_LOGICAL_OPERATORS,
  UPPER_BOUND_LOGICAL_OPERATORS,
  getMatcherQueryOpts,
  getQueryMatcher,
  getQueryPlan,
  getSortComparator,
  isSelectorSatisfiedByIndex,
  normalizeMangoQuery,
  prepareQuery,
  rateQueryPlan,
  runQueryUpdateFunction
} from "./chunk-4H7V2DEK.js";
import {
  BehaviorSubject,
  Subject,
  combineLatest,
  filter,
  firstValueFrom,
  mergeMap
} from "./chunk-7CIGBAPP.js";
import {
  DEFAULT_CHECKPOINT_SCHEMA,
  META_LWT_UNIX_TIME_MAX,
  NON_PREMIUM_COLLECTION_LIMIT,
  PREMIUM_FLAG_HASH,
  PROMISE_RESOLVE_FALSE,
  PROMISE_RESOLVE_NULL,
  PROMISE_RESOLVE_TRUE,
  PROMISE_RESOLVE_VOID,
  RANDOM_STRING,
  REGEX_ALL_DOTS,
  REGEX_ALL_PIPES,
  RXDB_UTILS_GLOBAL,
  RXDB_VERSION,
  RXJS_SHARE_REPLAY_DEFAULTS,
  RX_META_LWT_MINIMUM,
  RX_META_SCHEMA,
  RxError,
  RxTypeError,
  appendToArray,
  areRxDocumentArraysEqual,
  arrayBufferToBase64,
  arrayBufferToString,
  arrayFilterNotEmpty,
  asyncFilter,
  b64DecodeUnicode,
  b64EncodeUnicode,
  base64ToArrayBuffer,
  batchArray,
  blobToBase64String,
  blobToString,
  clone,
  countUntilNotMatching,
  createBlob,
  createBlobFromBase64,
  createRevision,
  customFetchWithFixedHeaders,
  deepEqual,
  deepFreeze,
  deepKeys,
  defaultHashSha256,
  deleteProperty,
  ensureInteger,
  ensureNotFalsy,
  errorToPlainJson,
  errorUrlHint,
  fillObjectWithDefaults,
  fillPrimaryKey,
  fillWithDefaultSettings,
  findUndefinedPath,
  firstPropertyNameOfObject,
  firstPropertyValueOfObject,
  flatClone,
  flattenObject,
  getBlobSize,
  getComposedPrimaryKeyOfDocumentData,
  getDefaultIndex,
  getDefaultRevision,
  getDefaultRxDocumentMeta,
  getErrorUrl,
  getFinalFields,
  getFromMapOrCreate,
  getFromMapOrThrow,
  getFromObjectOrThrow,
  getHeightOfRevision,
  getLengthOfPrimaryKey,
  getPrimaryFieldOfPrimaryKey,
  getProperty,
  getPseudoSchemaForVersion,
  getSchemaByObjectPath,
  getSortDocumentsByLastWriteTimeComparator,
  hasDeepProperty,
  hasPremiumFlag,
  hasProperty,
  hashStringToNumber,
  isBulkWriteConflictError,
  isFolderPath,
  isMaybeReadonlyArray,
  isOneItemOfArrayInOtherArray,
  isPromise,
  lastCharOfString,
  lastOfArray,
  maxOfNumbers,
  nameFunction,
  nativeSha256,
  newRxError,
  newRxTypeError,
  nextTick,
  normalizeRxJsonSchema,
  normalizeString,
  now,
  objectPathMonad,
  overwritable,
  overwriteGetterForCaching,
  parseRevision,
  pluginMissing,
  promiseSeries,
  promiseWait,
  randomNumber,
  randomOfArray,
  randomToken,
  removeOneFromArrayIfMatches,
  requestIdleCallbackIfAvailable,
  requestIdlePromise,
  requestIdlePromiseNoQueue,
  runXTimes,
  rxStorageWriteErrorToRxError,
  setProperty,
  shuffleArray,
  sortByObjectNumberProperty,
  sortDocumentsByLastWriteTime,
  sortObject,
  stringToArrayBuffer,
  stripMetaDataFromDocument,
  sumNumberArray,
  toArray,
  toPromise,
  toWithDeleted,
  trimDots,
  ucfirst,
  uniqueArray
} from "./chunk-NM3SVBJO.js";
import "./chunk-C3M7BXFS.js";

// ../../node_modules/rxdb/dist/esm/plugin.js
var PROTOTYPES = {
  RxSchema: RxSchema.prototype,
  RxDocument: basePrototype,
  RxQuery: RxQueryBase.prototype,
  RxCollection: RxCollectionBase.prototype,
  RxDatabase: RxDatabaseBase.prototype
};
var ADDED_PLUGINS = /* @__PURE__ */ new Set();
var ADDED_PLUGIN_NAMES = /* @__PURE__ */ new Set();
function addRxPlugin(plugin) {
  runPluginHooks("preAddRxPlugin", {
    plugin,
    plugins: ADDED_PLUGINS
  });
  if (ADDED_PLUGINS.has(plugin)) {
    return;
  } else {
    if (ADDED_PLUGIN_NAMES.has(plugin.name)) {
      throw newRxError("PL3", {
        name: plugin.name,
        plugin
      });
    }
    ADDED_PLUGINS.add(plugin);
    ADDED_PLUGIN_NAMES.add(plugin.name);
  }
  if (!plugin.rxdb) {
    throw newRxTypeError("PL1", {
      plugin
    });
  }
  if (plugin.init) {
    plugin.init();
  }
  if (plugin.prototypes) {
    Object.entries(plugin.prototypes).forEach(([name, fun]) => {
      return fun(PROTOTYPES[name]);
    });
  }
  if (plugin.overwritable) {
    Object.assign(overwritable, plugin.overwritable);
  }
  if (plugin.hooks) {
    Object.entries(plugin.hooks).forEach(([name, hooksObj]) => {
      if (hooksObj.after) {
        HOOKS[name].push(hooksObj.after);
      }
      if (hooksObj.before) {
        HOOKS[name].unshift(hooksObj.before);
      }
    });
  }
}

// ../../node_modules/rxdb/dist/esm/replication-protocol/checkpoint.js
async function getLastCheckpointDoc(state, direction) {
  var checkpointDocId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {
    isCheckpoint: "1",
    itemId: direction
  });
  var checkpointResult = await state.input.metaInstance.findDocumentsById([checkpointDocId], false);
  var checkpointDoc = checkpointResult[0];
  state.lastCheckpointDoc[direction] = checkpointDoc;
  if (checkpointDoc) {
    return checkpointDoc.checkpointData;
  } else {
    return void 0;
  }
}
async function setCheckpoint(state, direction, checkpoint) {
  state.checkpointQueue = state.checkpointQueue.then(async () => {
    var previousCheckpointDoc = state.lastCheckpointDoc[direction];
    if (checkpoint && /**
     * If the replication is already canceled,
     * we do not write a checkpoint
     * because that could mean we write a checkpoint
     * for data that has been fetched from the master
     * but not been written to the child.
     */
    !state.events.canceled.getValue() && /**
     * Only write checkpoint if it is different from before
     * to have less writes to the storage.
     */
    (!previousCheckpointDoc || JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint))) {
      var newDoc = {
        id: "",
        isCheckpoint: "1",
        itemId: direction,
        _deleted: false,
        _attachments: {},
        checkpointData: checkpoint,
        _meta: getDefaultRxDocumentMeta(),
        _rev: getDefaultRevision()
      };
      newDoc.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newDoc);
      while (!state.events.canceled.getValue()) {
        if (previousCheckpointDoc) {
          newDoc.checkpointData = stackCheckpoints([previousCheckpointDoc.checkpointData, newDoc.checkpointData]);
        }
        newDoc._meta.lwt = now();
        newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);
        if (state.events.canceled.getValue()) {
          return;
        }
        var writeRows = [{
          previous: previousCheckpointDoc,
          document: newDoc
        }];
        var result = await state.input.metaInstance.bulkWrite(writeRows, "replication-set-checkpoint");
        var successDoc = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRows, result)[0];
        if (successDoc) {
          state.lastCheckpointDoc[direction] = successDoc;
          return;
        } else {
          var error = result.error[0];
          if (error.status !== 409) {
            throw error;
          } else {
            previousCheckpointDoc = ensureNotFalsy(error.documentInDb);
            newDoc._rev = createRevision(await state.checkpointKey, previousCheckpointDoc);
          }
        }
      }
    }
  });
  await state.checkpointQueue;
}
async function getCheckpointKey(input) {
  var hash = await input.hashFunction([input.identifier, input.forkInstance.databaseName, input.forkInstance.collectionName].join("||"));
  return "rx_storage_replication_" + hash;
}

// ../../node_modules/rxdb/dist/esm/replication-protocol/helper.js
function docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, docState, previous) {
  var docData = Object.assign({}, docState, {
    _attachments: hasAttachments && docState._attachments ? docState._attachments : {},
    _meta: keepMeta ? docState._meta : Object.assign({}, previous ? previous._meta : {}, {
      lwt: now()
    }),
    _rev: keepMeta ? docState._rev : getDefaultRevision()
  });
  if (!docData._rev) {
    docData._rev = createRevision(databaseInstanceToken, previous);
  }
  return docData;
}
function writeDocToDocState(writeDoc, keepAttachments, keepMeta) {
  var ret = flatClone(writeDoc);
  if (!keepAttachments) {
    delete ret._attachments;
  }
  if (!keepMeta) {
    delete ret._meta;
    delete ret._rev;
  }
  return ret;
}
function stripAttachmentsDataFromMetaWriteRows(state, rows) {
  if (!state.hasAttachments) {
    return rows;
  }
  return rows.map((row) => {
    var document = clone(row.document);
    document.docData = stripAttachmentsDataFromDocument(document.docData);
    return {
      document,
      previous: row.previous
    };
  });
}
function getUnderlyingPersistentStorage(instance) {
  while (true) {
    if (instance.underlyingPersistentStorage) {
      instance = instance.underlyingPersistentStorage;
    } else {
      return instance;
    }
  }
}

// ../../node_modules/rxdb/dist/esm/replication-protocol/meta-instance.js
var META_INSTANCE_SCHEMA_TITLE = "RxReplicationProtocolMetaData";
function getRxReplicationMetaInstanceSchema(replicatedDocumentsSchema, encrypted) {
  var parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);
  var baseSchema = {
    title: META_INSTANCE_SCHEMA_TITLE,
    primaryKey: {
      key: "id",
      fields: ["itemId", "isCheckpoint"],
      separator: "|"
    },
    type: "object",
    version: replicatedDocumentsSchema.version,
    additionalProperties: false,
    properties: {
      id: {
        type: "string",
        minLength: 1,
        // add +1 for the '|' and +1 for the 'isCheckpoint' flag
        maxLength: parentPrimaryKeyLength + 2
      },
      isCheckpoint: {
        type: "string",
        enum: ["0", "1"],
        minLength: 1,
        maxLength: 1
      },
      itemId: {
        type: "string",
        /**
         * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it
         * because checkpoints use the itemId field for that.
         */
        maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4
      },
      checkpointData: {
        type: "object",
        additionalProperties: true
      },
      docData: {
        type: "object",
        properties: replicatedDocumentsSchema.properties
      },
      isResolvedConflict: {
        type: "string"
      }
    },
    keyCompression: replicatedDocumentsSchema.keyCompression,
    required: ["id", "isCheckpoint", "itemId"]
  };
  if (encrypted) {
    baseSchema.encrypted = ["docData"];
  }
  var metaInstanceSchema = fillWithDefaultSettings(baseSchema);
  return metaInstanceSchema;
}
function getAssumedMasterState(state, docIds) {
  return state.input.metaInstance.findDocumentsById(docIds.map((docId) => {
    var useId = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, {
      itemId: docId,
      isCheckpoint: "0"
    });
    return useId;
  }), true).then((metaDocs) => {
    var ret = {};
    Object.values(metaDocs).forEach((metaDoc) => {
      ret[metaDoc.itemId] = {
        docData: metaDoc.docData,
        metaDocument: metaDoc
      };
    });
    return ret;
  });
}
async function getMetaWriteRow(state, newMasterDocState, previous, isResolvedConflict) {
  var docId = newMasterDocState[state.primaryPath];
  var newMeta = previous ? flatCloneDocWithMeta(previous) : {
    id: "",
    isCheckpoint: "0",
    itemId: docId,
    docData: newMasterDocState,
    _attachments: {},
    _deleted: false,
    _rev: getDefaultRevision(),
    _meta: {
      lwt: 0
    }
  };
  newMeta.docData = newMasterDocState;
  if (isResolvedConflict) {
    newMeta.isResolvedConflict = isResolvedConflict;
  }
  newMeta._meta.lwt = now();
  newMeta.id = getComposedPrimaryKeyOfDocumentData(state.input.metaInstance.schema, newMeta);
  newMeta._rev = createRevision(await state.checkpointKey, previous);
  var ret = {
    previous,
    document: newMeta
  };
  return ret;
}

// ../../node_modules/rxdb/dist/esm/replication-protocol/downstream.js
async function startReplicationDownstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.downstream) {
    var checkpointDoc = await getLastCheckpointDoc(state, "down");
    if (!checkpointDoc) {
      await setCheckpoint(state, "down", state.input.initialCheckpoint.downstream);
    }
  }
  var identifierHash = await state.input.hashFunction(state.input.identifier);
  var replicationHandler = state.input.replicationHandler;
  var timer = 0;
  var openTasks = [];
  function addNewTask(task) {
    state.stats.down.addNewTask = state.stats.down.addNewTask + 1;
    var taskWithTime = {
      time: timer++,
      task
    };
    openTasks.push(taskWithTime);
    state.streamQueue.down = state.streamQueue.down.then(() => {
      var useTasks = [];
      while (openTasks.length > 0) {
        state.events.active.down.next(true);
        var innerTaskWithTime = ensureNotFalsy(openTasks.shift());
        if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {
          continue;
        }
        if (innerTaskWithTime.task === "RESYNC") {
          if (useTasks.length === 0) {
            useTasks.push(innerTaskWithTime.task);
            break;
          } else {
            break;
          }
        }
        useTasks.push(innerTaskWithTime.task);
      }
      if (useTasks.length === 0) {
        return;
      }
      if (useTasks[0] === "RESYNC") {
        return downstreamResyncOnce();
      } else {
        return downstreamProcessChanges(useTasks);
      }
    }).then(() => {
      state.events.active.down.next(false);
      if (!state.firstSyncDone.down.getValue() && !state.events.canceled.getValue()) {
        state.firstSyncDone.down.next(true);
      }
    });
  }
  addNewTask("RESYNC");
  if (!state.events.canceled.getValue()) {
    var sub = replicationHandler.masterChangeStream$.pipe(mergeMap(async (ev) => {
      await firstValueFrom(state.events.active.up.pipe(filter((s) => !s)));
      return ev;
    })).subscribe((task) => {
      state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;
      addNewTask(task);
    });
    firstValueFrom(state.events.canceled.pipe(filter((canceled) => !!canceled))).then(() => sub.unsubscribe());
  }
  var lastTimeMasterChangesRequested = -1;
  async function downstreamResyncOnce() {
    state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, "down"));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = [];
    while (!state.events.canceled.getValue()) {
      lastTimeMasterChangesRequested = timer++;
      var downResult = await replicationHandler.masterChangesSince(lastCheckpoint, state.input.pullBatchSize);
      if (downResult.documents.length === 0) {
        break;
      }
      lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);
      promises.push(persistFromMaster(downResult.documents, lastCheckpoint));
      if (downResult.documents.length < state.input.pullBatchSize) {
        break;
      }
    }
    await Promise.all(promises);
  }
  function downstreamProcessChanges(tasks) {
    state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;
    var docsOfAllTasks = [];
    var lastCheckpoint = null;
    tasks.forEach((task) => {
      if (task === "RESYNC") {
        throw new Error("SNH");
      }
      appendToArray(docsOfAllTasks, task.documents);
      lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);
    });
    return persistFromMaster(docsOfAllTasks, ensureNotFalsy(lastCheckpoint));
  }
  var persistenceQueue = PROMISE_RESOLVE_VOID;
  var nonPersistedFromMaster = {
    docs: {}
  };
  function persistFromMaster(docs, checkpoint) {
    var primaryPath = state.primaryPath;
    state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;
    docs.forEach((docData) => {
      var docId = docData[primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint;
    persistenceQueue = persistenceQueue.then(() => {
      var downDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(downDocsById);
      if (state.events.canceled.getValue() || docIds.length === 0) {
        return PROMISE_RESOLVE_VOID;
      }
      var writeRowsToFork = [];
      var writeRowsToForkById = {};
      var writeRowsToMeta = {};
      var useMetaWriteRows = [];
      return Promise.all([state.input.forkInstance.findDocumentsById(docIds, true), getAssumedMasterState(state, docIds)]).then(([currentForkStateList, assumedMasterState]) => {
        var currentForkState = /* @__PURE__ */ new Map();
        currentForkStateList.forEach((doc) => currentForkState.set(doc[primaryPath], doc));
        return Promise.all(docIds.map(async (docId) => {
          var forkStateFullDoc = currentForkState.get(docId);
          var forkStateDocData = forkStateFullDoc ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false) : void 0;
          var masterState = downDocsById[docId];
          var assumedMaster = assumedMasterState[docId];
          if (assumedMaster && forkStateFullDoc && assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev) {
            await state.streamQueue.up;
          }
          var isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ? false : state.input.conflictHandler.isEqual(assumedMaster.docData, forkStateDocData, "downstream-check-if-equal-0");
          if (!isAssumedMasterEqualToForkState && assumedMaster && assumedMaster.docData._rev && forkStateFullDoc && forkStateFullDoc._meta[state.input.identifier] && getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]) {
            isAssumedMasterEqualToForkState = true;
          }
          if (forkStateFullDoc && assumedMaster && isAssumedMasterEqualToForkState === false || forkStateFullDoc && !assumedMaster) {
            return PROMISE_RESOLVE_VOID;
          }
          var areStatesExactlyEqual = !forkStateDocData ? false : state.input.conflictHandler.isEqual(masterState, forkStateDocData, "downstream-check-if-equal-1");
          if (forkStateDocData && areStatesExactlyEqual) {
            if (!assumedMaster || isAssumedMasterEqualToForkState === false) {
              useMetaWriteRows.push(await getMetaWriteRow(state, forkStateDocData, assumedMaster ? assumedMaster.metaDocument : void 0));
            }
            return PROMISE_RESOLVE_VOID;
          }
          var newForkState = Object.assign({}, masterState, forkStateFullDoc ? {
            _meta: flatClone(forkStateFullDoc._meta),
            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},
            _rev: getDefaultRevision()
          } : {
            _meta: {
              lwt: now()
            },
            _rev: getDefaultRevision(),
            _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}
          });
          if (masterState._rev) {
            var nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;
            newForkState._meta[state.input.identifier] = nextRevisionHeight;
            if (state.input.keepMeta) {
              newForkState._rev = masterState._rev;
            }
          }
          if (state.input.keepMeta && masterState._meta) {
            newForkState._meta = masterState._meta;
          }
          var forkWriteRow = {
            previous: forkStateFullDoc,
            document: newForkState
          };
          forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(identifierHash, forkWriteRow.previous);
          writeRowsToFork.push(forkWriteRow);
          writeRowsToForkById[docId] = forkWriteRow;
          writeRowsToMeta[docId] = await getMetaWriteRow(state, masterState, assumedMaster ? assumedMaster.metaDocument : void 0);
        }));
      }).then(async () => {
        if (writeRowsToFork.length > 0) {
          return state.input.forkInstance.bulkWrite(writeRowsToFork, await state.downstreamBulkWriteFlag).then((forkWriteResult) => {
            var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, writeRowsToFork, forkWriteResult);
            success.forEach((doc) => {
              var docId = doc[primaryPath];
              state.events.processed.down.next(writeRowsToForkById[docId]);
              useMetaWriteRows.push(writeRowsToMeta[docId]);
            });
            var mustThrow;
            forkWriteResult.error.forEach((error) => {
              if (error.status === 409) {
                return;
              }
              var throwMe = newRxError("RC_PULL", {
                writeError: error
              });
              state.events.error.next(throwMe);
              mustThrow = throwMe;
            });
            if (mustThrow) {
              throw mustThrow;
            }
          });
        }
      }).then(() => {
        if (useMetaWriteRows.length > 0) {
          return state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows), "replication-down-write-meta").then((metaWriteResult) => {
            metaWriteResult.error.forEach((writeError) => {
              state.events.error.next(newRxError("RC_PULL", {
                id: writeError.documentId,
                writeError
              }));
            });
          });
        }
      }).then(() => {
        setCheckpoint(state, "down", useCheckpoint);
      });
    }).catch((unhandledError) => state.events.error.next(unhandledError));
    return persistenceQueue;
  }
}

// ../../node_modules/rxdb/dist/esm/replication-protocol/conflicts.js
async function resolveConflictError(state, input, forkState) {
  var conflictHandler = state.input.conflictHandler;
  var isEqual = conflictHandler.isEqual(input.realMasterState, input.newDocumentState, "replication-resolve-conflict");
  if (isEqual) {
    return void 0;
  } else {
    var resolved = await conflictHandler.resolve(input, "replication-resolve-conflict");
    var resolvedDoc = Object.assign({}, resolved, {
      /**
       * Because the resolved conflict is written to the fork,
       * we have to keep/update the forks _meta data, not the masters.
       */
      _meta: flatClone(forkState._meta),
      _rev: getDefaultRevision(),
      _attachments: flatClone(forkState._attachments)
    });
    resolvedDoc._meta.lwt = now();
    resolvedDoc._rev = createRevision(await state.checkpointKey, forkState);
    return resolvedDoc;
  }
}

// ../../node_modules/rxdb/dist/esm/plugins/attachments/attachments-utils.js
function assignMethodsToAttachment(attachment) {
  Object.entries(attachment.doc.collection.attachments).forEach(([funName, fun]) => {
    Object.defineProperty(attachment, funName, {
      get: () => fun.bind(attachment)
    });
  });
}
async function fillWriteDataForAttachmentsChange(primaryPath, storageInstance, newDocument, originalDocument) {
  if (!newDocument._attachments || originalDocument && !originalDocument._attachments) {
    throw new Error("_attachments missing");
  }
  var docId = newDocument[primaryPath];
  var originalAttachmentsIds = new Set(originalDocument && originalDocument._attachments ? Object.keys(originalDocument._attachments) : []);
  await Promise.all(Object.entries(newDocument._attachments).map(async ([key, value]) => {
    if ((!originalAttachmentsIds.has(key) || originalDocument && ensureNotFalsy(originalDocument._attachments)[key].digest !== value.digest) && !value.data) {
      var attachmentDataString = await storageInstance.getAttachmentData(docId, key, value.digest);
      value.data = attachmentDataString;
    }
  }));
  return newDocument;
}

// ../../node_modules/rxdb/dist/esm/plugins/attachments/index.js
var RxAttachment = function() {
  function RxAttachment2({
    doc,
    id,
    type,
    length,
    digest
  }) {
    this.doc = doc;
    this.id = id;
    this.type = type;
    this.length = length;
    this.digest = digest;
    assignMethodsToAttachment(this);
  }
  var _proto = RxAttachment2.prototype;
  _proto.remove = function remove() {
    return this.doc.collection.incrementalWriteQueue.addWrite(this.doc._data, (docWriteData) => {
      delete docWriteData._attachments[this.id];
      return docWriteData;
    }).then(() => {
    });
  };
  _proto.getData = async function getData() {
    var plainDataBase64 = await this.getDataBase64();
    var ret = await createBlobFromBase64(plainDataBase64, this.type);
    return ret;
  };
  _proto.getStringData = async function getStringData() {
    var data = await this.getData();
    var asString = await blobToString(data);
    return asString;
  };
  _proto.getDataBase64 = async function getDataBase64() {
    var plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(this.doc.primary, this.id, this.digest);
    return plainDataBase64;
  };
  return RxAttachment2;
}();

// ../../node_modules/rxdb/dist/esm/replication-protocol/upstream.js
async function startReplicationUpstream(state) {
  if (state.input.initialCheckpoint && state.input.initialCheckpoint.upstream) {
    var checkpointDoc = await getLastCheckpointDoc(state, "up");
    if (!checkpointDoc) {
      await setCheckpoint(state, "up", state.input.initialCheckpoint.upstream);
    }
  }
  var replicationHandler = state.input.replicationHandler;
  state.streamQueue.up = state.streamQueue.up.then(() => {
    return upstreamInitialSync().then(() => {
      return processTasks();
    });
  });
  var timer = 0;
  var initialSyncStartTime = -1;
  var openTasks = [];
  var persistenceQueue = PROMISE_RESOLVE_FALSE;
  var nonPersistedFromMaster = {
    docs: {}
  };
  var sub = state.input.forkInstance.changeStream().subscribe((eventBulk) => {
    if (state.events.paused.getValue()) {
      return;
    }
    state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;
    openTasks.push({
      task: eventBulk,
      time: timer++
    });
    if (!state.events.active.up.getValue()) {
      state.events.active.up.next(true);
    }
    if (state.input.waitBeforePersist) {
      return state.input.waitBeforePersist().then(() => processTasks());
    } else {
      return processTasks();
    }
  });
  var subResync = replicationHandler.masterChangeStream$.pipe(filter((ev) => ev === "RESYNC")).subscribe(() => {
    openTasks.push({
      task: "RESYNC",
      time: timer++
    });
    processTasks();
  });
  firstValueFrom(state.events.canceled.pipe(filter((canceled) => !!canceled))).then(() => {
    sub.unsubscribe();
    subResync.unsubscribe();
  });
  async function upstreamInitialSync() {
    state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;
    if (state.events.canceled.getValue()) {
      return;
    }
    state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, "up"));
    var lastCheckpoint = await state.checkpointQueue;
    var promises = /* @__PURE__ */ new Set();
    var _loop = async function() {
      initialSyncStartTime = timer++;
      if (promises.size > 3) {
        await Promise.race(Array.from(promises));
      }
      var upResult = await getChangedDocumentsSince(state.input.forkInstance, state.input.pushBatchSize, lastCheckpoint);
      if (upResult.documents.length === 0) {
        return 1;
      }
      lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);
      var promise = persistToMaster(upResult.documents, ensureNotFalsy(lastCheckpoint));
      promises.add(promise);
      promise.catch().then(() => promises.delete(promise));
    };
    while (!state.events.canceled.getValue()) {
      if (await _loop())
        break;
    }
    var resolvedPromises = await Promise.all(promises);
    var hadConflicts = resolvedPromises.find((r) => !!r);
    if (hadConflicts) {
      await upstreamInitialSync();
    } else if (!state.firstSyncDone.up.getValue() && !state.events.canceled.getValue()) {
      state.firstSyncDone.up.next(true);
    }
  }
  function processTasks() {
    if (state.events.canceled.getValue() || openTasks.length === 0) {
      state.events.active.up.next(false);
      return;
    }
    state.stats.up.processTasks = state.stats.up.processTasks + 1;
    state.events.active.up.next(true);
    state.streamQueue.up = state.streamQueue.up.then(async () => {
      var docs = [];
      var checkpoint;
      while (openTasks.length > 0) {
        var taskWithTime = ensureNotFalsy(openTasks.shift());
        if (taskWithTime.time < initialSyncStartTime) {
          continue;
        }
        if (taskWithTime.task === "RESYNC") {
          state.events.active.up.next(false);
          await upstreamInitialSync();
          return;
        }
        if (taskWithTime.task.context !== await state.downstreamBulkWriteFlag) {
          appendToArray(docs, taskWithTime.task.events.map((r) => {
            return r.documentData;
          }));
        }
        checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);
      }
      await persistToMaster(docs, checkpoint);
      if (openTasks.length === 0) {
        state.events.active.up.next(false);
      } else {
        return processTasks();
      }
    });
  }
  function persistToMaster(docs, checkpoint) {
    state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;
    docs.forEach((docData) => {
      var docId = docData[state.primaryPath];
      nonPersistedFromMaster.docs[docId] = docData;
    });
    nonPersistedFromMaster.checkpoint = checkpoint;
    persistenceQueue = persistenceQueue.then(async () => {
      if (state.events.canceled.getValue()) {
        return false;
      }
      var upDocsById = nonPersistedFromMaster.docs;
      nonPersistedFromMaster.docs = {};
      var useCheckpoint = nonPersistedFromMaster.checkpoint;
      var docIds = Object.keys(upDocsById);
      function rememberCheckpointBeforeReturn() {
        return setCheckpoint(state, "up", useCheckpoint);
      }
      ;
      if (docIds.length === 0) {
        rememberCheckpointBeforeReturn();
        return false;
      }
      var assumedMasterState = await getAssumedMasterState(state, docIds);
      var writeRowsToMaster = {};
      var writeRowsToMasterIds = [];
      var writeRowsToMeta = {};
      var forkStateById = {};
      await Promise.all(docIds.map(async (docId) => {
        var fullDocData = upDocsById[docId];
        forkStateById[docId] = fullDocData;
        var docData = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);
        var assumedMasterDoc = assumedMasterState[docId];
        if (assumedMasterDoc && // if the isResolvedConflict is correct, we do not have to compare the documents.
        assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev && state.input.conflictHandler.isEqual(assumedMasterDoc.docData, docData, "upstream-check-if-equal") || /**
         * If the master works with _rev fields,
         * we use that to check if our current doc state
         * is different from the assumedMasterDoc.
         */
        assumedMasterDoc && assumedMasterDoc.docData._rev && getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier]) {
          return;
        }
        writeRowsToMasterIds.push(docId);
        writeRowsToMaster[docId] = {
          assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : void 0,
          newDocumentState: docData
        };
        writeRowsToMeta[docId] = await getMetaWriteRow(state, docData, assumedMasterDoc ? assumedMasterDoc.metaDocument : void 0);
      }));
      if (writeRowsToMasterIds.length === 0) {
        rememberCheckpointBeforeReturn();
        return false;
      }
      var writeRowsArray = Object.values(writeRowsToMaster);
      var conflictIds = /* @__PURE__ */ new Set();
      var conflictsById = {};
      var writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);
      await Promise.all(writeBatches.map(async (writeBatch) => {
        if (state.hasAttachments) {
          await Promise.all(writeBatch.map(async (row) => {
            row.newDocumentState = await fillWriteDataForAttachmentsChange(state.primaryPath, state.input.forkInstance, clone(row.newDocumentState), row.assumedMasterState);
          }));
        }
        var masterWriteResult = await replicationHandler.masterWrite(writeBatch);
        masterWriteResult.forEach((conflictDoc) => {
          var id = conflictDoc[state.primaryPath];
          conflictIds.add(id);
          conflictsById[id] = conflictDoc;
        });
      }));
      var useWriteRowsToMeta = [];
      writeRowsToMasterIds.forEach((docId) => {
        if (!conflictIds.has(docId)) {
          state.events.processed.up.next(writeRowsToMaster[docId]);
          useWriteRowsToMeta.push(writeRowsToMeta[docId]);
        }
      });
      if (state.events.canceled.getValue()) {
        return false;
      }
      if (useWriteRowsToMeta.length > 0) {
        await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta), "replication-up-write-meta");
      }
      var hadConflictWrites = false;
      if (conflictIds.size > 0) {
        state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;
        var conflictWriteFork = [];
        var conflictWriteMeta = {};
        await Promise.all(Object.entries(conflictsById).map(([docId, realMasterState]) => {
          var writeToMasterRow = writeRowsToMaster[docId];
          var input = {
            newDocumentState: writeToMasterRow.newDocumentState,
            assumedMasterState: writeToMasterRow.assumedMasterState,
            realMasterState
          };
          return resolveConflictError(state, input, forkStateById[docId]).then(async (resolved) => {
            if (resolved) {
              state.events.resolvedConflicts.next({
                input,
                output: resolved
              });
              conflictWriteFork.push({
                previous: forkStateById[docId],
                document: resolved
              });
              var assumedMasterDoc = assumedMasterState[docId];
              conflictWriteMeta[docId] = await getMetaWriteRow(state, ensureNotFalsy(realMasterState), assumedMasterDoc ? assumedMasterDoc.metaDocument : void 0, resolved._rev);
            }
          });
        }));
        if (conflictWriteFork.length > 0) {
          hadConflictWrites = true;
          state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;
          var forkWriteResult = await state.input.forkInstance.bulkWrite(conflictWriteFork, "replication-up-write-conflict");
          var mustThrow;
          forkWriteResult.error.forEach((error) => {
            if (error.status === 409) {
              return;
            }
            var throwMe = newRxError("RC_PUSH", {
              writeError: error
            });
            state.events.error.next(throwMe);
            mustThrow = throwMe;
          });
          if (mustThrow) {
            throw mustThrow;
          }
          var useMetaWrites = [];
          var success = getWrittenDocumentsFromBulkWriteResponse(state.primaryPath, conflictWriteFork, forkWriteResult);
          success.forEach((docData) => {
            var docId = docData[state.primaryPath];
            useMetaWrites.push(conflictWriteMeta[docId]);
          });
          if (useMetaWrites.length > 0) {
            await state.input.metaInstance.bulkWrite(stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites), "replication-up-write-conflict-meta");
          }
        }
      }
      rememberCheckpointBeforeReturn();
      return hadConflictWrites;
    }).catch((unhandledError) => {
      state.events.error.next(unhandledError);
      return false;
    });
    return persistenceQueue;
  }
}

// ../../node_modules/rxdb/dist/esm/replication-protocol/index.js
function replicateRxStorageInstance(input) {
  input = flatClone(input);
  input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);
  input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);
  var checkpointKeyPromise = getCheckpointKey(input);
  var state = {
    primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),
    hasAttachments: !!input.forkInstance.schema.attachments,
    input,
    checkpointKey: checkpointKeyPromise,
    downstreamBulkWriteFlag: checkpointKeyPromise.then((checkpointKey) => "replication-downstream-" + checkpointKey),
    events: {
      canceled: new BehaviorSubject(false),
      paused: new BehaviorSubject(false),
      active: {
        down: new BehaviorSubject(true),
        up: new BehaviorSubject(true)
      },
      processed: {
        down: new Subject(),
        up: new Subject()
      },
      resolvedConflicts: new Subject(),
      error: new Subject()
    },
    stats: {
      down: {
        addNewTask: 0,
        downstreamProcessChanges: 0,
        downstreamResyncOnce: 0,
        masterChangeStreamEmit: 0,
        persistFromMaster: 0
      },
      up: {
        forkChangeStreamEmit: 0,
        persistToMaster: 0,
        persistToMasterConflictWrites: 0,
        persistToMasterHadConflicts: 0,
        processTasks: 0,
        upstreamInitialSync: 0
      }
    },
    firstSyncDone: {
      down: new BehaviorSubject(false),
      up: new BehaviorSubject(false)
    },
    streamQueue: {
      down: PROMISE_RESOLVE_VOID,
      up: PROMISE_RESOLVE_VOID
    },
    checkpointQueue: PROMISE_RESOLVE_VOID,
    lastCheckpointDoc: {}
  };
  startReplicationDownstream(state);
  startReplicationUpstream(state);
  return state;
}
function awaitRxStorageReplicationFirstInSync(state) {
  return firstValueFrom(combineLatest([state.firstSyncDone.down.pipe(filter((v) => !!v)), state.firstSyncDone.up.pipe(filter((v) => !!v))])).then(() => {
  });
}
function awaitRxStorageReplicationInSync(replicationState) {
  return Promise.all([replicationState.streamQueue.up, replicationState.streamQueue.down, replicationState.checkpointQueue]);
}
async function awaitRxStorageReplicationIdle(state) {
  await awaitRxStorageReplicationFirstInSync(state);
  while (true) {
    var {
      down,
      up
    } = state.streamQueue;
    await Promise.all([up, down]);
    if (down === state.streamQueue.down && up === state.streamQueue.up) {
      return;
    }
  }
}
function rxStorageInstanceToReplicationHandler(instance, conflictHandler, databaseInstanceToken, keepMeta = false) {
  instance = getUnderlyingPersistentStorage(instance);
  var hasAttachments = !!instance.schema.attachments;
  var primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);
  var replicationHandler = {
    masterChangeStream$: instance.changeStream().pipe(mergeMap(async (eventBulk) => {
      var ret = {
        checkpoint: eventBulk.checkpoint,
        documents: await Promise.all(eventBulk.events.map(async (event) => {
          var docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);
          if (hasAttachments) {
            docData = await fillWriteDataForAttachmentsChange(
              primaryPath,
              instance,
              clone(docData),
              /**
               * Notice that the master never knows
               * the client state of the document.
               * Therefore we always send all attachments data.
               */
              void 0
            );
          }
          return docData;
        }))
      };
      return ret;
    })),
    masterChangesSince(checkpoint, batchSize) {
      return getChangedDocumentsSince(instance, batchSize, checkpoint).then(async (result) => {
        return {
          checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,
          documents: await Promise.all(result.documents.map(async (plainDocumentData) => {
            var docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);
            if (hasAttachments) {
              docData = await fillWriteDataForAttachmentsChange(
                primaryPath,
                instance,
                clone(docData),
                /**
                 * Notice the the master never knows
                 * the client state of the document.
                 * Therefore we always send all attachments data.
                 */
                void 0
              );
            }
            return docData;
          }))
        };
      });
    },
    async masterWrite(rows) {
      var rowById = {};
      rows.forEach((row) => {
        var docId = row.newDocumentState[primaryPath];
        rowById[docId] = row;
      });
      var ids = Object.keys(rowById);
      var masterDocsStateList = await instance.findDocumentsById(ids, true);
      var masterDocsState = /* @__PURE__ */ new Map();
      masterDocsStateList.forEach((doc) => masterDocsState.set(doc[primaryPath], doc));
      var conflicts = [];
      var writeRows = [];
      await Promise.all(Object.entries(rowById).map(([id, row]) => {
        var masterState = masterDocsState.get(id);
        if (!masterState) {
          writeRows.push({
            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)
          });
        } else if (masterState && !row.assumedMasterState) {
          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));
        } else if (conflictHandler.isEqual(writeDocToDocState(masterState, hasAttachments, keepMeta), ensureNotFalsy(row.assumedMasterState), "rxStorageInstanceToReplicationHandler-masterWrite") === true) {
          writeRows.push({
            previous: masterState,
            document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)
          });
        } else {
          conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));
        }
      }));
      if (writeRows.length > 0) {
        var result = await instance.bulkWrite(writeRows, "replication-master-write");
        result.error.forEach((err) => {
          if (err.status !== 409) {
            throw newRxError("SNH", {
              name: "non conflict error",
              error: err
            });
          } else {
            conflicts.push(writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta));
          }
        });
      }
      return conflicts;
    }
  };
  return replicationHandler;
}
async function cancelRxStorageReplication(replicationState) {
  replicationState.events.canceled.next(true);
  replicationState.events.active.up.complete();
  replicationState.events.active.down.complete();
  replicationState.events.processed.up.complete();
  replicationState.events.processed.down.complete();
  replicationState.events.resolvedConflicts.complete();
  replicationState.events.canceled.complete();
  await replicationState.checkpointQueue;
}

// ../../node_modules/rxdb/dist/esm/custom-index.js
function getIndexMeta(schema, index) {
  var fieldNameProperties = index.map((fieldName) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    if (!schemaPart) {
      throw new Error("not in schema: " + fieldName);
    }
    var type = schemaPart.type;
    var parsedLengths;
    if (type === "number" || type === "integer") {
      parsedLengths = getStringLengthOfIndexNumber(schemaPart);
    }
    var getValue = objectPathMonad(fieldName);
    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;
    var getIndexStringPart;
    if (type === "string") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        if (!fieldValue) {
          fieldValue = "";
        }
        return fieldValue.padEnd(maxLength, " ");
      };
    } else if (type === "boolean") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return fieldValue ? "1" : "0";
      };
    } else {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return getNumberIndexString(parsedLengths, fieldValue);
      };
    }
    var ret = {
      fieldName,
      schemaPart,
      parsedLengths,
      getValue,
      getIndexStringPart
    };
    return ret;
  });
  return fieldNameProperties;
}
function getIndexableStringMonad(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var fieldNamePropertiesAmount = fieldNameProperties.length;
  var indexPartsFunctions = fieldNameProperties.map((r) => r.getIndexStringPart);
  var ret = function(docData) {
    var str = "";
    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {
      str += indexPartsFunctions[i](docData);
    }
    return str;
  };
  return ret;
}
function getStringLengthOfIndexNumber(schemaPart) {
  var minimum = Math.floor(schemaPart.minimum);
  var maximum = Math.ceil(schemaPart.maximum);
  var multipleOf = schemaPart.multipleOf;
  var valueSpan = maximum - minimum;
  var nonDecimals = valueSpan.toString().length;
  var multipleOfParts = multipleOf.toString().split(".");
  var decimals = 0;
  if (multipleOfParts.length > 1) {
    decimals = multipleOfParts[1].length;
  }
  return {
    minimum,
    maximum,
    nonDecimals,
    decimals,
    roundedMinimum: minimum
  };
}
function getIndexStringLength(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var length = 0;
  fieldNameProperties.forEach((props) => {
    var schemaPart = props.schemaPart;
    var type = schemaPart.type;
    if (type === "string") {
      length += schemaPart.maxLength;
    } else if (type === "boolean") {
      length += 1;
    } else {
      var parsedLengths = props.parsedLengths;
      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;
    }
  });
  return length;
}
function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {
  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);
  var primaryKey = paddedPrimaryKey.trim();
  return primaryKey;
}
function getNumberIndexString(parsedLengths, fieldValue) {
  if (typeof fieldValue === "undefined") {
    fieldValue = 0;
  }
  if (fieldValue < parsedLengths.minimum) {
    fieldValue = parsedLengths.minimum;
  }
  if (fieldValue > parsedLengths.maximum) {
    fieldValue = parsedLengths.maximum;
  }
  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();
  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, "0");
  if (parsedLengths.decimals > 0) {
    var splitByDecimalPoint = fieldValue.toString().split(".");
    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : "0";
    str += decimalValueAsString.padEnd(parsedLengths.decimals, "0");
  }
  return str;
}
function getStartIndexStringFromLowerBound(schema, index, lowerBound) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    var bound = lowerBound[idx];
    var type = schemaPart.type;
    switch (type) {
      case "string":
        var maxLength = ensureNotFalsy(schemaPart.maxLength, "maxLength not set");
        if (typeof bound === "string") {
          str += bound.padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, " ");
        }
        break;
      case "boolean":
        if (bound === null) {
          str += "0";
        } else if (bound === INDEX_MIN) {
          str += "0";
        } else if (bound === INDEX_MAX) {
          str += "1";
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === INDEX_MIN) {
          var fillChar = "0";
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else if (bound === INDEX_MAX) {
          str += getNumberIndexString(parsedLengths, parsedLengths.maximum);
        } else {
          var add = getNumberIndexString(parsedLengths, bound);
          str += add;
        }
        break;
      default:
        throw new Error("unknown index type " + type);
    }
  });
  return str;
}
function getStartIndexStringFromUpperBound(schema, index, upperBound) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    var bound = upperBound[idx];
    var type = schemaPart.type;
    switch (type) {
      case "string":
        var maxLength = ensureNotFalsy(schemaPart.maxLength, "maxLength not set");
        if (typeof bound === "string" && bound !== INDEX_MAX) {
          str += bound.padEnd(maxLength, " ");
        } else if (bound === INDEX_MIN) {
          str += "".padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, INDEX_MAX);
        }
        break;
      case "boolean":
        if (bound === null) {
          str += "1";
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === INDEX_MAX) {
          var fillChar = "9";
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else if (bound === INDEX_MIN) {
          var _fillChar = "0";
          str += _fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else {
          str += getNumberIndexString(parsedLengths, bound);
        }
        break;
      default:
        throw new Error("unknown index type " + type);
    }
  });
  return str;
}
function changeIndexableStringByOneQuantum(str, direction) {
  var lastChar = str.slice(-1);
  var charCode = lastChar.charCodeAt(0);
  charCode = charCode + direction;
  var withoutLastChar = str.slice(0, -1);
  return withoutLastChar + String.fromCharCode(charCode);
}
export {
  BROADCAST_CHANNEL_BY_TOKEN,
  COLLECTIONS_WITH_RUNNING_CLEANUP,
  DEFAULT_CHECKPOINT_SCHEMA,
  DEFAULT_TRY_TO_KEEP_MAX,
  DEFAULT_UNEXECUTED_LIFETIME,
  HOOKS,
  INDEX_MAX,
  INDEX_MIN,
  INTERNAL_CONTEXT_COLLECTION,
  INTERNAL_CONTEXT_MIGRATION_STATUS,
  INTERNAL_CONTEXT_PIPELINE_CHECKPOINT,
  INTERNAL_CONTEXT_STORAGE_TOKEN,
  INTERNAL_STORAGE_NAME,
  INTERNAL_STORE_SCHEMA,
  INTERNAL_STORE_SCHEMA_TITLE,
  LOGICAL_OPERATORS,
  LOWER_BOUND_LOGICAL_OPERATORS,
  META_INSTANCE_SCHEMA_TITLE,
  META_LWT_UNIX_TIME_MAX,
  NON_PREMIUM_COLLECTION_LIMIT,
  OPEN_COLLECTIONS,
  PREMIUM_FLAG_HASH,
  PROMISE_RESOLVE_FALSE,
  PROMISE_RESOLVE_NULL,
  PROMISE_RESOLVE_TRUE,
  PROMISE_RESOLVE_VOID,
  QueryCache,
  RANDOM_STRING,
  REGEX_ALL_DOTS,
  REGEX_ALL_PIPES,
  RXDB_UTILS_GLOBAL,
  RXDB_VERSION,
  RXJS_SHARE_REPLAY_DEFAULTS,
  RX_DATABASE_LOCAL_DOCS_STORAGE_NAME,
  RX_META_LWT_MINIMUM,
  RX_META_SCHEMA,
  RxCollectionBase,
  RxDatabaseBase,
  RxError,
  RxQueryBase,
  RxQuerySingleResult,
  RxSchema,
  RxTypeError,
  STORAGE_TOKEN_DOCUMENT_ID,
  STORAGE_TOKEN_DOCUMENT_KEY,
  UPPER_BOUND_LOGICAL_OPERATORS,
  _clearHook,
  _collectionNamePrimary,
  _getDefaultQuery,
  addConnectedStorageToCollection,
  addRxPlugin,
  addRxStorageMultiInstanceSupport,
  appendToArray,
  areRxDocumentArraysEqual,
  arrayBufferToBase64,
  arrayBufferToString,
  arrayFilterNotEmpty,
  asyncFilter,
  attachmentWriteDataToNormalData,
  awaitRxStorageReplicationFirstInSync,
  awaitRxStorageReplicationIdle,
  awaitRxStorageReplicationInSync,
  b64DecodeUnicode,
  b64EncodeUnicode,
  base64ToArrayBuffer,
  basePrototype,
  batchArray,
  beforeDocumentUpdateWrite,
  blobToBase64String,
  blobToString,
  cancelRxStorageReplication,
  categorizeBulkWriteRows,
  changeIndexableStringByOneQuantum,
  clone,
  countRxQuerySubscribers,
  countUntilNotMatching,
  createBlob,
  createBlobFromBase64,
  createNewRxDocument,
  createQueryCache,
  createRevision,
  createRxCollection,
  createRxCollectionStorageInstance,
  createRxDatabase,
  createRxDatabaseStorageInstance,
  createRxDocumentConstructor,
  createRxQuery,
  createRxSchema,
  createWithConstructor,
  customFetchWithFixedHeaders,
  dbCount,
  deepEqual,
  deepFreeze,
  deepKeys,
  defaultCacheReplacementPolicy,
  defaultCacheReplacementPolicyMonad,
  defaultConflictHandler,
  defaultHashSha256,
  deleteProperty,
  docStateToWriteDoc,
  ensureInteger,
  ensureNoStartupErrors,
  ensureNotFalsy,
  ensureRxCollectionIsNotClosed,
  ensureRxStorageInstanceParamsAreCorrect,
  ensureStorageTokenDocumentExists,
  errorToPlainJson,
  errorUrlHint,
  fillObjectDataBeforeInsert,
  fillObjectWithDefaults,
  fillPrimaryKey,
  fillWithDefaultSettings,
  findUndefinedPath,
  firstPropertyNameOfObject,
  firstPropertyValueOfObject,
  flatClone,
  flatCloneDocWithMeta,
  flattenEvents,
  flattenObject,
  getAllCollectionDocuments,
  getAssumedMasterState,
  getAttachmentSize,
  getBlobSize,
  getBroadcastChannelReference,
  getChangedDocumentsSince,
  getChangedDocumentsSinceQuery,
  getCheckpointKey,
  getComposedPrimaryKeyOfDocumentData,
  getDefaultIndex,
  getDefaultRevision,
  getDefaultRxDocumentMeta,
  getDocumentDataOfRxChangeEvent,
  getDocumentOrmPrototype,
  getDocumentPrototype,
  getErrorUrl,
  getFinalFields,
  getFromMapOrCreate,
  getFromMapOrThrow,
  getFromObjectOrThrow,
  getHeightOfRevision,
  getIndexMeta,
  getIndexStringLength,
  getIndexableStringMonad,
  getIndexes,
  getLastCheckpointDoc,
  getLengthOfPrimaryKey,
  getMatcherQueryOpts,
  getMetaWriteRow,
  getNumberIndexString,
  getPreviousVersions,
  getPrimaryFieldOfPrimaryKey,
  getPrimaryKeyFromIndexableString,
  getPrimaryKeyOfInternalDocument,
  getProperty,
  getPseudoSchemaForVersion,
  getQueryMatcher,
  getQueryPlan,
  getRxDocumentConstructor,
  getRxReplicationMetaInstanceSchema,
  getSchemaByObjectPath,
  getSingleDocument,
  getSortComparator,
  getSortDocumentsByLastWriteTimeComparator,
  getStartIndexStringFromLowerBound,
  getStartIndexStringFromUpperBound,
  getStringLengthOfIndexNumber,
  getUnderlyingPersistentStorage,
  getWrappedStorageInstance,
  getWrittenDocumentsFromBulkWriteResponse,
  hasDeepProperty,
  hasEncryption,
  hasPremiumFlag,
  hasProperty,
  hashStringToNumber,
  isBulkWriteConflictError,
  isDatabaseStateVersionCompatibleWithDatabaseCode,
  isFindOneByIdQuery,
  isFolderPath,
  isMaybeReadonlyArray,
  isOneItemOfArrayInOtherArray,
  isPromise,
  isRxCollection,
  isRxDatabase,
  isRxDatabaseFirstTimeInstantiated,
  isRxDocument,
  isRxQuery,
  isRxSchema,
  isSelectorSatisfiedByIndex,
  lastCharOfString,
  lastOfArray,
  maxOfNumbers,
  nameFunction,
  nativeSha256,
  newRxError,
  newRxTypeError,
  nextTick,
  normalizeMangoQuery,
  normalizeRxJsonSchema,
  normalizeString,
  now,
  objectPathMonad,
  observeSingle,
  overwritable,
  overwriteGetterForCaching,
  parseRevision,
  pluginMissing,
  prepareQuery,
  promiseSeries,
  promiseWait,
  queryCollection,
  randomDelayStorage,
  randomNumber,
  randomOfArray,
  randomToken,
  rateQueryPlan,
  removeBroadcastChannelReference,
  removeCollectionStorages,
  removeConnectedStorageFromCollection,
  removeOneFromArrayIfMatches,
  removeRxDatabase,
  replicateRxStorageInstance,
  requestIdleCallbackIfAvailable,
  requestIdlePromise,
  requestIdlePromiseNoQueue,
  resolveConflictError,
  runAsyncPluginHooks,
  runPluginHooks,
  runQueryUpdateFunction,
  runXTimes,
  rxChangeEventBulkToRxChangeEvents,
  rxChangeEventToEventReduceChangeEvent,
  rxStorageInstanceToReplicationHandler,
  rxStorageWriteErrorToRxError,
  setCheckpoint,
  setProperty,
  shuffleArray,
  sortByObjectNumberProperty,
  sortDocumentsByLastWriteTime,
  sortObject,
  stackCheckpoints,
  startReplicationDownstream,
  startReplicationUpstream,
  stringToArrayBuffer,
  stripAttachmentsDataFromDocument,
  stripAttachmentsDataFromMetaWriteRows,
  stripAttachmentsDataFromRow,
  stripMetaDataFromDocument,
  sumNumberArray,
  throwIfIsStorageWriteError,
  toArray,
  toPromise,
  toTypedRxJsonSchema,
  toWithDeleted,
  triggerCacheReplacement,
  trimDots,
  tunnelQueryCache,
  ucfirst,
  uncacheRxQuery,
  uniqueArray,
  wrapRxStorageInstance,
  wrappedValidateStorageFactory,
  writeDocToDocState,
  writeSingle
};
//# sourceMappingURL=rxdb.js.map
