{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/hooks.ts", "../../../../../node_modules/rxdb/src/rx-storage-helper.ts", "../../../../../node_modules/oblivious-set/src/index.ts"],
  "sourcesContent": ["\n/**\n * hook-functions that can be extended by the plugin\n */\nexport const HOOKS = {\n    /**\n     * Runs before a plugin is added.\n     * Use this to block the usage of non-compatible plugins.\n     */\n    preAddRxPlugin: [],\n    /**\n     * functions that run before the database is created\n     */\n    preCreateRxDatabase: [],\n    /**\n     * runs after the database is created and prepared\n     * but before the instance is returned to the user\n     * @async\n     */\n    createRxDatabase: [],\n    preCreateRxCollection: [],\n    createRxCollection: [],\n    createRxState: [],\n    /**\n    * runs at the end of the close-process of a collection\n    * @async\n    */\n    postCloseRxCollection: [],\n    /**\n     * Runs after a collection is removed.\n     * @async\n     */\n    postRemoveRxCollection: [],\n    /**\n      * functions that get the json-schema as input\n      * to do additionally checks/manipulation\n      */\n    preCreateRxSchema: [],\n    /**\n     * functions that run after the RxSchema is created\n     * gets RxSchema as attribute\n     */\n    createRxSchema: [],\n    prePrepareRxQuery: [],\n    preCreateRxQuery: [],\n    /**\n     * Runs before a query is send to the\n     * prepareQuery function of the storage engine.\n     */\n    prePrepareQuery: [],\n    createRxDocument: [],\n    /**\n     * runs after a RxDocument is created,\n     * cannot be async\n     */\n    postCreateRxDocument: [],\n    /**\n     * Runs before a RxStorageInstance is created\n     * gets the params of createStorageInstance()\n     * as attribute so you can manipulate them.\n     * Notice that you have to clone stuff before mutating the inputs.\n     */\n    preCreateRxStorageInstance: [],\n    preStorageWrite: [],\n    /**\n     * runs on the document-data before the document is migrated\n     * {\n     *   doc: Object, // original doc-data\n     *   migrated: // migrated doc-data after run through migration-strategies\n     * }\n     */\n    preMigrateDocument: [],\n    /**\n     * runs after the migration of a document has been done\n     */\n    postMigrateDocument: [],\n    /**\n     * runs at the beginning of the close-process of a database\n     */\n    preCloseRxDatabase: [],\n    /**\n     * runs after a database has been removed\n     * @async\n     */\n    postRemoveRxDatabase: [],\n\n\n    postCleanup: [],\n\n    /**\n     * runs before the replication writes the rows to master\n     * but before the rows have been modified\n     * @async\n     */\n    preReplicationMasterWrite: [],\n\n    /**\n     * runs after the replication has been sent to the server\n     * but before the new documents have been handled\n     * @async\n     */\n    preReplicationMasterWriteDocumentsHandle: [],\n};\n\nexport function runPluginHooks(hookKey: keyof typeof HOOKS, obj: any) {\n    if (HOOKS[hookKey].length > 0) {\n        HOOKS[hookKey].forEach(fun => (fun as any)(obj));\n    }\n}\n\n\n/**\n * We do intentionally not run the hooks in parallel\n * because that makes stuff unpredictable and we use runAsyncPluginHooks()\n * only in places that are not that relevant for performance.\n */\nexport async function runAsyncPluginHooks(hookKey: keyof typeof HOOKS, obj: any): Promise<any> {\n    for (const fn of HOOKS[hookKey]) {\n        await (fn as any)(obj);\n    }\n}\n\n/**\n * used in tests to remove hooks\n */\nexport function _clearHook(type: keyof typeof HOOKS, fun: Function) {\n    HOOKS[type] = HOOKS[type].filter(h => h !== fun);\n}\n", "/**\n * Helper functions for accessing the RxStorage instances.\n */\n\nimport { overwritable } from './overwritable.ts';\nimport { newRxError } from './rx-error.ts';\nimport {\n    getPrimaryFieldOfPrimaryKey\n} from './rx-schema-helper.ts';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowProcessed,\n    CategorizeBulkWriteRowsOutput,\n    EventBulk,\n    RxAttachmentData,\n    RxAttachmentWriteData,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorageWriteError,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    StringKeys,\n    RxStorageWriteErrorConflict,\n    RxStorageWriteErrorAttachment,\n    RxStorage,\n    RxStorageDefaultCheckpoint,\n    FilledMangoQuery,\n    RxStorageBulkWriteResponse\n} from './types/index.d.ts';\nimport {\n    PROMISE_RESOLVE_TRUE,\n    RXDB_VERSION,\n    RX_META_LWT_MINIMUM,\n    appendToArray,\n    createRevision,\n    ensureNotFalsy,\n    flatClone,\n    getFromMapOrCreate,\n    lastOfArray,\n    now,\n    promiseWait,\n    randomToken\n} from './plugins/utils/index.ts';\nimport { Observable, filter, map, startWith, switchMap } from 'rxjs';\nimport { normalizeMangoQuery, prepareQuery } from './rx-query-helper.ts';\nimport { runPluginHooks } from './hooks.ts';\n\nexport const INTERNAL_STORAGE_NAME = '_rxdb_internal';\nexport const RX_DATABASE_LOCAL_DOCS_STORAGE_NAME = 'rxdatabase_storage_local';\n\nexport async function getSingleDocument<RxDocType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any>,\n    documentId: string\n): Promise<RxDocumentData<RxDocType> | undefined> {\n    const results = await storageInstance.findDocumentsById([documentId], false);\n    const doc = results[0];\n    if (doc) {\n        return doc;\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * Writes a single document,\n * throws RxStorageBulkWriteError on failure\n */\nexport async function writeSingle<RxDocType>(\n    instance: RxStorageInstance<RxDocType, any, any>,\n    writeRow: BulkWriteRow<RxDocType>,\n    context: string\n): Promise<RxDocumentData<RxDocType>> {\n    const writeResult = await instance.bulkWrite(\n        [writeRow],\n        context\n    );\n    if (writeResult.error.length > 0) {\n        const error = writeResult.error[0];\n        throw error;\n    } else {\n        const primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n        const success = getWrittenDocumentsFromBulkWriteResponse(primaryPath, [writeRow], writeResult);\n        const ret = success[0];\n        return ret;\n    }\n}\n\n/**\n * Observe the plain document data of a single document.\n * Do not forget to unsubscribe.\n */\nexport function observeSingle<RxDocType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any>,\n    documentId: string\n): Observable<RxDocumentData<RxDocType>> {\n    const firstFindPromise = getSingleDocument(storageInstance, documentId);\n    const ret = storageInstance\n        .changeStream()\n        .pipe(\n            map(evBulk => evBulk.events.find(ev => ev.documentId === documentId)),\n            filter(ev => !!ev),\n            map(ev => Promise.resolve(ensureNotFalsy(ev).documentData)),\n            startWith(firstFindPromise),\n            switchMap(v => v),\n            filter(v => !!v)\n        ) as any;\n    return ret;\n}\n\n/**\n * Checkpoints must be stackable over another.\n * This is required form some RxStorage implementations\n * like the sharding plugin, where a checkpoint only represents\n * the document state from some, but not all shards.\n */\nexport function stackCheckpoints<CheckpointType>(\n    checkpoints: (CheckpointType | undefined)[]\n): CheckpointType {\n    return Object.assign(\n        {},\n        ...checkpoints.filter(x => !!x)\n    );\n}\n\nexport function throwIfIsStorageWriteError<RxDocType>(\n    collection: RxCollection<RxDocType, any, any>,\n    documentId: string,\n    writeData: RxDocumentWriteData<RxDocType> | RxDocType,\n    error: RxStorageWriteError<RxDocType> | undefined\n) {\n    if (error) {\n        if (error.status === 409) {\n            throw newRxError('CONFLICT', {\n                collection: collection.name,\n                id: documentId,\n                writeError: error,\n                data: writeData\n            });\n        } else if (error.status === 422) {\n            throw newRxError('VD2', {\n                collection: collection.name,\n                id: documentId,\n                writeError: error,\n                data: writeData\n            });\n        } else {\n            throw error;\n        }\n    }\n}\n\n\n/**\n * Analyzes a list of BulkWriteRows and determines\n * which documents must be inserted, updated or deleted\n * and which events must be emitted and which documents cause a conflict\n * and must not be written.\n * Used as helper inside of some RxStorage implementations.\n * @hotPath The performance of this function is critical\n */\nexport function categorizeBulkWriteRows<RxDocType>(\n    storageInstance: RxStorageInstance<any, any, any>,\n    primaryPath: StringKeys<RxDocType>,\n    /**\n     * Current state of the documents\n     * inside of the storage. Used to determine\n     * which writes cause conflicts.\n     * This must be a Map for better performance.\n     */\n    docsInDb: Map<RxDocumentData<RxDocType>[StringKeys<RxDocType>] | string, RxDocumentData<RxDocType>>,\n    /**\n     * The write rows that are passed to\n     * RxStorageInstance().bulkWrite().\n     */\n    bulkWriteRows: BulkWriteRow<RxDocType>[],\n    context: string,\n    /**\n     * Used by some storages for better performance.\n     * For example when get-by-id and insert/update can run in parallel.\n     */\n    onInsert?: (docData: RxDocumentData<RxDocType>) => void,\n    onUpdate?: (docData: RxDocumentData<RxDocType>) => void\n): CategorizeBulkWriteRowsOutput<RxDocType> {\n    const hasAttachments = !!storageInstance.schema.attachments;\n    const bulkInsertDocs: BulkWriteRowProcessed<RxDocType>[] = [];\n    const bulkUpdateDocs: BulkWriteRowProcessed<RxDocType>[] = [];\n    const errors: RxStorageWriteError<RxDocType>[] = [];\n    const eventBulkId = randomToken(10);\n    const eventBulk: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any> = {\n        id: eventBulkId,\n        events: [],\n        checkpoint: null,\n        context\n    };\n    const eventBulkEvents = eventBulk.events;\n\n    const attachmentsAdd: {\n        documentId: string;\n        attachmentId: string;\n        attachmentData: RxAttachmentWriteData;\n        digest: string;\n    }[] = [];\n    const attachmentsRemove: {\n        documentId: string;\n        attachmentId: string;\n        digest: string;\n    }[] = [];\n    const attachmentsUpdate: {\n        documentId: string;\n        attachmentId: string;\n        attachmentData: RxAttachmentWriteData;\n        digest: string;\n    }[] = [];\n\n    const hasDocsInDb = docsInDb.size > 0;\n    let newestRow: BulkWriteRowProcessed<RxDocType> | undefined;\n\n    /**\n     * @performance is really important in this loop!\n     */\n    const rowAmount = bulkWriteRows.length;\n    for (let rowId = 0; rowId < rowAmount; rowId++) {\n        const writeRow = bulkWriteRows[rowId];\n\n        // use these variables to have less property accesses\n        const document = writeRow.document;\n        const previous = writeRow.previous;\n        const docId = document[primaryPath] as string;\n        const documentDeleted = document._deleted;\n        const previousDeleted = previous && previous._deleted;\n\n        let documentInDb: RxDocumentData<RxDocType> | undefined = undefined as any;\n        if (hasDocsInDb) {\n            documentInDb = docsInDb.get(docId);\n        }\n        let attachmentError: RxStorageWriteErrorAttachment<RxDocType> | undefined;\n\n        if (!documentInDb) {\n            /**\n             * It is possible to insert already deleted documents,\n             * this can happen on replication.\n             */\n            const insertedIsDeleted = documentDeleted ? true : false;\n            if (hasAttachments) {\n                Object\n                    .entries(document._attachments)\n                    .forEach(([attachmentId, attachmentData]) => {\n                        if (\n                            !(attachmentData as RxAttachmentWriteData).data\n                        ) {\n                            attachmentError = {\n                                documentId: docId,\n                                isError: true,\n                                status: 510,\n                                writeRow,\n                                attachmentId\n                            };\n                            errors.push(attachmentError);\n                        } else {\n                            attachmentsAdd.push({\n                                documentId: docId,\n                                attachmentId,\n                                attachmentData: attachmentData as any,\n                                digest: attachmentData.digest\n                            });\n                        }\n                    });\n            }\n            if (!attachmentError) {\n                if (hasAttachments) {\n                    bulkInsertDocs.push(stripAttachmentsDataFromRow(writeRow));\n                    if (onInsert) {\n                        onInsert(document);\n                    }\n                } else {\n                    bulkInsertDocs.push(writeRow as any);\n                    if (onInsert) {\n                        onInsert(document);\n                    }\n                }\n\n                newestRow = writeRow as any;\n            }\n\n            if (!insertedIsDeleted) {\n                const event = {\n                    documentId: docId,\n                    operation: 'INSERT' as const,\n                    documentData: hasAttachments ? stripAttachmentsDataFromDocument(document) : document as any,\n                    previousDocumentData: hasAttachments && previous ? stripAttachmentsDataFromDocument(previous) : previous as any\n                };\n                eventBulkEvents.push(event);\n            }\n        } else {\n            // update existing document\n            const revInDb: string = documentInDb._rev;\n\n            /**\n             * Check for conflict\n             */\n            if (\n                (\n                    !previous\n                ) ||\n                (\n                    !!previous &&\n                    revInDb !== previous._rev\n                )\n            ) {\n                // is conflict error\n                const err: RxStorageWriteError<RxDocType> = {\n                    isError: true,\n                    status: 409,\n                    documentId: docId,\n                    writeRow: writeRow,\n                    documentInDb\n                };\n                errors.push(err);\n                continue;\n            }\n\n            // handle attachments data\n\n            const updatedRow: BulkWriteRowProcessed<RxDocType> = hasAttachments ? stripAttachmentsDataFromRow(writeRow) : writeRow as any;\n            if (hasAttachments) {\n                if (documentDeleted) {\n                    /**\n                     * Deleted documents must have cleared all their attachments.\n                     */\n                    if (previous) {\n                        Object\n                            .keys(previous._attachments)\n                            .forEach(attachmentId => {\n                                attachmentsRemove.push({\n                                    documentId: docId,\n                                    attachmentId,\n                                    digest: ensureNotFalsy(previous)._attachments[attachmentId].digest\n                                });\n                            });\n                    }\n                } else {\n                    // first check for errors\n                    Object\n                        .entries(document._attachments)\n                        .find(([attachmentId, attachmentData]) => {\n                            const previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n                            if (\n                                !previousAttachmentData &&\n                                !(attachmentData as RxAttachmentWriteData).data\n                            ) {\n                                attachmentError = {\n                                    documentId: docId,\n                                    documentInDb: documentInDb as any,\n                                    isError: true,\n                                    status: 510,\n                                    writeRow,\n                                    attachmentId\n                                };\n                            }\n                            return true;\n                        });\n                    if (!attachmentError) {\n                        Object\n                            .entries(document._attachments)\n                            .forEach(([attachmentId, attachmentData]) => {\n                                const previousAttachmentData = previous ? previous._attachments[attachmentId] : undefined;\n                                if (!previousAttachmentData) {\n                                    attachmentsAdd.push({\n                                        documentId: docId,\n                                        attachmentId,\n                                        attachmentData: attachmentData as any,\n                                        digest: attachmentData.digest\n                                    });\n                                } else {\n                                    const newDigest = updatedRow.document._attachments[attachmentId].digest;\n                                    if (\n                                        (attachmentData as RxAttachmentWriteData).data &&\n                                        /**\n                                         * Performance shortcut,\n                                         * do not update the attachment data if it did not change.\n                                         */\n                                        previousAttachmentData.digest !== newDigest\n                                    ) {\n                                        attachmentsUpdate.push({\n                                            documentId: docId,\n                                            attachmentId,\n                                            attachmentData: attachmentData as RxAttachmentWriteData,\n                                            digest: attachmentData.digest\n                                        });\n                                    }\n                                }\n                            });\n                    }\n                }\n            }\n\n            if (attachmentError) {\n                errors.push(attachmentError);\n            } else {\n                if (hasAttachments) {\n                    bulkUpdateDocs.push(stripAttachmentsDataFromRow(updatedRow));\n                    if (onUpdate) {\n                        onUpdate(document);\n                    }\n                } else {\n                    bulkUpdateDocs.push(updatedRow);\n                    if (onUpdate) {\n                        onUpdate(document);\n                    }\n                }\n                newestRow = updatedRow as any;\n            }\n\n            let eventDocumentData: RxDocumentData<RxDocType> | undefined = null as any;\n            let previousEventDocumentData: RxDocumentData<RxDocType> | undefined = null as any;\n            let operation: 'INSERT' | 'UPDATE' | 'DELETE' = null as any;\n\n            if (previousDeleted && !documentDeleted) {\n                operation = 'INSERT';\n                eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document as any;\n            } else if (previous && !previousDeleted && !documentDeleted) {\n                operation = 'UPDATE';\n                eventDocumentData = hasAttachments ? stripAttachmentsDataFromDocument(document) : document as any;\n                previousEventDocumentData = previous;\n            } else if (documentDeleted) {\n                operation = 'DELETE';\n                eventDocumentData = ensureNotFalsy(document) as any;\n                previousEventDocumentData = previous;\n            } else {\n                throw newRxError('SNH', { args: { writeRow } });\n            }\n\n            const event = {\n                documentId: docId,\n                documentData: eventDocumentData as RxDocumentData<RxDocType>,\n                previousDocumentData: previousEventDocumentData,\n                operation: operation\n            };\n            eventBulkEvents.push(event);\n        }\n    }\n\n    return {\n        bulkInsertDocs,\n        bulkUpdateDocs,\n        newestRow,\n        errors,\n        eventBulk,\n        attachmentsAdd,\n        attachmentsRemove,\n        attachmentsUpdate\n    };\n}\n\nexport function stripAttachmentsDataFromRow<RxDocType>(writeRow: BulkWriteRow<RxDocType>): BulkWriteRowProcessed<RxDocType> {\n    return {\n        previous: writeRow.previous,\n        document: stripAttachmentsDataFromDocument(writeRow.document)\n    };\n}\n\nexport function getAttachmentSize(\n    attachmentBase64String: string\n): number {\n    return atob(attachmentBase64String).length;\n}\n\n/**\n * Used in custom RxStorage implementations.\n */\nexport function attachmentWriteDataToNormalData(writeData: RxAttachmentData | RxAttachmentWriteData): RxAttachmentData {\n    const data = (writeData as RxAttachmentWriteData).data;\n    if (!data) {\n        return writeData as any;\n    }\n    const ret: RxAttachmentData = {\n        length: getAttachmentSize(data),\n        digest: writeData.digest,\n        type: writeData.type\n    };\n    return ret;\n}\n\nexport function stripAttachmentsDataFromDocument<RxDocType>(doc: RxDocumentWriteData<RxDocType>): RxDocumentData<RxDocType> {\n    if (!doc._attachments || Object.keys(doc._attachments).length === 0) {\n        return doc;\n    }\n\n    const useDoc: RxDocumentData<RxDocType> = flatClone(doc) as any;\n    useDoc._attachments = {};\n    Object\n        .entries(doc._attachments)\n        .forEach(([attachmentId, attachmentData]) => {\n            useDoc._attachments[attachmentId] = attachmentWriteDataToNormalData(attachmentData);\n        });\n    return useDoc;\n}\n\n/**\n * Flat clone the document data\n * and also the _meta field.\n * Used many times when we want to change the meta\n * during replication etc.\n */\nexport function flatCloneDocWithMeta<RxDocType>(\n    doc: RxDocumentData<RxDocType>\n): RxDocumentData<RxDocType> {\n    return Object.assign(\n        {},\n        doc,\n        {\n            _meta: flatClone(doc._meta)\n        }\n    );\n}\n\nexport type WrappedRxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions> = RxStorageInstance<RxDocumentType, any, InstanceCreationOptions> & {\n    originalStorageInstance: RxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>;\n};\n\n/**\n * Wraps the normal storageInstance of a RxCollection\n * to ensure that all access is properly using the hooks\n * and other data transformations and also ensure that database.lockedRun()\n * is used properly.\n */\nexport function getWrappedStorageInstance<\n    RxDocType,\n    Internals,\n    InstanceCreationOptions,\n    CheckpointType\n>(\n    database: RxDatabase<{}, Internals, InstanceCreationOptions, any>,\n    storageInstance: RxStorageInstance<RxDocType, Internals, InstanceCreationOptions, CheckpointType>,\n    /**\n     * The original RxJsonSchema\n     * before it was mutated by hooks.\n     */\n    rxJsonSchema: RxJsonSchema<RxDocumentData<RxDocType>>\n): WrappedRxStorageInstance<RxDocType, Internals, InstanceCreationOptions> {\n    overwritable.deepFreezeWhenDevMode(rxJsonSchema);\n\n    const primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n\n    const ret: WrappedRxStorageInstance<RxDocType, Internals, InstanceCreationOptions> = {\n        originalStorageInstance: storageInstance,\n        schema: storageInstance.schema,\n        internals: storageInstance.internals,\n        collectionName: storageInstance.collectionName,\n        databaseName: storageInstance.databaseName,\n        options: storageInstance.options,\n        async bulkWrite(\n            rows: BulkWriteRow<RxDocType>[],\n            context: string\n        ) {\n            const databaseToken = database.token;\n            const toStorageWriteRows: BulkWriteRow<RxDocType>[] = new Array(rows.length);\n            /**\n             * Use the same timestamp for all docs of this rows-set.\n             * This improves performance because calling Date.now() inside of the now() function\n             * is too costly.\n             */\n            const time = now();\n            for (let index = 0; index < rows.length; index++) {\n                const writeRow = rows[index];\n                const document = flatCloneDocWithMeta(writeRow.document);\n                document._meta.lwt = time;\n\n                /**\n                 * Yes we really want to set the revision here.\n                 * If you make a plugin that relies on having its own revision\n                 * stored into the storage, use this.originalStorageInstance.bulkWrite() instead.\n                 */\n                const previous = writeRow.previous;\n                document._rev = createRevision(\n                    databaseToken,\n                    previous\n                );\n                toStorageWriteRows[index] = {\n                    document,\n                    previous\n                };\n            }\n\n            runPluginHooks('preStorageWrite', {\n                storageInstance: this.originalStorageInstance,\n                rows: toStorageWriteRows\n            });\n\n            const writeResult = await database.lockedRun(\n                () => storageInstance.bulkWrite(\n                    toStorageWriteRows,\n                    context\n                )\n            );\n\n            /**\n             * The RxStorageInstance MUST NOT allow to insert already _deleted documents,\n             * without sending the previous document version.\n             * But for better developer experience, RxDB does allow to re-insert deleted documents.\n             * We do this by automatically fixing the conflict errors for that case\n             * by running another bulkWrite() and merging the results.\n             * @link https://github.com/pubkey/rxdb/pull/3839\n            */\n            const useWriteResult: typeof writeResult = {\n                error: []\n            };\n            BULK_WRITE_ROWS_BY_RESPONSE.set(useWriteResult, toStorageWriteRows);\n\n            const reInsertErrors: RxStorageWriteErrorConflict<RxDocType>[] = writeResult.error.length === 0\n                ? []\n                : writeResult.error\n                    .filter((error) => {\n                        if (\n                            error.status === 409 &&\n                            !error.writeRow.previous &&\n                            !error.writeRow.document._deleted &&\n                            ensureNotFalsy(error.documentInDb)._deleted\n                        ) {\n                            return true;\n                        }\n\n                        // add the \"normal\" errors to the parent error array.\n                        useWriteResult.error.push(error);\n                        return false;\n                    }) as any;\n            if (reInsertErrors.length > 0) {\n                const reInsertIds = new Set<string>();\n                const reInserts: BulkWriteRow<RxDocType>[] = reInsertErrors\n                    .map((error) => {\n                        reInsertIds.add(error.documentId);\n                        return {\n                            previous: error.documentInDb,\n                            document: Object.assign(\n                                {},\n                                error.writeRow.document,\n                                {\n                                    _rev: createRevision(\n                                        database.token,\n                                        error.documentInDb\n                                    )\n                                }\n                            )\n                        };\n                    });\n\n                const subResult = await database.lockedRun(\n                    () => storageInstance.bulkWrite(\n                        reInserts,\n                        context\n                    )\n                );\n\n                appendToArray(useWriteResult.error, subResult.error);\n                const successArray = getWrittenDocumentsFromBulkWriteResponse(\n                    primaryPath,\n                    toStorageWriteRows,\n                    useWriteResult,\n                    reInsertIds\n                );\n                const subSuccess = getWrittenDocumentsFromBulkWriteResponse(\n                    primaryPath,\n                    reInserts,\n                    subResult\n                );\n                appendToArray(successArray, subSuccess);\n                return useWriteResult;\n            }\n            return useWriteResult;\n        },\n        query(preparedQuery) {\n            return database.lockedRun(\n                () => storageInstance.query(preparedQuery)\n            );\n        },\n        count(preparedQuery) {\n            return database.lockedRun(\n                () => storageInstance.count(preparedQuery)\n            );\n        },\n        findDocumentsById(ids, deleted) {\n            return database.lockedRun(\n                () => storageInstance.findDocumentsById(ids, deleted)\n            );\n        },\n        getAttachmentData(\n            documentId: string,\n            attachmentId: string,\n            digest: string\n        ) {\n            return database.lockedRun(\n                () => storageInstance.getAttachmentData(documentId, attachmentId, digest)\n            );\n        },\n        getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : (limit: number, checkpoint?: any) => {\n            return database.lockedRun(\n                () => ((storageInstance as any).getChangedDocumentsSince)(ensureNotFalsy(limit), checkpoint)\n            );\n        },\n        cleanup(minDeletedTime: number) {\n            return database.lockedRun(\n                () => storageInstance.cleanup(minDeletedTime)\n            );\n        },\n        remove() {\n            database.storageInstances.delete(ret);\n            return database.lockedRun(\n                () => storageInstance.remove()\n            );\n        },\n        close() {\n            database.storageInstances.delete(ret);\n            return database.lockedRun(\n                () => storageInstance.close()\n            );\n        },\n        changeStream() {\n            return storageInstance.changeStream();\n        }\n    };\n\n    database.storageInstances.add(ret);\n    return ret;\n}\n\n/**\n * Each RxStorage implementation should\n * run this method at the first step of createStorageInstance()\n * to ensure that the configuration is correct.\n */\nexport function ensureRxStorageInstanceParamsAreCorrect(\n    params: RxStorageInstanceCreationParams<any, any>\n) {\n    if (params.schema.keyCompression) {\n        throw newRxError('UT5', { args: { params } });\n    }\n    if (hasEncryption(params.schema)) {\n        throw newRxError('UT6', { args: { params } });\n    }\n    if (\n        params.schema.attachments &&\n        params.schema.attachments.compression\n    ) {\n        throw newRxError('UT7', { args: { params } });\n    }\n}\n\nexport function hasEncryption(jsonSchema: RxJsonSchema<any>): boolean {\n    if (\n        (!!jsonSchema.encrypted && jsonSchema.encrypted.length > 0) ||\n        (jsonSchema.attachments && jsonSchema.attachments.encrypted)\n    ) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nexport function getChangedDocumentsSinceQuery<RxDocType, CheckpointType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any, CheckpointType>,\n    limit: number,\n    checkpoint?: CheckpointType\n): FilledMangoQuery<RxDocType> {\n    const primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n    const sinceLwt = checkpoint ? (checkpoint as unknown as RxStorageDefaultCheckpoint).lwt : RX_META_LWT_MINIMUM;\n    const sinceId = checkpoint ? (checkpoint as unknown as RxStorageDefaultCheckpoint).id : '';\n    return normalizeMangoQuery(storageInstance.schema, {\n        selector: {\n            $or: [\n                {\n                    '_meta.lwt': {\n                        $gt: sinceLwt\n                    }\n                },\n                {\n                    '_meta.lwt': {\n                        $eq: sinceLwt\n                    },\n                    [primaryPath]: {\n                        $gt: checkpoint ? sinceId : ''\n                    }\n                }\n            ],\n            // add this hint for better index usage\n            '_meta.lwt': {\n                $gte: sinceLwt\n            }\n        } as any,\n        sort: [\n            { '_meta.lwt': 'asc' },\n            { [primaryPath]: 'asc' }\n        ] as any,\n        skip: 0,\n        limit,\n        /**\n         * DO NOT SET A SPECIFIC INDEX HERE!\n         * The query might be modified by some plugin\n         * before sending it to the storage.\n         * We can be sure that in the end the query planner\n         * will find the best index.\n         */\n        // index: ['_meta.lwt', primaryPath]\n    });\n}\n\nexport async function getChangedDocumentsSince<RxDocType, CheckpointType>(\n    storageInstance: RxStorageInstance<RxDocType, any, any, CheckpointType>,\n    limit: number,\n    checkpoint?: CheckpointType\n): Promise<{\n    documents: RxDocumentData<RxDocType>[];\n    /**\n     * The checkpoint contains data so that another\n     * call to getChangedDocumentsSince() will continue\n     * from exactly the last document that was returned before.\n     */\n    checkpoint: CheckpointType;\n}> {\n    if (storageInstance.getChangedDocumentsSince) {\n        return storageInstance.getChangedDocumentsSince(limit, checkpoint);\n    }\n\n    const primaryPath = getPrimaryFieldOfPrimaryKey(storageInstance.schema.primaryKey);\n    const query = prepareQuery<RxDocumentData<any>>(\n        storageInstance.schema,\n        getChangedDocumentsSinceQuery(\n            storageInstance,\n            limit,\n            checkpoint\n        )\n    );\n\n    const result = await storageInstance.query(query);\n    const documents = result.documents;\n    const lastDoc = lastOfArray(documents);\n\n    return {\n        documents: documents,\n        checkpoint: lastDoc ? {\n            id: (lastDoc as any)[primaryPath],\n            lwt: lastDoc._meta.lwt\n        } as any : checkpoint ? checkpoint : {\n            id: '',\n            lwt: 0\n        }\n    };\n}\n\n\nconst BULK_WRITE_ROWS_BY_RESPONSE = new WeakMap<RxStorageBulkWriteResponse<any>, BulkWriteRow<any>[]>();\nconst BULK_WRITE_SUCCESS_MAP = new WeakMap<RxStorageBulkWriteResponse<any>, RxDocumentData<any>[]>();\n\n/**\n * For better performance, this is done only when accessed\n * because most of the time we do not need the results, only the errors.\n */\nexport function getWrittenDocumentsFromBulkWriteResponse<RxDocType>(\n    primaryPath: string,\n    writeRows: BulkWriteRow<RxDocType>[],\n    response: RxStorageBulkWriteResponse<RxDocType>,\n    reInsertIds?: Set<string>\n): RxDocumentData<RxDocType>[] {\n    return getFromMapOrCreate(\n        BULK_WRITE_SUCCESS_MAP,\n        response,\n        () => {\n            const ret: RxDocumentData<RxDocType>[] = [];\n            let realWriteRows = BULK_WRITE_ROWS_BY_RESPONSE.get(response);\n            if (!realWriteRows) {\n                realWriteRows = writeRows;\n            }\n            if (response.error.length > 0 || reInsertIds) {\n                const errorIds = reInsertIds ? reInsertIds : new Set<string>();\n                for (let index = 0; index < response.error.length; index++) {\n                    const error = response.error[index];\n                    errorIds.add(error.documentId);\n                }\n\n                for (let index = 0; index < realWriteRows.length; index++) {\n                    const doc = realWriteRows[index].document;\n                    if (!errorIds.has((doc as any)[primaryPath])) {\n                        ret.push(stripAttachmentsDataFromDocument(doc));\n                    }\n                }\n            } else {\n                // pre-set array size for better performance\n                ret.length = writeRows.length - response.error.length;\n                for (let index = 0; index < realWriteRows.length; index++) {\n                    const doc = realWriteRows[index].document;\n                    ret[index] = stripAttachmentsDataFromDocument(doc);\n                }\n            }\n            return ret;\n        }\n    );\n}\n\n\n/**\n * Wraps the storage and simluates\n * delays. Mostly used in tests.\n */\nexport function randomDelayStorage<Internals, InstanceCreationOptions>(\n    input: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n        delayTimeBefore: () => number;\n        delayTimeAfter: () => number;\n    }\n): RxStorage<Internals, InstanceCreationOptions> {\n    /**\n     * Ensure writes to a delay storage\n     * are still correctly run in order.\n     */\n    let randomDelayStorageWriteQueue: Promise<any> = PROMISE_RESOLVE_TRUE;\n\n    const retStorage: RxStorage<Internals, InstanceCreationOptions> = {\n        name: 'random-delay-' + input.storage.name,\n        rxdbVersion: RXDB_VERSION,\n        async createStorageInstance(params) {\n            await promiseWait(input.delayTimeBefore());\n            const storageInstance = await input.storage.createStorageInstance(params);\n            await promiseWait(input.delayTimeAfter());\n\n            return {\n                databaseName: storageInstance.databaseName,\n                internals: storageInstance.internals,\n                options: storageInstance.options,\n                schema: storageInstance.schema,\n                collectionName: storageInstance.collectionName,\n                bulkWrite(a, b) {\n                    randomDelayStorageWriteQueue = randomDelayStorageWriteQueue.then(async () => {\n                        await promiseWait(input.delayTimeBefore());\n                        const response = await storageInstance.bulkWrite(a, b);\n                        await promiseWait(input.delayTimeAfter());\n                        return response;\n                    });\n                    const ret = randomDelayStorageWriteQueue;\n                    return ret;\n                },\n                async findDocumentsById(a, b) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.findDocumentsById(a, b);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n                },\n                async query(a) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.query(a);\n                    return ret;\n                },\n                async count(a) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.count(a);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                async getAttachmentData(a, b, c) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.getAttachmentData(a, b, c);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                getChangedDocumentsSince: !storageInstance.getChangedDocumentsSince ? undefined : async (a, b) => {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await ensureNotFalsy(storageInstance.getChangedDocumentsSince)(a, b);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                changeStream() {\n                    return storageInstance.changeStream();\n                },\n                async cleanup(a) {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.cleanup(a);\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                async close() {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.close();\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n\n                },\n                async remove() {\n                    await promiseWait(input.delayTimeBefore());\n                    const ret = await storageInstance.remove();\n                    await promiseWait(input.delayTimeAfter());\n                    return ret;\n                },\n            };\n\n\n        }\n    };\n    return retStorage;\n}\n", "\n/**\n * this is a set which automatically forgets\n * a given entry when a new entry is set and the ttl\n * of the old one is over\n */\nexport class ObliviousSet<T = any> {\n    public readonly map = new Map();\n\n    /**\n     * Creating calls to setTimeout() is expensive,\n     * so we only do that if there is not timeout already open.\n     */\n    public _to: boolean = false;\n    constructor(\n        public readonly ttl: number\n    ) { }\n\n    has(value: T): boolean {\n        return this.map.has(value);\n    }\n\n    add(value: T): void {\n        this.map.set(value, now());\n\n        /**\n         * When a new value is added,\n         * start the cleanup at the next tick\n         * to not block the cpu for more important stuff\n         * that might happen.\n         */\n        if (!this._to) {\n            this._to = true;\n            setTimeout(() => {\n                this._to = false;\n                removeTooOldValues(this);\n            }, 0);\n        }\n    }\n\n    clear() {\n        this.map.clear();\n    }\n}\n\n\n/**\n * Removes all entries from the set\n * where the TTL has expired\n */\nexport function removeTooOldValues(\n    obliviousSet: ObliviousSet\n) {\n    const olderThen = now() - obliviousSet.ttl;\n    const iterator = obliviousSet.map[Symbol.iterator]();\n\n    /**\n     * Because we can assume the new values are added at the bottom,\n     * we start from the top and stop as soon as we reach a non-too-old value.\n     */\n    while (true) {\n\n        const next = iterator.next().value;\n\n        if (!next) {\n            return; // no more elements\n        }\n        const value = next[0];\n        const time = next[1];\n        if (time < olderThen) {\n            obliviousSet.map.delete(value);\n        } else {\n            // We reached a value that is not old enough\n            return;\n        }\n    }\n}\n\nexport function now(): number {\n    return Date.now();\n}\n\n\n"],
  "mappings": "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",
  "names": ["HOOKS", "preAddRxPlugin", "preCreateRxDatabase", "createRxDatabase", "preCreateRxCollection", "createRxCollection", "createRxState", "postCloseRxCollection", "postRemoveRxCollection", "preCreateRxSchema", "createRxSchema", "prePrepareRxQuery", "preCreateRxQuery", "prePrepareQuery", "createRxDocument", "postCreateRxDocument", "preCreateRxStorageInstance", "preStorageWrite", "preMigrateDocument", "postMigrateDocument", "preCloseRxDatabase", "postRemoveRxDatabase", "postCleanup", "preReplicationMasterWrite", "preReplicationMasterWriteDocumentsHandle", "runPluginHooks", "hookKey", "obj", "length", "forEach", "fun", "runAsyncPluginHooks", "fn", "_clearHook", "type", "filter", "h", "INTERNAL_STORAGE_NAME", "RX_DATABASE_LOCAL_DOCS_STORAGE_NAME", "getSingleDocument", "storageInstance", "documentId", "results", "findDocumentsById", "doc", "undefined", "writeSingle", "instance", "writeRow", "context", "writeResult", "bulkWrite", "error", "length", "primaryPath", "getPrimaryFieldOfPrimaryKey", "schema", "primaryKey", "success", "getWrittenDocumentsFromBulkWriteResponse", "ret", "observeSingle", "firstFindPromise", "changeStream", "pipe", "map", "evBulk", "events", "find", "ev", "filter", "Promise", "resolve", "ensureNotFalsy", "documentData", "startWith", "switchMap", "v", "stackCheckpoints", "checkpoints", "Object", "assign", "x", "throwIfIsStorageWriteError", "collection", "writeData", "status", "newRxError", "name", "id", "writeError", "data", "categorizeBulkWriteRows", "docsInDb", "bulkWriteRows", "onInsert", "onUpdate", "hasAttachments", "attachments", "bulkInsertDocs", "bulkUpdateDocs", "errors", "eventBulkId", "randomToken", "eventBulk", "checkpoint", "eventBulkEvents", "attachmentsAdd", "attachmentsRemove", "attachmentsUpdate", "hasDocsInDb", "size", "newestRow", "rowAmount", "_loop", "rowId", "document", "previous", "docId", "documentDeleted", "_deleted", "previousDeleted", "documentInDb", "get", "attachmentError", "insertedIsDeleted", "entries", "_attachments", "forEach", "attachmentId", "attachmentData", "isError", "push", "digest", "stripAttachmentsDataFromRow", "event", "operation", "stripAttachmentsDataFromDocument", "previousDocumentData", "revInDb", "_rev", "err", "updatedRow", "keys", "previousAttachmentData", "newDigest", "eventDocumentData", "previousEventDocumentData", "args", "getAttachmentSize", "attachmentBase64String", "atob", "attachmentWriteDataToNormalData", "type", "useDoc", "flatClone", "flatCloneDocWithMeta", "_meta", "getWrappedStorageInstance", "database", "rxJsonSchema", "overwritable", "deepFreezeWhenDevMode", "originalStorageInstance", "internals", "collectionName", "databaseName", "options", "rows", "databaseToken", "token", "toStorageWriteRows", "Array", "time", "now", "index", "lwt", "createRevision", "runPluginHooks", "lockedRun", "useWriteResult", "BULK_WRITE_ROWS_BY_RESPONSE", "set", "reInsertErrors", "reInsertIds", "Set", "reInserts", "add", "subResult", "appendToArray", "successArray", "subSuccess", "query", "preparedQuery", "count", "ids", "deleted", "getAttachmentData", "getChangedDocumentsSince", "limit", "cleanup", "minDeletedTime", "remove", "storageInstances", "delete", "close", "ensureRxStorageInstanceParamsAreCorrect", "params", "keyCompression", "hasEncryption", "compression", "jsonSchema", "encrypted", "getChangedDocumentsSinceQuery", "sinceLwt", "RX_META_LWT_MINIMUM", "sinceId", "normalizeMangoQuery", "selector", "$or", "$gt", "$eq", "$gte", "sort", "skip", "prepareQuery", "result", "documents", "lastDoc", "lastOfArray", "WeakMap", "BULK_WRITE_SUCCESS_MAP", "writeRows", "response", "getFromMapOrCreate", "realWriteRows", "errorIds", "has", "randomDelayStorage", "input", "randomDelayStorageWriteQueue", "PROMISE_RESOLVE_TRUE", "retStorage", "storage", "rxdbVersion", "RXDB_VERSION", "createStorageInstance", "promiseWait", "delayTimeBefore", "delayTimeAfter", "a", "b", "then", "c", "now"]
}
